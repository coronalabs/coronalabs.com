<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Guest Bloggers &#8211; Corona Labs</title>
	<atom:link href="/blog/topics/guest-bloggers/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description></description>
	<lastBuildDate>Mon, 19 Oct 2020 12:16:12 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.8</generator>

<image>
	<url>/wordpress/wp-content/uploads/2017/06/cropped-icon_32x32@2x-32x32.png</url>
	<title>Guest Bloggers &#8211; Corona Labs</title>
	<link>/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Understanding Gamers and Gameplay: Moving Beyond the Genre</title>
		<link>/blog/2017/05/23/understanding-gamers-and-gameplay-moving-beyond-the-genre/</link>
		<pubDate>Tue, 23 May 2017 18:43:04 +0000</pubDate>
		<dc:creator><![CDATA[Rob Miracle]]></dc:creator>
				<category><![CDATA[Game Development]]></category>
		<category><![CDATA[Guest Bloggers]]></category>

		<guid isPermaLink="false">/?p=70835</guid>
		<description><![CDATA[Understanding what motivates players is important for building compelling games. In this guest post from Appodeal, learn how players "think" about games.]]></description>
				<content:encoded><![CDATA[<p>Our parent company <a href=http://www.appodeal.com/ target="_blank" rel="noopener">Appodeal</a> shares some important DNA with Corona Labs. We all love games and we love helping developers make the most <em>from</em> their games. Appodeal&#8217;s Japneet Kaur recently <a href=https://blog.appodeal.com/blog/2017/04/05/gamers-and-gameplay-beyond-the-genre/ target="_blank" rel="noopener">wrote an article</a> focused on helping developers understand gamers and gameplay.</p>
<p><img class="alignnone size-full wp-image-70836" src="/wordpress/wp-content/uploads/2017/05/casual-gamer-2.jpg" alt="casual-gamer" width="750" height="250" /></p>
<p>This article dives into what motivates different people when it comes to gameplay. With this information, you can plan features in your game that can appeal to the different categories of players, extending your game&#8217;s reach and overall appeal.</p>
<div class="align-wrap" style="text-align: center; margin-top: 35px; margin-bottom: 35px;">
<p><a class="btn btn_cta btn-lg btn-solid base_clr_bg " href=https://blog.appodeal.com/blog/2017/04/05/gamers-and-gameplay-beyond-the-genre/ target="_blank" rel="noopener">Read the article</a></p>
<style>
.btn_cta { border-color: #ff6300; background-color: #ff6300; }<br /></style>
</div>
<div class="align-wrap" style="text-align: center; margin-top: 35px; margin-bottom: 35px;"></div>
<p><em>*Featured image by Mary Varn at <a href=http://www.npccomic.com/>NPC Comic</a>!</em></p>
]]></content:encoded>
			</item>
		<item>
		<title>Tutorial: Responsive Real-Time Searching</title>
		<link>/blog/2015/05/12/tutorial-responsive-real-time-searching/</link>
		<comments>/blog/2015/05/12/tutorial-responsive-real-time-searching/#comments</comments>
		<pubDate>Tue, 12 May 2015 20:46:09 +0000</pubDate>
		<dc:creator><![CDATA[Charles McKeever]]></dc:creator>
				<category><![CDATA[Guest Bloggers]]></category>
		<category><![CDATA[Tutorials, Tips and Demos]]></category>
		<category><![CDATA[searching]]></category>
		<category><![CDATA[tutorial]]></category>

		<guid isPermaLink="false">/?p=62743</guid>
		<description><![CDATA[In this tutorial, learn a simple technique which you can use to implement real-time data searches that produce responsive feedback and updates in your apps.]]></description>
				<content:encoded><![CDATA[<p><em>Today&#8217;s guest tutorial comes to you courtesy of Corona Ambassador and Portland, Oregon app developer Ed Maurina. Ed is a regular contributor to the weekly <a href=/community/corona-geek/ target="_blank">Corona Geek</a> hangouts and an active member of the Corona community. He has developed games for REEL FX Studios and maintains his Corona SSK game development library. Check out his work and blog at <a href=http://roaminggamer.com/>RoamingGamer.com</a>.</em></p>
<hr />
<p>In this tutorial, we will discuss a simple technique which you can use to implement real-time data searches that produce responsive feedback and updates in your apps.</p>
<h3>The Challenge</h3>
<p>If you have ever tried to implement a real-time search, you will be aware that it can be difficult to maintain application responsiveness for large data sets and/or dynamically changing search criteria.</p>
<p>For example, your application may have these requirements:</p>
<ul>
<li>The app has a massive data set.</li>
<li>The data set needs to be searchable.</li>
<li>Searches need to execute as soon as a user starts entering the search criteria.</li>
<li>When the search criteria change, the search should automatically adjust in real-time.</li>
<li>Matching entries are returned as they are found, updating the app interface.</li>
<li>The app should remain responsive.</li>
</ul>
<p>The last requirement is critical. If your app hangs or has temporary hiccups while a search executes, you may as well not distribute it.</p>
<p>So, how to do this?</p>
<h3>The Sample App</h3>
<p>To demonstrate a solution to the general problem above, let me specify an exact application and then provide code which solves the problem.</p>
<p>This application will have the following features:</p>
<ul>
<li><strong>Large Data Set</strong> &#8212; A simple word list containing over 100,000 words.</li>
<li><strong>FPS Counter</strong> &#8212; A simple FPS counter will be shown at all times to give concrete proof of responsiveness.</li>
<li><strong>Search Field</strong> &#8212; A single text entry field (works on devices and in both Simulators).</li>
<li><strong>Progress Counters</strong> &#8212; Meters to show total words, words found, and current search index.</li>
<li><strong>Results List</strong> &#8212; A basic (non-scrollable list) of words as they are found.</li>
</ul>
<h3>The App Modules</h3>
<p>The <a href=https://github.com/roaminggamer/RG_FreeStuff/raw/master/AskEd/2015/05/responsiveSearches/code.zip target="_blank">sample code</a> has several modules, found in Lua files of the same name:</p>
<ul>
<li><code>common.lua</code> &#8212; Calculates and discovers useful variables and flags (<code>left</code>, <code>right</code>, <code>centerX</code>, <code>onSimulator</code>, etc.).</li>
<li><code>wordList.lua</code> &#8212; Generates the data set.</li>
<li><code>meter.lua</code> &#8212; Creates a framerate meter.</li>
<li><code>searchField.lua</code> &#8212; Creates a &#8220;text input field&#8221; for our search that will work on devices and both Simulators (also creates count and index counters).</li>
<li><code>example.lua</code> &#8212; The solution to the problem posed at the start of this article.</li>
</ul>
<h3>Initialize Search Settings</h3>
<p>Before we start the <code>"enterFrame"</code> listener, we need to initialize the module:</p>
<ol>
<li>Create and position initial results display group.</li>
<li>Initialize flags and variables to starting values.</li>
<li>Set how many comparisons we&#8217;re allowed to do per frame.</li>
</ol>
<p></p><pre class="crayon-plain-tag">function example.init( maxTime )
    -- 1.
    foundGroup = display.newGroup()
    foundGroup.y = com.top + 60

    -- 2.
    searching = false -- Not currently searching
    lastTerm = &quot;&quot; -- No search term yet.
    curIndex = 1 -- On first word in word list.
    foundCount = 0 -- No words found yet.

    -- 3.
    searchTime = maxTime or (1000/display.fps/2)
end</pre><p>Notice that in step #3, when we initialize the search code, if we don&#8217;t specify a specific time, the code automatically detects the FPS (as set in <code>config.lua</code>) and then calculates a time equal to half of one frame.</p>
<h3>The &#8220;enterFrame&#8221; Listener</h3>
<p>Once the module is initialized, we can define the <code>"enterFrame"</code> listener and start it running. The definition has five parts.</p>
<h4>Part 1 &#8212; Get the current search term and see if it has changed</h4>
<p></p><pre class="crayon-plain-tag">local searchTerm = searchField.getSearchTerm()
if ( lastTerm ~= searchTerm ) then
    example.resetResults()
    lastTerm = searchTerm
    searching = ( string.len( searchTerm ) &gt; 0 )
end</pre><p>If the search results have changed, we reset the search results (similar to initialization of module), take note of the new search term, and set flags saying that we are &#8220;searching.&#8221; If they have not, we simply ignore this bit of code and continue on.</p>
<h4>Part 2 &#8212; Abort if not &#8220;searching&#8221;</h4>
<p></p><pre class="crayon-plain-tag">if ( not searching ) then return end</pre><p>If the <code>searching</code> flag is set to false, we abort early and wait for the next frame to start again.</p>
<h4>Part 3 &#8212; Search until we are out of time, or at the end of the word list</h4>
<p>While each of the above modules may be useful and interesting, we will focus only on <code>example.lua</code>.</p>
<h4>The Solution</h4>
<p>After this build up, you may be disappointed to see that this is basically a self-regulating <code>"enterFrame"</code> listener. In a nutshell, the listener starts a new search whenever the search criteria change and searches in a tight loop till a set amount of time passes. It then stops searching and exits. On the next frame, the entire sequence starts again.</p>
<p>The listener has this logical structure:</p>
<p><img class="wp-image-62745 size-full" style="margin: 0px 0px 20px 0px;" src="/wordpress/wp-content/uploads/2015/05/responsive-real-time-searching-diagram.png" alt="Responsive Real-time Searching Logic Flowchart" width="606" height="547" /></p>
<p>Now let&#8217;s look at the actual code.</p><pre class="crayon-plain-tag">local getTimer = system.getTimer -- localize for speedup
local strLower = string.lower -- localize for speedup
local startTime = getTimer()
local elapsedTime = 0

while ( elapsedTime &lt; searchTime and curIndex &lt;= #wordList ) do
    local curWord = wordList[curIndex]
    if ( string.match( strLower(curWord), strLower( searchTerm ) ) ~= nil ) then
        example.drawResult( curWord )
    end
    elapsedTime = getTimer() - startTime
    curIndex = curIndex + 1
end</pre><p>This code:</p>
<ul>
<li>Localizes some useful functions for an execution speedup.</li>
<li>Takes note of the <code>startTime</code>.</li>
<li>Sets <code>elapsedTime</code> to zero.</li>
<li>Enters a search loop and does not exit until it get to the end of the list or runs out of time.</li>
<li>Upon finding match, the code displays it, and continues.</li>
</ul>
<p>This is the meat of the solution and you should understand that by measuring &#8220;elapsed time&#8221; each time we search and (possibly) display results, we ensure that:</p>
<ol>
<li>The search can give us as soon as it needs to and not block the completion of this frame.</li>
<li>The code that stops and resumes searching is dynamic and takes into account the cost of the search and displaying the results.</li>
</ol>
<h4>Part 4 &mdash; Update the search index label</h4>
<p></p><pre class="crayon-plain-tag">searchField.setSearchIndex( curIndex )</pre><p>(<em>Note that this part is purely for feedback in the example</em>)</p>
<h4>Part 5 &mdash; Check to see if we reached the end of list, and quit if so</h4>
<p></p><pre class="crayon-plain-tag">searching = curIndex &lt; #wordList</pre><p>As a final step in the listener, we check to see if the end of the word list was reached. If it was, we set <code>searching</code> to false. In either case, we drop out of the function (it will execute again at the beginning of the next frame).</p>
<h3>In Conclusion</h3>
<p>As I mentioned above, this blog post <a href=https://github.com/roaminggamer/RG_FreeStuff/raw/master/AskEd/2015/05/responsiveSearches/code.zip target="_blank">comes with sample code</a>, so please experiment with it in your own apps. Hopefully this tutorial has shown you an interesting methodology to implement real-time, responsive searching in your project.</p>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2015/05/12/tutorial-responsive-real-time-searching/feed/</wfw:commentRss>
		<slash:comments>6</slash:comments>
		</item>
		<item>
		<title>Tutorial: The Finalize API (an Unsung Hero)</title>
		<link>/blog/2015/05/05/tutorial-the-finalize-api-an-unsung-hero/</link>
		<comments>/blog/2015/05/05/tutorial-the-finalize-api-an-unsung-hero/#comments</comments>
		<pubDate>Tue, 05 May 2015 22:43:20 +0000</pubDate>
		<dc:creator><![CDATA[Brent Sorrentino]]></dc:creator>
				<category><![CDATA[Guest Bloggers]]></category>
		<category><![CDATA[Tutorials, Tips and Demos]]></category>
		<category><![CDATA[event listeners]]></category>
		<category><![CDATA[finalize]]></category>
		<category><![CDATA[tutorial]]></category>

		<guid isPermaLink="false">/?p=62646</guid>
		<description><![CDATA[In this tutorial, learn about the under-utilized but powerful "finalize" event and how it can be used to keep your app running smoothly.]]></description>
				<content:encoded><![CDATA[<p><em>Jason Schroeder is a New York City-based app developer and Corona Ambassador who has released seven Corona-made apps since he began using Corona SDK in 2011. He is currently working on an independent reboot of the 21-year-old Abrosia Software game “Chiral,” which he expects to release later this year. You can follow Jason on Twitter <strong>@schroederapps</strong> and learn more about Chiral at <a href=http://www.chiralgame.com/ target="_blank">www.chiralgame.com</a>.</em></p>
<hr />
<p>There are over 1,000 Lua APIs for Corona SDK, according to the API Reference. While certain APIs, such as those found in the <a href=https://docs.coronalabs.com/api/library/display/index.html target="_blank">display</a>, <a href=https://docs.coronalabs.com/api/library/audio/index.html target="_blank">audio</a>, and <a href=https://docs.coronalabs.com/api/library/composer/index.html target="_blank">composer</a> libraries are so essential that even the most &#8220;newbie&#8221; developers become instantly familiar with them, there&#8217;s a huge advantage to be gained by regularly browsing the online documentation and discovering hidden gems that you may not have noticed when teaching yourself the basics. One great example of this is the <a href=https://docs.coronalabs.com/api/event/finalize/index.html target="_blank">finalize</a> event API, which gets scandalously little recognition given how useful it is.</p>
<h3>About Events</h3>
<p>Every Corona display object can (and does) dispatch “events” (which take the form of Lua tables) on a regular basis, even if you aren&#8217;t aware of these events or aren&#8217;t responding to them in your code. For example, if a user touches a display object, that object always dispatches an event table containing key/value pairs such as a reference to the dispatching object (<code>event.target</code>) and the coordinates where the user&#8217;s finger is touching the screen (<code>event.x</code> and <code>event.y</code>), among others. By adding a listener function to handle these dispatched events using the <a href=https://docs.coronalabs.com/api/type/EventListener/addEventListener.html target="_blank">object:addEventListener()</a> API, you can make your app respond to this user input. But even if you don&#8217;t add a listener for them, every display object in your app is dispatching &#8220;touch&#8221; events anytime the user&#8217;s finger happens to touch them.</p>
<p>Not unlike touch events, any time a display object is removed from the stage &#8212; usually by calling <a href=http://docs.coronalabs.com/api/library/display/remove.html target="_blank">display.remove()</a> or <a href=http://docs.coronalabs.com/api/type/DisplayObject/removeSelf.html target="_blank">object:removeSelf()</a> &#8212; that object dispatches a <a href=https://docs.coronalabs.com/api/event/finalize/index.html target="_blank">finalize</a> event. I&#8217;d imagine that many Corona developers don&#8217;t bother handling these events, but being able to perform specific actions just as a display object is being destroyed has all sorts of useful applications. I&#8217;ll explore one specific example later on in this post, but first let&#8217;s go over how to listen for finalize events and handle the data that gets passed into our listener function.</p>
<h3>Listening for Finalize Events</h3>
<p>Just like touch listeners, a finalize listener can take the form of a “table listener” or a “function listener.” For the purposes of this tutorial, I&#8217;m going to focus on using a table listener because it&#8217;s my preferred method &#8212; but either type of listener will work, and you should use whatever method works best for you. If you don’t know the difference between these types of listeners, you can read more about it <a href=http://docs.coronalabs.com/daily/guide/events/detectEvents/index.html?#functionvstable target="_blank">here</a>.</p>
<p>Listening for finalize events requires 3 basic steps. First, we create our listener function:</p><pre class="crayon-plain-tag">local function finalizeListener( self, event )
   -- do something when &quot;self&quot; is removed from the stage
   print( &quot;Object removed from stage: &quot;..tostring(self) )
end</pre><p>Next, we add a <code>.finalize</code> property to a display object, pointing to our listener function:</p><pre class="crayon-plain-tag">object.finalize = finalizeListener</pre><p>And finally, we add an event listener to that same object, listening for <code>"finalize"</code> events:</p><pre class="crayon-plain-tag">object:addEventListener( &quot;finalize&quot; )</pre><p>Now, whenever that display object is removed from the stage, our listener function will be triggered, and the console will print out the string <code>"Object removed from stage:"</code> followed by the object&#8217;s table ID.</p>
<h3>Why You Should Use Finalize Listeners</h3>
<p>The code above shows <i>how</i> to listen for finalize events and respond to them, but it doesn&#8217;t really showcase why this is so useful. Honestly, the potential applications of finalize listeners are only limited by your imagination, and the usefulness will depend on the needs of your app &#8212; but let’s look at one specific scenario where a finalize listener can help keep your app running smoothly.</p>
<p>In some cases, you may need to have a display object update itself on every single frame of your app. For example, you could have a text object that displays the user&#8217;s score that needs to be constantly updated, or you might have a character sprite that needs to be repositioned on every frame to keep it centered on the screen. The best way to accomplish these continual updates is through a Runtime <a href=http://docs.coronalabs.com/api/event/enterFrame/index.html target="_blank">enterFrame</a> listener, which is a function that is called every time your app draws a new &#8220;frame.&#8221;</p>
<p>While <a href=http://docs.coronalabs.com/api/event/enterFrame/index.html target="_blank">enterFrame</a> listeners are great tools because they can be run as often as 60 times per second, they can also wreak havoc if you have any errors in your code. And if you attempt to manipulate a display object that has been destroyed in an <a href=http://docs.coronalabs.com/api/event/enterFrame/index.html target="_blank">enterFrame</a> listener (or any <code>nil</code> object), you&#8217;re going to get hit with a show-stopping Runtime error. This is avoided by removing your <a href=http://docs.coronalabs.com/api/event/enterFrame/index.html target="_blank">enterFrame</a> listener before it can attempt to manipulate your soon-to-be-removed display object. While it’s possible to manage this manually, removing <a href=http://docs.coronalabs.com/api/event/enterFrame/index.html target="_blank">enterFrame</a> listeners in the same block of code that destroys your display object, you can save yourself time and headaches by utilizing finalize listeners to automate this process for you, especially in circumstances where you will be removing lots of objects with regularity.</p>
<p>Below is a simple <code>main.lua</code> that creates an app that does the following:</p>
<p>It creates a circle that can be dragged around the screen.</p>
<p>It uses an <a href=http://docs.coronalabs.com/api/event/enterFrame/index.html target="_blank">enterFrame</a> listener to resize the circle as it is dragged, depending on how close it is to the center of the screen</p>
<p>Releasing your finger from the circle will remove the circle from the stage, using <a href=https://docs.coronalabs.com/api/library/display/remove.html target="_blank">display.remove()</a> and re-draw a new circle 500 milliseconds later.</p><pre class="crayon-plain-tag">-- forward declare functions
local onEnterFrame, finalizeListener, touchListener, createCircle

-- function to calculate distance between two points
local function getDistance ( x1, y1, x2, y2 )
   local dx = x1 - x2
   local dy = y1 - y2
   return math.sqrt ( dx * dx + dy * dy )
end

-- enterFrame listener
function onEnterFrame( self, event )
   local distance = getDistance( self.x, self.y, display.contentCenterX, display.contentCenterY )
   local scale = 1 - distance*.005
   self.xScale, self.yScale = scale, scale
end

-- finalize listener
function finalizeListener( self, event )
   Runtime:removeEventListener( &quot;enterFrame&quot;, self )
   print( &quot;Removed enterFrame Listener for &quot;..tostring(self) )
   timer.performWithDelay( 500, createCircle )
end

-- touch listener
function touchListener( self, event )
   if event.phase == &quot;began&quot; then
      display.getCurrentStage():setFocus( self, event.id )
      self.hasFocus = true
   elseif self.hasFocus then
      self.x, self.y = event.x, event.y
      if event.phase == &quot;ended&quot; or event.phase == &quot;cancelled&quot; then
         self.hasFocus = false
         display.getCurrentStage():setFocus( nil, event.id )
         display.remove( self )
      end
   end
end

-- function to create a new circle and add listeners to it
function createCircle()
   local circle = display.newCircle( display.contentCenterX, display.contentCenterY, display.contentHeight*.075 )
   circle.finalize = finalizeListener
   circle:addEventListener( &quot;finalize&quot; )
   circle.enterFrame = onEnterFrame
   Runtime:addEventListener( &quot;enterFrame&quot;, circle )
   circle.touch = touchListener
   circle:addEventListener( &quot;touch&quot; )
end

-- create the first circle
createCircle()</pre><p>Since there is an <a href=http://docs.coronalabs.com/api/event/enterFrame/index.html target="_blank">enterFrame</a> listener used to manipulate the circle, the app will crash if that function is run after removing the circle from the stage. To see this in action, simply comment out line 43 from the code above and run it in the Corona Simulator. As soon as you release your finger from the circle and the circle is removed, you’ll get the following Runtime error:</p>
<p><a href=/wordpress/wp-content/uploads/2015/05/finalize-error1.png><img class="alignnone wp-image-62653" src=/wordpress/wp-content/uploads/2015/05/finalize-error1.png alt="finalize-error" width="800" height="338" /></a></p>
<p>This crash occurs because line 43 is necessary to add our finalize listener to the circle, ensuring that the <a href=http://docs.coronalabs.com/api/event/enterFrame/index.html target="_blank">enterFrame</a> listener is removed when the circle is destroyed. That little listener function is mighty helpful! Keep in mind, also, that the finalize listener in the above code is re-usable: you can add it to any display objects (not just the circle) by setting an object’s <code>.finalize</code> property to &#8220;<code>finalizeListener"</code> and adding a &#8220;<code>finalize"</code> event listener to that object. If your app creates a lot of objects that need to be updated in an <a href=http://docs.coronalabs.com/api/event/enterFrame/index.html target="_blank">enterFrame</a> listener, having just one finalize listener to handle cleanup of those <a href=http://docs.coronalabs.com/api/event/enterFrame/index.html target="_blank">enterFrame</a> listeners can be a real sanity-saver.</p>
<h3>In Conclusion</h3>
<p>This just shows one possible application of finalize listeners, but I hope it gets you thinking about ways you can use Corona’s 1,000+ APIs to streamline your code and help make your development work faster and easier to manage. If you have come up with any especially creative uses of the finalize event API, please share in the comments &#8212; happy coding!</p>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2015/05/05/tutorial-the-finalize-api-an-unsung-hero/feed/</wfw:commentRss>
		<slash:comments>4</slash:comments>
		</item>
		<item>
		<title>Guest Post: Building a Beautiful Business App with Corona</title>
		<link>/blog/2015/04/29/guest-post-building-a-beautiful-business-app-with-corona/</link>
		<comments>/blog/2015/04/29/guest-post-building-a-beautiful-business-app-with-corona/#comments</comments>
		<pubDate>Wed, 29 Apr 2015 14:00:38 +0000</pubDate>
		<dc:creator><![CDATA[david]]></dc:creator>
				<category><![CDATA[Corona SDK]]></category>
		<category><![CDATA[Guest Bloggers]]></category>

		<guid isPermaLink="false">/?p=62587</guid>
		<description><![CDATA[This post comes courtesy of David Haynes, a Corona developer at <a href="https://shawfloors.com/">Shaw Floors</a>. The app, <a href="https://itunes.apple.com/us/app/floorvana-by-shaw-floors/id945472387?mt=8">Floorvana</a>, is available on the iTunes App Store and is currently being featured in a TV commercial airing on the DYI Network and HGTV!]]></description>
				<content:encoded><![CDATA[<p><em>This post comes courtesy of David Haynes, a Corona developer at <a href=https://shawfloors.com/>Shaw Floors</a>. The app, <a href=https://itunes.apple.com/us/app/floorvana-by-shaw-floors/id945472387?mt=8>Floorvana</a>, is available on the iTunes App Store and is currently being featured in a TV commercial airing on the DYI Network and HGTV the week of 4/27-5/03/15. See the video at the bottom of this post. Thanks David!</em></p>
<hr>
<p>Back in mid-December, we released a business app written with Corona SDK &#8212; Floorvana by Shaw Floors.  Floorvana was designed to help a consumer choose the perfect flooring product (or at least narrow the search) by creating a color palette from her own photo(s), then providing options to best match her inspiration.</p>
<p><img src="/wordpress/wp-content/uploads/2015/04/image1.jpg" alt="image1" width="480" height="360" class="alignnone size-full wp-image-62593" /></p>
<p>We just launched the project in a more official way this past week at the Shaw AWESOME convention in Orlando, FL, and it was a massive hit. Shaw has really put a lot of effort into marketing the app, and I think you&#8217;ll start to see it pop up a lot more all over the place. Many of the dealers will be placing Floorvana kiosks in their stores too.</p>
<p>When I arrived at our hotel in Orlando, there were Shaw banners everywhere, which made sense, but I was blown away by perhaps the simplest thing &#8212; the room key.</p>
<p><img src="/wordpress/wp-content/uploads/2015/04/image2.jpg" alt="image2" width="480" height="640" class="alignnone size-full wp-image-62592" /></p>
<p>That&#8217;s our app on the room key! Holy crap!</p>
<p>They also had stand up things like this everywhere:</p>
<p><img src="/wordpress/wp-content/uploads/2015/04/image3.jpg" alt="image3" width="480" height="640" class="alignnone size-full wp-image-62591" /></p>
<p>And it was on displayed (in rotation) on the 4-sided jumbotron in the center of the convention:</p>
<p><img src="/wordpress/wp-content/uploads/2015/04/image4.jpg" alt="image4" width="480" height="640" class="alignnone size-full wp-image-62590" /></p>
<p>It was also featured on tons of swag that was given away, including pens, bracelets, and bags.  Everywhere we went at this massive hotel/conference center, there was something that said Floorvana.  The keynote presentation that day started out with a performance from Team Iluminate, whom I highly recommend checking out on YouTube. The fact that the app I&#8217;ve been developing was talked about during that same keynote is a little bit mind blowing for me.</p>
<p><img src="/wordpress/wp-content/uploads/2015/04/image5.jpg" alt="image5" width="823" height="520" class="alignnone size-full wp-image-62589" /></p>
<p>As the lead developer on the project, I received a good bit of flak for using Corona SDK for a business app because &#8220;it&#8217;s just for games!&#8221;  In my mind, though, it was a great way to save time and effort, in order to get the project where it needed to be more quickly.  Our design team created a user experience that was easy to use, compelling, and platform-agnostic, so it looked equally at home on iOS or Android.</p>
<p>It also looked pretty great streamed (with an Apple TV) to a 50&#8243; television designed to look like a giant iPhone:</p>
<p><img src="/wordpress/wp-content/uploads/2015/04/image6.jpg" alt="image6" width="640" height="480" class="alignnone size-full wp-image-62588" /></p>
<p>As we developed Floorvana, just like with any software project, we had a few challenges, but we always received help and guidance from the Corona staff and community. The new textfield scaling improvements could not have come at a better time.  And Sergey Lerg&#8217;s latest config.lua helped correct some visual discrepancies as well, so thanks for that!</p>
<p>I think we&#8217;ve proven that with a good design, Corona is more than capable of handling business apps.</p>
<p>View more information, including the commercial for Floorvana (which looks incredible to me, but i&#8217;m biased), here:<br />
<a href=http://shawfloors.com/floorvana>http://shawfloors.com/floorvana</a></p>
<p><iframe width="560" height="315" src="https://www.youtube.com/embed/Zfm0dJHbKFg" frameborder="0" allowfullscreen></iframe></p>
]]></content:encoded>
			<wfw:commentRss>/blog/2015/04/29/guest-post-building-a-beautiful-business-app-with-corona/feed/</wfw:commentRss>
		<slash:comments>9</slash:comments>
		</item>
		<item>
		<title>Knitty Kitty: Achieving the Impossible in 8 Hours</title>
		<link>/blog/2015/04/23/knitty-kitty-achieving-the-impossible-in-8-hours/</link>
		<comments>/blog/2015/04/23/knitty-kitty-achieving-the-impossible-in-8-hours/#comments</comments>
		<pubDate>Thu, 23 Apr 2015 21:04:19 +0000</pubDate>
		<dc:creator><![CDATA[Brent Sorrentino]]></dc:creator>
				<category><![CDATA[Game Development]]></category>
		<category><![CDATA[Guest Bloggers]]></category>
		<category><![CDATA[Corona SDK]]></category>

		<guid isPermaLink="false">/?p=62537</guid>
		<description><![CDATA[In this guest post, the folks at Playcrafting and Simple Machine discuss how a match three puzzle game was developed in Corona SDK within a single eight hour session, from design decisions to code editing to assembly of promotional material leading up to the game's release.]]></description>
				<content:encoded><![CDATA[<p><i>This guest post comes to you courtesy of Dan Butchko at Playcrafting and Kurt Bieg at </i><a href=http://www.simplemachine.co/ target="_blank"><i>Simple Machine</i></a><i>. Playcrafting offers workshops, classes, and events for game developers and those aspiring to make games. To learn more and see what they have coming up, check out </i><a href=http://www.playcrafting.com/ target="_blank"><i>Playcrafting.com</i></a><i>. You can download the game discussed in this post from </i><a href=https://play.google.com/store/apps/details?id=com.playcrafting.knittykitty&hl=en target="_blank"><i>the Google Play Store</i></a><i>.</i></p>
<hr />
<p>Late one winter day in New York City, we met to plan upcoming game classes for the robust community of skilled game developers that Playcrafting serves. We started to kick around ideas for educational content that would push the boundaries of traditional instruction. There are plenty of &#8220;Learn X in a day&#8221; classes and workshops, but we realized that none took that next step to show how much goes into the actual release of a game.</p>
<p>That&#8217;s when we jumped at the idea of doing a one-day workshop where the group designs a game from start to finish, then releases it on the store. As an alternative education provider without the recognition of an established university, it’s always a challenge at Playcrafting to show potential students the direct takeaways they will receive from a one-day workshop. We kept thinking about how amazing it would be for students to see their game available for download to the public by the time they got home from the full day workshop.</p>
<p>On the flip side, we realized how groundbreaking this experience would be by showing people just how much work goes into the release of a game, not just on the development side, but also in marketing preparation from creating promotional images to writing the description and uploading the build. Anyone who has shipped a game can tell you that once you&#8217;re done coding, you&#8217;re only half done with getting your game in the hands of players. There&#8217;s all this additional work needed to make your game available to the public, and you can feel blindsided if you don&#8217;t know about it.</p>
<p>The end result of our planning was our “Release Your First Game: Puzzle Edition!” full day workshop. We somehow came up with the perfect takeaway for students: Design and release a game in one day with your name on it. What better way to inspire newcomers to start making games or re-energize veteran developers?</p>
<h3>From the Start</h3>
<p>In one very short eight hour session, we transformed the room into a temporary development studio. Kurt led the group to make live design decisions, edit code and assemble promotional material leading up to release of the game on Google Play at the end of the day. To expedite the process of development and release in one short day, we chose to do a match three puzzle game using Corona SDK.</p>
<p>Working off of a shared Game Design Document, attendees contributed ideas and assets throughout the day. The group used a basic match three puzzle game template as a starting point to then create their own game using Corona SDK. The entire class designed concepts that changed the game in completely unpredictable ways. By the end, we were sifting through ideas and prototyping them live. After settling on a brilliant mechanic where only one piece on the board can be swapped, the class came up with a bunch of themes for the game. Ultimately we arrived at cats, ‘nuff said. The theme of the game became a cat that can move around the board and swap different colored balls of yarn to make a match of three or more. It wasn&#8217;t perfect at first and required several rounds of iteration and testing on Corona SDK, but the team kept pushing until we had something that worked.</p>
<h3>To the End</h3>
<p><a href=/wordpress/wp-content/uploads/2015/04/knitty-kitty-2.jpg><img class="alignright wp-image-62541" style="margin: 0px 0px 20px 25px;" src=/wordpress/wp-content/uploads/2015/04/knitty-kitty-2.jpg alt="knitty-kitty-2" width="260" height="390" /></a>After the game was complete, we had to switch gears and set up the store. With only a few hours left, we generated screenshots, collaborated on a description and came up with too many good names (imagine infinite cat puns). Of course, once &#8220;Knitty Kitty&#8221; was on the table, nothing else even came close. Students jumped in to apply their own skill sets to assets that were needed. One handled the logo, a sub-group whipped up a great description and others used the character and tile assets to enhance sample screens.</p>
<p>It was a mad dash to the end to get the game built out and published to the Google Play Store, but we managed to pull it off. Lo and behold, by the time 5pm came around, we were ecstatic about the success of our mock dev team and Knitty Kitty was live on the store. Students were thrilled to take photos of the build loading into the store and grab the code so they could head home and continue tweaking it in Corona SDK.</p>
<p>This trial workshop was such a success that we’re now doing it once per month using different game genres. It was tremendously empowering for attendees to see how easy and fun it can be to make games. We somehow achieved the impossible — transforming a room of strangers into a team of developers then building and publishing a game in one day. And we would not have been able to do so without the Playcrafting’s enthusiastic community or the ease and accessibility of Corona SDK.</p>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2015/04/23/knitty-kitty-achieving-the-impossible-in-8-hours/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>Guest Post: Building a Custom Launcher with CoronaCards</title>
		<link>/blog/2015/04/09/guest-post-building-a-custom-launcher-with-coronacards/</link>
		<comments>/blog/2015/04/09/guest-post-building-a-custom-launcher-with-coronacards/#comments</comments>
		<pubDate>Thu, 09 Apr 2015 21:38:06 +0000</pubDate>
		<dc:creator><![CDATA[oleg]]></dc:creator>
				<category><![CDATA[CoronaCards]]></category>
		<category><![CDATA[Guest Bloggers]]></category>
		<category><![CDATA[guestpost]]></category>

		<guid isPermaLink="false">/?p=61888</guid>
		<description><![CDATA[Learn how Bonfire Media used <a href="http://coronacards.com/" target="_new">CoronaCards</a> to create "Aero Launcher," an enhanced launcher app for Android which has received almost 1,000,000 downloads.]]></description>
				<content:encoded><![CDATA[<p><em>Today&#8217;s feature comes to you courtesy of <a href=http://www.bonfiremedia.com/ target="_blank">Bonfire Media</a>. As a long-time veteran of the mobile software industry, Bonfire Media has been making apps and games for over 10 years, and in the last few years has been using Corona SDK for several projects. One of their most recent releases, <a href=https://play.google.com/store/apps/details?id=com.bonfiremedia.launcher target="_blank">Aero Launcher</a>, was built with <a href=http://coronacards.com/ target="_blank">CoronaCards</a> and has already received almost 1,000,000 downloads.</em></p>
<hr />
<p><b>What is Aero Launcher?</b></p>
<p>Before I describe <a href=https://play.google.com/store/apps/details?id=com.bonfiremedia.launcher target="_blank">Aero Launcher</a>, it probably makes sense to clarify what a &#8220;launcher&#8221; is. Almost everyone with a mobile device uses a launcher every day, as it&#8217;s simply the screen that appears on your smartphone or tablet when you hit the &#8220;home&#8221; button. Essentially, the launcher is the application we all use to launch and organize our apps and, as such, all mobile devices come with a built-in launcher. However, many people may not realize that, on Android devices, you can replace the boring stock launcher with an awesome, custom launcher.</p>
<p>Aero Launcher is one such custom launcher. Here&#8217;s a short video:</p>
<p><iframe width="1060" height="596" src="https://www.youtube.com/embed/QpmizVPRerE?feature=oembed" frameborder="0" gesture="media" allowfullscreen></iframe></p>
<p>Aero Launcher provides three main advantages over your default Android launcher:</p>
<ol>
<li>It automatically organizes all of your apps and games into simple tabs: <strong>Favorites</strong>, <strong>Apps</strong>, <strong>Games</strong> and <strong>System</strong>. Within each tab, you can optionally ask Aero to organize your apps even further into subcategories. This feature is great for users who don&#8217;t like to spend the time grouping all of their apps manually. In addition, you can easily move apps to your favorites tabs or uninstall unwanted apps by long-pressing an icon.</li>
<li>Aero brings your homescreen alive with beautiful wallpapers, animated particle effects, custom fonts, and unique sounds. Here is an example of the &#8220;Fireworks&#8221; theme which shoots fireworks whenever you touch the screen, and the &#8220;Snow&#8221; theme that features falling snow:<a href=/wordpress/wp-content/uploads/2015/03/aerolauncher.jpg><img class="alignnone size-full wp-image-61893" src=/wordpress/wp-content/uploads/2015/03/aerolauncher.jpg alt="aerolauncher" width="1290" height="940" /></a></li>
<li>Aero&#8217;s <strong>Genie</strong> tab recommends apps and games which you might enjoy, based on apps that you already have installed and use the most.</li>
</ol>
<h3>Why CoronaCards?</h3>
<p>Why did we use Corona products instead of opting for the fully native Java development route? First of all, we really wanted a smooth, 60 fps experience for our launcher, including smooth animations, particle effects, and game-like responsiveness. Corona is very good for this, and because we are very experienced with Corona, we knew that we could make great themes using Corona rather than native Java. Plus, playing with cool animations and effects is more fun in Corona than in Java!</p>
<p>So, why did we use <a href=http://coronacards.com/ target="_blank">CoronaCards</a> instead of simply Corona SDK? Well, one of the things which all custom launchers need is an inventory of all the apps that a user has installed. Corona SDK doesn&#8217;t have access to this information, but the native Android SDK does and we needed a way to check this. Thus, we were left with the choice between <a href=/products/enterprise/ target="_blank">Corona Enterprise</a> and CoronaCards. Both solutions would have worked, but the reason we went with CoronaCards is that we already had a large codebase from an old launcher we had written natively, and it felt simpler to embed a CoronaCards &#8220;view&#8221; into our existing launcher code rather than rewrite the bulk of our code in Lua and add native extensions.</p>
<p>Essentially we considered it like this: Corona Enterprise is ideal if you want to create your apps primarily in Lua and Corona SDK and then add native extensions whenever necessary. CoronaCards, on the other hand, is a better fit for developers writing the bulk of their code natively who would then like to utilize the power and simplicity of Corona SDK for aspects of the front-end UI. For Aero Launcher, we used CoronaCards not just for elements of our UI, but for the <em>entire</em> UI. This pushed the boundaries of CoronaCards in a few cases, but with the help of other Corona developers, we were able to make it work, and work very well. In the end, Aero Launcher&#8217;s codebase is about 50% Java and 50% Lua.</p>
<h3>Getting Aero Launcher</h3>
<p>Aero Launcher is currently available on <a href=https://play.google.com/store/apps/details?id=com.bonfiremedia.launcher target="_blank">Google Play</a>. Please try it out and let us know what you think!</p>
]]></content:encoded>
			<wfw:commentRss>/blog/2015/04/09/guest-post-building-a-custom-launcher-with-coronacards/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>Tutorial: Using Coroutines in Corona</title>
		<link>/blog/2015/02/10/tutorial-using-coroutines-in-corona/</link>
		<comments>/blog/2015/02/10/tutorial-using-coroutines-in-corona/#comments</comments>
		<pubDate>Tue, 10 Feb 2015 22:23:48 +0000</pubDate>
		<dc:creator><![CDATA[Brent Sorrentino]]></dc:creator>
				<category><![CDATA[Guest Bloggers]]></category>
		<category><![CDATA[Tutorials, Tips and Demos]]></category>
		<category><![CDATA[coroutine]]></category>
		<category><![CDATA[tutorial]]></category>

		<guid isPermaLink="false">/?p=61368</guid>
		<description><![CDATA[Coroutines, one of Lua's key features, are quite powerful and give you the ability to start and stop blocks of code as needed. From advanced timer manipulation to creating state machines, coroutines give you greater control over when parts of your code execute. This tutorial touches on just a few of their many uses, in particular those which play to Corona's own strengths.]]></description>
				<content:encoded><![CDATA[<p><em>Today&#8217;s guest tutorial comes to you courtesy of Steven Johnson, the Technical Director and head of R&amp;D at Xibalba Studios. Steven has been using Lua since 2003 and he has worked with custom engines, Vision SDK, LÖVE, HTML5 emulation, and projects with SDL bindings in C++ and LuaJIT. When he&#8217;s not working on his own hobby projects, he likes to research math and graphics concepts.</em></p>
<hr />
<p>Coroutines, <a href=http://www.jucs.org/jucs_10_7/coroutines_in_lua/de_Moura_A_L.html target="_blank">introduced in Lua 5.0</a>, are one of the language&#8217;s key features, but despite having been available in Corona from the beginning, they seem to receive very little attention. This is unfortunate, as coroutines are quite powerful, giving you the ability to start and stop blocks of code as needed. Whether you want to do advanced timer manipulation or create state machines, coroutines give you greater control over when the parts of your code execute. This tutorial will touch on just a few of their many uses, in particular those which play to Corona&#8217;s own strengths.</p>
<h3><a name="basics"></a>The Basics</h3>
<p>Let&#8217;s begin with a quick primer on the API. All functions are found in the <b>coroutine</b> table. As of this writing, these have not been included in Corona&#8217;s SDK API reference, but may be found in the <a href=http://www.lua.org/manual/5.1/manual.html?#5.2 target="_blank">Lua manual</a>.</p>
<p>Creating a coroutine is simple enough:</p><pre class="crayon-plain-tag">-- This is the &quot;routine&quot; part of the coroutine, the code that gets run...
local function Body()
    print( &quot;In the coroutine!&quot; )
end

-- ...and this is the object we need to run it.
local co = coroutine.create( Body )</pre><p>This gives us a reference, <code>co</code>, to the coroutine.</p>
<p>We can inspect its type:</p><pre class="crayon-plain-tag">print( type( co ) )  -- prints &quot;thread&quot;</pre><p>What we find is that <code>co</code> is a distinct kind of object, rather than a table or userdata as we might expect. Don&#8217;t worry too much about the term &#8220;thread&#8221;; in Lua, it and &#8220;coroutine&#8221; are mostly interchangeable<a name="from_note1"></a><a href="#note1">[1]</a>. Also, these are <b>not </b>operating system threads, which preempt running code to switch tasks. Rather, coroutines are collaborative; the coroutine itself decides when to give up control.</p>
<p>We can also ask about the coroutine&#8217;s status:</p><pre class="crayon-plain-tag">print( coroutine.status( co ) )  -- prints &quot;suspended&quot;</pre><p>As we can see, simply creating the coroutine doesn&#8217;t run it. This shouldn&#8217;t be too surprising. Creating a function, for instance, is distinct from calling it. To run the coroutine, we must do this:</p><pre class="crayon-plain-tag">coroutine.resume( co )  -- prints &quot;In the coroutine!&quot;</pre><p>The body executes, and the message inside gets printed, as expected.</p>
<p>What is the coroutine&#8217;s status now? Let&#8217;s check:</p><pre class="crayon-plain-tag">print( coroutine.status( co ) )  -- prints &quot;dead&quot;</pre><p>The body has run its course, so nothing remains for the coroutine to do, and it goes dead.</p>
<p>Once a coroutine is dead, all we can do with it is ask its status, which will always be <code>"dead"</code>. If we try to resume it once more, nothing happens. Or rather, as we&#8217;ll see shortly, it fails silently.</p>
<p>At this point, coroutines seem like nothing more than a complicated way to call a function once, and only once!</p>
<p>The missing piece of the puzzle is the ability to yield:</p><pre class="crayon-plain-tag">local function Body()
    print( &quot;First resume&quot; )

    coroutine.yield()

    print( &quot;Second resume&quot; )

    coroutine.yield()

    print( &quot;Final resume&quot; )
end

local co = coroutine.create( Body )

coroutine.resume( co )  -- prints &quot;First resume&quot;

print( &quot;After first yield&quot; )

coroutine.resume( co )  -- prints &quot;Second resume&quot;

print( &quot;After second yield&quot; )

coroutine.resume( co )  -- prints &quot;Final resume&quot;</pre><p>The first <code>coroutine.resume</code> kicks off the coroutine. The code at the beginning of the body executes, and a message is printed. So far, nothing new.</p>
<p>When the <code>coroutine.yield</code> fires, we suddenly hop outside of the coroutine&#8217;s body and back among the code that created it. Instead of getting the message <b>&#8220;Second resume&#8221;</b>, we see <b>&#8220;After first yield&#8221;</b>.</p>
<p>The coroutine is once again in a suspended state, just as it was after being created. It is <b>not</b> dead; there is still code left to execute. However, the coroutine won&#8217;t run again until we explicitly resume it.</p>
<p>When we do so, execution picks up where it left off, immediately after the yield, and we get the expected <b>&#8220;Second resume&#8221;</b>. Another yield and a final resume round out the snippet, giving us <b>&#8220;After second yield&#8221;</b> followed by <b>&#8220;Final resume&#8221;</b>.</p>
<p>After each of the yields, the status will be <code>"suspended"</code>. After the final resume, our coroutine is once again <code>"dead"</code>.</p>
<h3><a name="data"></a>Working With Data</h3>
<p>It&#8217;s possible to pass data to and from a coroutine. We can send values to the coroutine by passing them as arguments to <code>coroutine.resume</code>:</p><pre class="crayon-plain-tag">local function Body( a, b, c )
    DoSomething()

    local d, e = coroutine.yield()

    DoSomethingElse()

    local f, g, h = coroutine.yield()

    DoOneLastThing()
end

local co = coroutine.create( Body )

coroutine.resume( co, &quot;one&quot;, 2 )  -- a = &quot;one&quot;, b = 2, c = nil
coroutine.resume( co, 8, {} )  -- d = 8, e = the table
coroutine.resume( co, 42, 9 )  -- f = 42, g = 9, h = nil</pre><p>As we see, on the very first resume (the one which kicks the coroutine off, after creation), the data winds up in the parameters. On each subsequent resume, they instead show up as return values of the most recent <code>coroutine.yield</code>.</p>
<p>Receiving isn&#8217;t too different, but we go through <code>coroutine.yield</code> instead:</p><pre class="crayon-plain-tag">local function Body()
    DoSomething()

    coroutine.yield( 1, &quot;3&quot; )

    DoSomethingElse()

    coroutine.yield( { n = 6 }, 7, 4 )

    DoOneLastThing()

    return &quot;Data&quot;, 1
end

local co = coroutine.create( Body )

print( coroutine.resume( co ) )  -- prints true, 1, &quot;3&quot;
print( coroutine.resume( co ) )  -- prints true, something about the table, 7, 4
print( coroutine.resume( co ) )  -- prints true, &quot;Data&quot;, 1</pre><p>Here we see that any arguments passed to <code>coroutine.yield</code> end up as return values of the most recent <code>coroutine.resume</code>, as do any values returned from the coroutine body.</p>
<p>(<b>Programming in Lua</b> contains an <a href=http://www.lua.org/pil/9.2.html target="_blank">excellent example</a> of data-passing in action.)</p>
<p>Now, there&#8217;s something peculiar about the yield snippet. In the printed results, what does that <code>true</code> mean? It indicates that the resume was successful. Had an error occurred along the way, that <code>true</code> would be a <code>false</code> instead, the only other return value being an error message. When I mentioned before how resuming a dead coroutine fails silently, this is what is happening.</p>
<p>And speaking of dead coroutines, that&#8217;s what we&#8217;re stuck with, following an error.</p>
<h3><a name="wrap"></a>Wrapping Up</h3>
<p>We&#8217;ll often only need to create, resume, and yield a coroutine. This is common enough that a convenience function, <code>coroutine.wrap</code>, is provided in order to make coroutines more friendly to use:</p><pre class="crayon-plain-tag">local function Body()
    print( &quot;First resume&quot; )

    coroutine.yield()

    print( &quot;Second resume&quot; )

    coroutine.yield()

    print( &quot;Final resume&quot; )
end

local wrapped = coroutine.wrap( Body )

wrapped()  -- prints &quot;First resume&quot;
wrapped()  -- prints &quot;Second resume&quot;
wrapped()  -- prints &quot;Final resume&quot;</pre><p>This resembles our earlier examples, except resuming the coroutine seems to behave like a regular function call. In fact, the wrapper <b>is </b>just a function; <code>coroutine.resume</code> is taken care of behind the scenes, together with the coroutine reference itself.</p>
<p>Passing data around works much as before, except unlike <code>coroutine.resume</code>, the wrapper doesn&#8217;t return a success boolean. So what if it fails? For instance, in the last example, if we were to call the wrapper once more, now that the coroutine has finished?</p>
<p><a href=/wordpress/wp-content/uploads/2015/02/crash.jpg><img class=" size-full wp-image-61372 aligncenter" src=/wordpress/wp-content/uploads/2015/02/crash.jpg alt="crash" width="320" height="242" /></a></p>
<p><strong>&#8220;KERBLOOEY!&#8221;</strong></p>
<p>Of course, when developing in Corona, this is generally what we&#8217;ll want. It&#8217;s an error like any other. With all of this under our belt, we&#8217;re ready to advance.</p>
<h3><a name="tagteam"></a>The Coroutine-Timer Tag Team</h3>
<p><code>coroutine.wrap</code> offers some interesting possibilities. In particular, the wrapper being just a function opens some doors for us. Many Corona APIs, the various event listeners for instance, take function arguments, and will happily accept our coroutine-in-disguise.</p>
<p>Now, presumably we would favor coroutines over regular functions because we want the yield capability. Once we yield, however, the rest of the coroutine won&#8217;t happen, unless the wrapper gets called again (remember, doing this just performs a resume, under the hood). Therefore, we&#8217;ll typically want to use coroutines in logic that we expect to trigger multiple times.<a name="from_note2"></a><a href="#note2">[2]</a></p>
<p>As it happens, we have many such mechanisms in Corona. Timers, for instance:</p><pre class="crayon-plain-tag">local function Body()
    print( &quot;First resume&quot; )

    coroutine.yield()

    print( &quot;Second resume&quot; )

    coroutine.yield()

    print( &quot;Final resume&quot; )
end

timer.performWithDelay( 1000, coroutine.wrap( Body ), 3 )</pre><p>As you might imagine, this will fire every second or so, printing one of the now-familiar messages each time. This is all well and good, but notice the iteration count: <strong>three</strong> iterations. Two for the yields and one more to run the final leg. If we overestimate this count, say by specifying four iterations, we&#8217;ll end up trying to resume a dead coroutine. The code above is quite simple, so this isn&#8217;t a huge worry.</p>
<p>As our coroutine body grows larger, it becomes increasingly difficult to maintain a correct count, especially when the yields are in loops or behind function calls. Once we bring <code>if</code> statements into the mix, we can&#8217;t even depend on a fixed number, and then we&#8217;re completely out of luck.</p>
<p>We really want something that &#8220;just works&#8221;. Fortunately, <code>"timer"</code> events come packaged with a reference, <a href=http://docs.coronalabs.com/api/event/timer/source.html target="_blank">source</a>, which can be used to cancel the corresponding timer. Rather than hard-coding some number of iterations, we can simply let the timer run indefinitely, only canceling it once we&#8217;ve finished our task.</p>
<p>A first attempt might go something like this:</p><pre class="crayon-plain-tag">local function Body( event )
    DoSomething()

    coroutine.yield()

    DoSomethingElse()

    timer.cancel( event.source )
end

timer.performWithDelay( 50, coroutine.wrap( Body ), 0 )</pre><p>And this will work&#8230; until it doesn&#8217;t. Unfortunately, coroutines flush out a <a href=http://en.wikipedia.org/wiki/Leaky_abstraction target="_blank">leaky abstraction</a>: Corona is recycling the event tables. Presumably this is to avoid garbage collector spikes, and is a great idea. With normal functions, we would never know the difference. But we&#8217;re being naughty. By yielding, we end up holding on to that event table across multiple frames. Meanwhile, Corona has been passing the table around, swapping timer references in and out. When it comes time to deal with &#8220;our&#8221; timer, we might cancel a different one altogether!</p>
<p>We can play nice by saving the reference up front:</p><pre class="crayon-plain-tag">local function Body( event )
    local source = event.source

    DoSomething()

    coroutine.yield()

    DoSomethingElse()

    timer.cancel( source )
end

timer.performWithDelay( 50, coroutine.wrap( Body ), 0 )</pre><p>This does work. However, the <code>"timer"</code> event also contains <b>count</b> and <b>time</b> fields, and similar issues crop up.</p>
<p>We can account for these too. Our code probably won&#8217;t care where the event table came from (and as we just saw, it shouldn&#8217;t), and will be none the wiser if we give it a &#8220;shadow&#8221; table.<a name="from_note3"></a><a href="#note3">[3]</a> We update this shadow table instead, and all is well again.</p>
<h3><a name="timerutil"></a>A Timer Utility</h3>
<p>Figuring these things out each time is going to get old. For that matter, most coroutine-based timers are going to have the same &#8220;look&#8221; to them, once we do get these details in order. We ought to roll this all up for reuse:</p><pre class="crayon-plain-tag">function CoroPerformWithDelay( delay, func, n )
    local wrapped = coroutine.wrap( function( event )
        func( event )  -- Do the action...

        return &quot;cancel&quot;  -- ...then tell the timer to die when we're done.
    end )

    local event2  -- Our &quot;shadow&quot; event.

    return timer.performWithDelay( delay, function( event )
        event2 = event2 or { source = event.source }  -- On first run, save source...

        event2.count = event.count  -- ...update these every time.
        event2.time = event.time

        local result = wrapped( event2 )  -- Update the coroutine. It will pick up the event on the first run.

        if result == &quot;cancel&quot; then
            timer.cancel( event2.source )  -- After func completes, or on a cancel request, kill the timer.
        end
    end, n or 0 )
end</pre><p>Now, we&#8217;ve been looking at timers, but the same ideas extend to <code>"enterFrame"</code> listeners, and even to repeating transitions. I tend to favor timers because of the customizable delay, and find them a bit more natural to cancel. If the coroutine is going to run forever anyway, however, it&#8217;s rather arbitrary.</p>
<p>Since we&#8217;ve brought up canceling, note that it&#8217;s perfectly fine to cancel the timer early. That said, it&#8217;s important to recognize that the timer and coroutine are two distinct things, so we would still need to yield the coroutine. Our helper function lets us do both at once (from inside the coroutine, of course) by calling <code>coroutine.yield("cancel")</code>.</p>
<h3><a name="waitutils"></a>Waiting Around</h3>
<p>So we have coroutines running on top of timers. Where do we go from here? Just using a timer encourages us to think of individual steps in the coroutine as taking place in time. If we apply this perspective to an earlier example, first we <code>DoSomething()</code>, then <i>later</i> we <code>DoSomethingElse()</code>. It&#8217;s a short leap from there to wanting something more explicitly chronological, like &#8220;<code>DoSomethingElse()</code> five seconds from now&#8221;. Can we achieve this?</p>
<p>Well, we do know when &#8220;now&#8221; is: we just ask <code>system.getTimer</code>. &#8220;The future,&#8221; then, is just &#8220;now&#8221; plus 5000 milliseconds. Once &#8220;the future&#8221; arrives, we know our five seconds are up. The most straightforward approach is to loop until then, yielding on each iteration. <a name="from_note4"></a><a href="#note1">[4]</a></p>
<p>Consider the following:</p><pre class="crayon-plain-tag">function WaitMS ( duration, update )
    local now = system.getTimer()
    local ends_at = now + duration

    while now &lt; ends_at do
        if update then -- Call any per-frame behavior. Yielding is discouraged, as it throws off our bookkeeping.
            update()
        end

        coroutine.yield()

        now = system.getTimer()
    end
end</pre><p>Then, lo and behold, we can do this:</p><pre class="crayon-plain-tag">DoSomething()
WaitMS( 5000 )
DoSomethingElse()</pre><p>Five seconds may be a long time, relatively speaking, just to wait around. The optional <code>update</code> parameter lets us sneak in little batches of work, as necessary.</p>
<p>We can wait for something other than time, obviously. Perhaps some condition must be satisfied:</p><pre class="crayon-plain-tag">function WaitUntilTrue( func, update )
    while not func() do
        if update then
            update()
        end

        coroutine.yield()
    end
end</pre><p>Let&#8217;s try it out! Here, we fire off a transition, then wait for it to finish:</p><pre class="crayon-plain-tag">local pos = { x = 20 }
local done = false  -- We haven't even started. Of course we're not done!

transition.to( pos, {
    x = 50,

    onComplete = function()
        done = true  -- NOW we're done.
    end
})

WaitUntilTrue( function()
    return done  -- Are we done yet?
end )
DoSomethingElse()</pre><p>Similarly, we can wait for some property to be true:</p><pre class="crayon-plain-tag">function WaitUntilPropertyTrue( object, name, update )
    while not object[name] do
        if update then
            update()
        end

        coroutine.yield()
    end
end</pre><p>Let&#8217;s use this to wait until an object becomes visible:</p><pre class="crayon-plain-tag">local rect = display.newRect( 100, 100, 50, 50 )

rect.isVisible = false

timer.performWithDelay( 5000, function()
    rect.isVisible = true
end )

WaitUntilPropertyTrue( rect, &quot;isVisible&quot; )
DoSomethingElse()</pre><p>Many more ideas could be explored. Obviously the &#8220;Wait until X is false&#8221; variants have their place. We can even watch multiple states, for which we&#8217;d have &#8220;Wait until all states in X are true&#8221;, &#8220;Wait until any state in X is true&#8221;, and so forth.</p>
<p>Each of these helper functions was fairly general, but nothing prevents us from making more specific ones. Compound operations, such as &#8220;Wait until object is visible, then wait ten seconds&#8221;, may also come in handy.</p>
<p>As the last examples show, coroutines play well with timers and transitions. Just one more tool in our kit.</p>
<h3><a name="statemachine"></a>State Machines</h3>
<p>Sometimes we&#8217;ll run across code like the following:</p><pre class="crayon-plain-tag">if state == 1 then
    DoState1()
elseif state == 2 then
    DoState2()
-- etc...</pre><p>Or, using strings:</p><pre class="crayon-plain-tag">if state == &quot;starting&quot; then
    Start()
elseif state == &quot;walking&quot; then
    Walk()
elseif state == &quot;waiting&quot; then
    Wait()
-- etc...</pre><p>This works well enough, but it&#8217;s often overkill, especially when we&#8217;re merely performing a sequence of actions. Beyond that, the pattern itself has some inherent dangers. When using integer states, we must remember which state belongs to what action. It doesn&#8217;t take long to lose our place. If we switch to the <span style="line-height: 1.5;">wrong state, say by mistyping the integer, we could easily have a debugging nightmare on our hands.</span></p>
<p>This isn&#8217;t such a problem with strings, of course, but we do have the hassle of thinking up good names. This is less trivial than it may seem. Things start out easy enough. We have <code>"starting"</code>, <code>"walking"</code>, and <code style="line-height: 1.5;">"waiting"</code><span style="line-height: 1.5;"> states&#8230; so far so good! </span>Then we&#8217;re walking again. Hmm. <code>"walking2"</code>? Sure, why not. Next it&#8217;s back to waiting. (<em>sigh</em>) <code>"waiting2"</code> it is.</p>
<p>Finally we come to the really awkward stuff. What do we call &#8220;updating x, choosing a fill color, and emptying an array&#8221;? We may end up making little functions, such as <code>Start</code>, <code>Walk</code>, and <code>Wait</code> in the last example, rather than inline <span style="line-height: 1.5;">code, just to reduce some of this visual congestion. The naming problem strikes again! This also reduces code locality: we need to go hunting to find </span><span style="line-height: 1.5;">those functions and see what&#8217;s in them. Furthermore, if we have several such functions, we&#8217;ve really only shifted the clutter around.</span></p>
<p>It would be better if the last snippet could instead be written:</p><pre class="crayon-plain-tag">Start()
Walk()
Wait()</pre><p>It should be obvious where this is headed. That style falls out quite naturally from moving our logic into a coroutine.</p>
<p>As a broader example, we might write the high-level game loop for some sort of sports title:</p><pre class="crayon-plain-tag">CoroPerformWithDelay( 30, function()
    OpeningSequence()

    for period = 1, NumberOfPeriods do
        WaitMS( 15000, PanCamera )  -- Show audience, stadium, etc.

        StartTheClock()

        repeat
            Play()  -- Basically, whatever happens between &quot;serving the ball&quot; and blowing the whistle.
        until OutOfTime()

        if period &lt; NumberOfPeriods then
            BetweenPeriodsSequence()  -- National anthem, hear from coaches, etc.
        else
            EndingSequence()  -- Fireworks!
        end
    end
end)</pre><p></p>
<h3><a name="sm2"></a>State Machines, Take Two</h3>
<p>Now, we may <b>want</b> &#8220;conventional&#8221; state machines. Character AI, for instance, typically consists of several independent behaviors, each of them fairly significant, which the character cycles through. Thankfully, we can accommodate this as well.</p>
<p>Consider a very simple AI, for one of the players in our sports title:</p><pre class="crayon-plain-tag">local States = {}

function States.Defensive()
    repeat
        GetCloserTo( Ball )

        if CloseTo( Ball ) then
            TryToGrabIt()
        end
    until GainedPossession()

    return States.Offensive()
end

function States.Offensive()
    repeat
        GetCloserTo( Goal )

        if CloseTo(Goal) then
            TryToScore()
        end
    until LostPossession()

    return States.Defensive()
end

local player = CoroPerformWithDelay( 30, States.Defensive )</pre><p>The player begins as the defender. The defensive strategy consists entirely of getting the ball away from the opponent (it isn&#8217;t a very sophisticated sport). With that objective in mind, the player tries to get in range of, and steal, the ball. If this succeeds, or the opponent lost the ball in some other way, the player has command of the ball and goes on the offensive.</p>
<p>Offense is a similar affair. The player tries to draw near the goal and score a point. If the opponent regains possession (ball was grabbed, the player scored, etc.), it&#8217;s back to defense.</p>
<p>Switching states is a simple matter of calling the appropriate function. I tend to lump all my states into a table, when doing this sort of thing. There usually isn&#8217;t any obviously correct order for the states, so forward declarations end up being too much hassle, especially as the switches become ever more tangled.</p>
<p>The <code>return state()</code> syntax is key. This is what is known as a <a href=http://www.lua.org/manual/5.1/manual.html?#2.5.8 target="_blank">tail call</a>. Whenever we call a function normally, Lua must leave behind some information so that, once the function finishes, execution can pick up where it left off. The trouble is, when we switch states, we have no intention of coming back! While we <b>can</b> hop around using the standard <code>state()</code> form, eventually so much of this bookkeeping piles up that it overflows the stack, and we crash. A tail call, on the other hand, in effect declares &#8220;I&#8217;m done here&#8221;. Lua honors this (by doing nothing) and the problem goes away.</p>
<p>Between the game loop and the player AI, we have two coroutines running. Nothing stops us from going further, say by making two full teams&#8217; worth of player AI. In the end, it comes down to what works.</p>
<h3><a name="long"></a>Long-Running Processes</h3>
<p>Timer-backed coroutines are great when it comes to events that span time. As it turns out, they&#8217;re perfect for tackling another class of problems, too: actions that just plain take a while!</p>
<p>&#8220;A while&#8221; could mean on the order of a minute or two, yet even a 50-millisecond operation will make our frame rate hiccup, if it doesn&#8217;t allow the rest of the program a chance to act.</p>
<p>A good example of this is loading a game level. We might find ourselves performing some quite time-consuming steps, such as unzipping large files or downloading images. The number of resources may also be significant. Each one takes time, and it adds up.</p>
<p>There&#8217;s not always much we can do about the predicament itself. What we probably <b>can</b> do is take some action between, or during, these many operations. If the long-running process is embedded in a coroutine, we can call <code>coroutine.yield</code> to temporarily cede control.</p>
<p>Yielding between might look like so:</p><pre class="crayon-plain-tag">DoHeavywork()

coroutine.yield()

DoMoreHeavyWork()</pre><p>And during:</p><pre class="crayon-plain-tag">local function DoHeavyWork()
    for i = 1, NumberOfThingsToProcess do
        DoSomeWork(i)

        coroutine.yield()
    end
end</pre><p>The yields put the action to sleep now and then, giving time back to Corona.</p>
<p>As with any long-running activity in Corona, it&#8217;s good practice to have something visual going on, be it the activity indicator, or a progress view, or even a simple animation. For particularly lengthy loads, we might even add a little mini-game as an overlay, to pass the time.</p>
<h3><a name="yieldutil"></a>Some Yield Helpers</h3>
<p>A shortcoming of using <code>coroutine.yield</code> directly is that, when we do yield, we&#8217;re done for that frame, even though there might still be time left for work. We can mitigate this somewhat by parametrizing the yield operation. That way, we can experiment with different strategies of staggering the yields, until we settle on a winner. The last snippet then becomes:</p><pre class="crayon-plain-tag">local function DoHeavyWork( yfunc )
    for i = 1, NumberOfThingsToProcess do
        DoSomeWork(i)

        yfunc()
    end
end</pre><p>As an example, we might use the following routine. When called, it tries to yield, but only actually does so if a certain amount of time has elapsed:</p><pre class="crayon-plain-tag">do
    local since

    function YieldOnTimeout()
        local now = system.getTimer()

        if not since then
            since = now  -- On first try, just sync.
        elseif now - since &gt;= 15 then  -- 15 milliseconds, but could be customized or an argument.
            since = now

            coroutine.yield()
        end
    end
end</pre><p>(The <code>do</code>&#8211;<code>end</code> construction limits the scope of <code>since</code>, keeping it private to <code>YieldOnTimeout</code>.)</p>
<p>In use, it might look like:</p><pre class="crayon-plain-tag">DoHeavyWork( YieldOnTimeout )</pre><p>This is no panacea, however. Sometimes we&#8217;ll get unlucky, say when there are only a couple milliseconds to spare and we run one more operation, which ends up taking five. To account for this, it may be best to underestimate the timeout.</p>
<p>Another possibility is to yield every few calls:</p><pre class="crayon-plain-tag">do
    local calls = 0

    function YieldEveryFewCalls()
        calls = calls + 1

        if calls == 4 then  -- Again, customizable and could be an argument.
            calls = 0

            coroutine.yield()
        end
    end
end</pre><p>Yet another idea is to yield randomly, say 25% of the time:</p><pre class="crayon-plain-tag">function YieldOccasionally()
    if math.random( 100 ) &lt;= 25 then  -- Ditto.
        coroutine.yield()
    end
end</pre><p></p>
<h3><a name="debug"></a>Coroutines as a Debugging Tool</h3>
<p>The <code>print()</code> statement is a hallmark of debugging, across a broad spectrum of programming languages. Sometimes this comes down to convenience, such as when it would take too much effort to configure a debugger, then place and watch breakpoints. On rare occasions, integrating a debugger may even <b>seem</b> to make the problem go away: an attack of the dreaded <a href=http://en.wikipedia.org/wiki/Heisenbug target="_blank">Heisenbug</a>!. A common strategy is to sprinkle <code>print()</code> statements around suspect points in the code, then compare the output with our expectations. If a message doesn&#8217;t appear, either the code in question was never visited or the program crashed along the way. As we narrow down the scope of the problem, we can remove instances of <code>print()</code> that are no longer necessary.</p>
<p>One concern in normal code is that most (or all) of these <code>print()</code> statements will execute, so we wind up with one long burst of messages. We might also need some sense of <b>when</b> a piece of code was executed, and what our program looked like at the time. It&#8217;s hard to guess where the process broke down.</p>
<p>Enter coroutines. If we can roughly isolate the troublesome code, it can be temporarily embedded in a coroutine. Then, by following each <code>print()</code> with a yield, we&#8217;re able to inspect the state of the world at that moment. Consider the following:</p><pre class="crayon-plain-tag">DoSomething()

-- We're curious about the snippet starting here...

local red = display.newRect( 100, 100, 30, 70 )

red:setFillColor( 1, 0, 0 )

print( &quot;Added red rect&quot; )

local blue = display.newCircle( 150, 30, 10 )

blue:setFillColor( 0, 0, 1 )

print( &quot;Added blue circle&quot; )

local green = display.newRect( 200, 100, 60, 20 )

green:setFillColor( 0, 1, 0 )

print( &quot;Added green rect&quot; )

-- ...and ending here.

DoSomethingElse()</pre><p>All of our messages and display objects show up at once.</p>
<p>With coroutines:</p><pre class="crayon-plain-tag">DoSomething()

-- Start of temporary debugging code...
local function print2( ... )
    print( ... )
    coroutine.yield()
end

CoroPerformWithDelay( 2000, function()  -- Wait 2 seconds after each print statement.
-- ...end of temporary debugging code

local red = display.newRect( 100, 100, 30, 70 )

red:setFillColor( 1, 0, 0 )

print2( &quot;Added red rect&quot; )

local blue = display.newCircle( 150, 30, 10 )

blue:setFillColor( 0, 0, 1 )

print2( &quot;Added blue circle&quot; )

local green = display.newRect( 200, 100, 60, 20 )

green:setFillColor( 0, 1, 0 )

print2( &quot;Added green rect&quot; )

-- Start of temporary debugging code...
end )
-- ...end of temporary debugging code

DoSomethingElse()</pre><p>By using coroutines, we get to watch the action unfold. In the example above, we now have a couple seconds to review the state of affairs after each <code>print2</code>, without significantly changing the code shape. If we only need to do some visual inspection, we can even just use <code>coroutine.yield</code> directly.</p>
<p>I employed this technique quite recently, in order to test some <a href=http://code.coronalabs.com/code/layout-helpers target="_blank">layout routines</a>. Since these primarily involve display objects, <code>print()</code> only got me so far. Many of the operations consist of one object being positioned relative to another, so if something went wrong in the middle, the whole layout fell apart. By viewing the steps one at a time, I was able to pinpoint when and where things went awry.</p>
<p>Bear in mind that this method does slightly alter the program flow, on account of the yields. Therefore, we must include this in our notion of isolation. In the previous example, for instance, <code>DoSomethingElse</code> shouldn&#8217;t depend on what happens inside the wrapped-up code.</p>
<h3><a name="touch"></a>The Magic Touch</h3>
<p>A timer won&#8217;t always be the best fit for debugging. With a short delay, the steps may go by too soon. Much longer, and we might instead grow weary waiting, especially if the problem tends to show up quite late.</p>
<p>Fortunately, time isn&#8217;t the only way to drive a coroutine. We hinted earlier at using wrapped coroutines as event listeners. <code>"touch"</code> listeners are one such choice, and in fact give us direct control: on each touch, we resume the wrapped-up code.</p>
<p>With Corona, it&#8217;s easy to create a dummy display object and assign it such a listener. Then, instead of waiting around for the timer, we just click rapidly through any steps we want to ignore. Once we find something suspicious, we can take our time.</p>
<p>The previous example then becomes:</p><pre class="crayon-plain-tag">DoSomething()

-- Start of temporary debugging code...
local function print2( ... )
    print( ... )
    coroutine.yield()
end

local co = coroutine.create( function()  -- Wait for next touch event.
-- ...end of temporary debugging code

local red = display.newRect( 100, 100, 30, 70 )

red:setFillColor( 1, 0, 0 )

print2( &quot;Added red rect&quot; )

local blue = display.newCircle( 150, 30, 10 )

blue:setFillColor( 0, 0, 1 )

print2( &quot;Added blue circle&quot; )

local green = display.newRect( 200, 100, 60, 20 )

green:setFillColor( 0, 1, 0 )

print2( &quot;Added green rect&quot; )

-- Start of temporary debugging code...
end )

local button = display.newCircle( 20, 20, 10 )

button:setFillColor( .7 )
button:addEventListener( &quot;touch&quot;, function( event )
    if event.phase == &quot;began&quot; then
        local ok, err = coroutine.resume( co )

        if not ok then
            print( err )  -- What went wrong?
        end
    end

    return true
end)
-- ...end of temporary debugging code --

DoSomethingElse()</pre><p>After one click, we see:</p>
<p><a href=/wordpress/wp-content/uploads/2015/02/debug1.jpg><img class=" size-full wp-image-61378 aligncenter" src=/wordpress/wp-content/uploads/2015/02/debug1.jpg alt="debug1" width="320" height="300" /></a></p>
<p><span style="line-height: 1.5;">(The gray circle is our &#8220;button&#8221;, the dummy display object.)</span></p>
<p>After another:</p>
<p><a href=/wordpress/wp-content/uploads/2015/02/debug2.jpg><img class=" size-full wp-image-61379 aligncenter" src=/wordpress/wp-content/uploads/2015/02/debug2.jpg alt="debug2" width="320" height="300" /></a></p>
<p>Finally:</p>
<p><a href=/wordpress/wp-content/uploads/2015/02/debug3.jpg><img class=" size-full wp-image-61380 aligncenter" src=/wordpress/wp-content/uploads/2015/02/debug3.jpg alt="debug3" width="320" height="300" /></a></p>
<p>This is actually a situation where <code>coroutine.create</code> and <code>coroutine.resume</code> are more appropriate. We don&#8217;t want <span style="line-height: 1.5;">to crash our program just because we clicked too many times and ran a dead coroutine. We also end up with a basic sandbox, where an error </span><span style="line-height: 1.5;">can occur without bringing down our whole program (the coroutine will then be dead, of course). If our code snippet was properly isolated, </span><span style="line-height: 1.5;">this should work just fine.</span></p>
<p>Once everything is good to go, we can remove all the &#8220;temporary debugging code&#8221; and move on.</p>
<h3><a name="gotchas"></a>Gotchas</h3>
<p>There are a few specific cases where coroutines break, owing mainly to some quirks in the interaction between Lua and C. Thanks to some redesign in the codebase, these have been fixed in Lua 5.2+. Corona is based on 5.1, though, so for the time being these issues are a fact of life.</p>
<p>Two such problem areas involve <a href=http://www.lua.org/manual/5.1/manual.html?#pdf-pcall target="_blank">protected calls</a> and <a href=http://www.lua.org/manual/5.1/manual.html?#2.8 target="_blank">metamethods</a>, as Peter &#8220;Corsix&#8221; Cawley <a href=http://www.corsix.org/content/look-lua-52-work3 target="_blank">points out on his blog</a> (see point #2). Note that the article itself mainly concerns 5.2, whereas we only care about the 5.1-related misbehavior. There have been some attempts to deal with protected calls, such as <a href=https://github.com/keplerproject/coxpcall target="_blank">Coxpcall</a>, created expressly to allow them in <a href=https://github.com/keplerproject/copas target="_blank">Copas</a> (a library for building TCP/IP servers atop coroutines).</p>
<p><a href=http://www.lua.org/manual/5.1/manual.html?#2.4.5 target="_blank">Iterators</a> are the other problem spot:</p><pre class="crayon-plain-tag">local wrapped = coroutine.wrap( function()
    for _ in function()  -- An (obviously not useful!) iterator body.
        print( &quot;Before&quot; )

        coroutine.yield()  -- In 5.1, gives error: attempt to yield across metamethod / C-call boundary.

        print( &quot;After&quot; )
    end do
        print( &quot;Loop!&quot; )
    end
end )

wrapped()</pre><p>This is a rather lame iterator (it doesn&#8217;t even attempt to iterate!), but it demonstrates the issue. Attempting to yield directly from the so-called iterator function results in an error, in Lua 5.1. We see the message <b>&#8220;Before&#8221;</b>, and then our program goes down in flames. Note that this is <b>not</b> the same as <a href=http://www.lua.org/pil/9.3.html target="_blank">using coroutines as iterators</a> (an incredibly useful feature but, alas, an entire topic of its own!).</p>
<p>Thankfully these all tend to be rare situations, but it&#8217;s good to be aware of them.</p>
<h3><a name="saving"></a>Saving</h3>
<p>The final gotcha comes from a design perspective. Being able to yield offers us great flexibility, but the flip side is that we do actually need to traverse the coroutine body to arrive at a given point in our code, with all of our local variables and program state in order. We can&#8217;t just jump to somewhere in the middle, in general. This presents a problem if the application must be able to save and later restore itself exactly where it left off. This isn&#8217;t insurmountable, but does need to be accounted for early on. It will almost certainly be difficult, and probably not worth the hassle.</p>
<p>If the application only needs to be saved every now and then (say between levels or at checkpoints, in a game), or has some leeway regarding what gets restored, this is a much smaller issue.</p>
<h3><a name="examples"></a>Examples</h3>
<p>Most of the code in this article has been adapted from the samples repository <a href=https://github.com/ggcrunchy/samples/tree/master/coroutines target="_blank">found here</a>. It can be downloaded from <a href=https://github.com/ggcrunchy/samples/archive/master.zip target="_blank">here</a>. These samples were made to be shown during a <a href=/blog/coronageek/corona-geek-122/ target="_blank">Corona Geek hangout</a>, so I wrote in a <span style="line-height: 1.5;">style which allows entire segments of the program to be turned on and off quickly. In particular, code gets blocked in </span><a style="line-height: 1.5;" href=http://www.lua.org/pil/1.3.html target="_blank">long comments</a><span style="line-height: 1.5;">. Doing so lets us start with a commented-out section:</span></p><pre class="crayon-plain-tag">--[[
DoSomething() -- Commented out, does not run.
--]]</pre><p>We can then enable all its code at once, simply by adding another hyphen at the beginning of the comment:</p><pre class="crayon-plain-tag">---[[
DoSomething() -- No longer commented, will run.
--]]</pre><p>To disable it once more, just remove the hyphen. I used this blocking method in <code>main.lua</code>, to <code>require()</code> each example, as well as within the modules themselves.</p>
<p>Also, in order to reduce switches between the simulator and console while recording, I overrode <code>print()</code> in <code>main.lua</code>, such that messages show up on the screen (as text objects) rather than the console. To disable this, simply remove or comment out the assignment to <code>print()</code>.</p>
<h3><a name="summary"></a>In Summary</h3>
<p>Coroutines are a truly powerful feature of Lua which, when combined with such mechanisms as Corona&#8217;s timers and event listeners, offer us a novel and useful approach to a whole host of difficult problems. We&#8217;ve only scratched the surface. <a href=http://www.lua.org/pil/9.html target="_blank">Chapter 9</a> of <b>Programming in Lua</b> covers several topics only <span style="line-height: 1.5;">touched on here. Explore, and have fun!</span></p>
<hr />
<p><a name="note1"></a><a href="#from_note1">[1]</a> A coroutine <b>is</b> a thread. The reverse is also true, with one very important exception: the main thread. This is the &#8220;normal&#8221; part of the program, where our code runs when it&#8217;s not inside a coroutine.</p>
<p><a name="note2"></a><a href="#from_note2">[2]</a> Typically, but not always. We could, for instance, assign the same wrapper to several listeners. Then, as these fire off piecemeal, the coroutine is gradually driven forward.</p>
<p>Another use case is to abort complex code. We might find ourselves in the middle of some heavy operation, ten function calls deep, when we realize we just can&#8217;t deal with it. It&#8217;s easy enough to <code>return</code> out of one function. Getting out of nine more is a different story! On the other hand, if this is all inside a coroutine, we can just yield. Suddenly we&#8217;re back in the <a href="#note1">main thread</a>, and can just throw the coroutine away. Another way to achieve this is to <code>error()</code> out, although this seems a bit impolite if we don&#8217;t actually have an error.</p>
<p>As the saying goes, &#8220;It&#8217;s better to ask forgiveness than permission.&#8221; Essentially, if it&#8217;s too much trouble to figure out up front whether an operation has even a chance of success, the best idea might be to just go for it. When we combine this approach with a set of choices, we arrive at a technique called backtracking, which can be summed up in another expression, &#8220;If at first you don&#8217;t succeed, try again.&#8221;</p>
<p>We might want to do normal yields in the coroutine. The ability to send data through <code>coroutine.yield</code> comes to our rescue here. At the outset, we reserve a couple values, <b>&#8220;success&#8221;</b> and <b>&#8220;failure&#8221;</b> perhaps, then resume until we run across one or the other.</p>
<p><a name="note3"></a><a href="#from_note3">[3]</a> Creating shadow tables reintroduces garbage, of course. However, coroutine-based timers will by and large be created far less frequently than garden variety timers, and be longer-running besides, so this is unlikely to be a problem in practice.</p>
<p><a name="note4"></a><a href="#from_note4">[4]</a> Another possibility, when yielding, is to pass control of the coroutine to a scheduler, which will later resume the coroutine once it&#8217;s ready to go. This has its pros and cons. Since we&#8217;re no longer spinning in a loop, it may prove more efficient, especially when we have several coroutines going. At the <span style="line-height: 1.5;">same time, if we still need to do updates, these costs just reappear in a different form, say as </span><code style="line-height: 1.5;">"enterFrame"</code><span style="line-height: 1.5;"> listener overhead.</span></p>
<p>Scheduler implementations abound. Some examples in pure Lua are <a href=https://github.com/xopxe/Lumen target="_blank">Lumen</a> and <a href=https://gist.github.com/Deco/1818054 target="_blank">this Gist</a>. Others, coded partially in C and C++, include <a href=https://github.com/lefcha/concurrentlua target="_blank">ConcurrentLua</a>, <a href=https://github.com/SierraWireless/luasched target="_blank">luasched</a>, and <a href=https://github.com/dmattp/nylon target="_blank">Nylon</a>. Unfortunately, we can&#8217;t simply drop these last few into a Corona codebase. That said, enough of their code <b>is</b> written in Lua to reward some study.</p>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2015/02/10/tutorial-using-coroutines-in-corona/feed/</wfw:commentRss>
		<slash:comments>14</slash:comments>
		</item>
		<item>
		<title>Guest post: 3 ways to more effectively re-engage your players</title>
		<link>/blog/2015/02/09/guest-post-3-ways-to-more-effectively-re-engage-your-players/</link>
		<pubDate>Tue, 10 Feb 2015 00:09:28 +0000</pubDate>
		<dc:creator><![CDATA[david]]></dc:creator>
				<category><![CDATA[Guest Bloggers]]></category>

		<guid isPermaLink="false">/?p=61402</guid>
		<description><![CDATA[This is a guest post by Long Vo, co-founder of GameThrive, on how to best re-engage your players.]]></description>
				<content:encoded><![CDATA[<p><em>Today&#8217;s guest post is by Long Vo of GameThrive. GameThrive is a powerful Push Notifications platform for mobile games and apps built by game developers. GameThrive is absolutely free for any developers building apps exclusively with Corona SDK.</em></p>
<hr/>
<p><img src="/wordpress/wp-content/uploads/2015/02/Logo_GameThrive_Sponsorship_Web.png" alt="GameThrive logo" width="240" height="62" class="alignright size-full wp-image-61419" />So, you’ve toiled over the last several months or year making an awesome mobile game. You release it into the app stores and have gotten a large number of players engaged and playing the heck out of your game. Over time, these players will start dropping off. If you’re like most other app devs, you’ve maybe not even implemented Push Notifications or you do very little in the way of using said Push Notifications to keep your players engaged. And, just like those other app devs, you’re letting your players slip away, losing potential userbase growth and income from ads or in-app purchases.</p>
<p>Here are 3 ways to send more effective Push Notifications using <a href=http://gamethrive.com>GameThrive/</a>&#8212; a free Push platform for Corona Devs. With GameThrive, you can set notifications to go out automatically when players reach criteria you set in player segments. </p>
<h3>Automatically Remind Inactive Players to Play</h3>
<p>Keep track of how active your players are. Reminders should be issued in decreasing frequency the longer they have been inactive. The trick is not to be too annoying that you risk them uninstalling your app. Your messages should also be tailored depending on how long they’ve been inactive. </p>
<p>Using GameThrive’s Automatic Messages, you can set up a different message to go out when your players reach a specific level of inactivity. </p>
<p><em>You can send a message for when a player is inactive for 4 days.</em></p>
<p><img src="/wordpress/wp-content/uploads/2015/02/gt1.png" alt="GameThrive" width="938" height="350" class="alignnone size-full wp-image-61411" /></p>
<p><em>Or, you can actively remind a player every 3 days if they’ve been inactive for at least a week.</em></p>
<p><img src="/wordpress/wp-content/uploads/2015/02/gt2.png" alt="GameThrive" width="938" height="647" class="alignnone size-full wp-image-61410" /></p>
<h3>Encourage Re-engagement with Player Progress Reminders </h3>
<p>If your game has a leveling mechanic to it, players who invest time into leveling don’t want to waste their effort. If a player hasn’t played your game in a while, simply remind them how close they are to achieving another milestone to encourage them to come back and play.</p>
<p>Using GameThrive’s User Tags, you can track a player’s level in the game and send an appropriate message to re-engage them.</p>
<p><em>First, create a segment for the progress of your player. Once your segment is created, you can then create a Filter for Player Tags based on the Player’s EXP Level.</em></p>
<p><img src="/wordpress/wp-content/uploads/2015/02/gt3.png" alt="GameThrive" width="768" height="210" class="alignnone size-full wp-image-61409" /></p>
<p><em>Your final segment should look something like this. </em></p>
<p><img src="/wordpress/wp-content/uploads/2015/02/gt4.png" alt="GameThrive" width="938" height="230" class="alignnone size-full wp-image-61408" /></p>
<p><em>Finally, you can set up an Automatic Message using those segments to send them if they’ve been inactive for a week.</em></p>
<p><img src="/wordpress/wp-content/uploads/2015/02/gt5.png" alt="GameThrive" width="938" height="647" class="alignnone size-full wp-image-61407" /></p>
<h3>New Game Updates are a Great Way to Re-engage your players</h3>
<p>Any time you add new features or make a game update is a great way to get your players to come back and re-engage with your app.</p>
<p>On iTunes, when you release an update to your app, all your ratings and reviews get archived to that version while your new version will have no ratings whatsoever. While we don’t recommend directly asking for reviews in the notification itself, you can pass metadata through the notification to present an in-game message inviting users to rate your game when they click the notification.</p>
<p><em>You can include data in the Notification that your app can use to trigger a Ratings Prompt when the Notification is received.</em></p>
<p><img src="/wordpress/wp-content/uploads/2015/02/gt6.png" alt="GameThrive" width="938" height="625" class="alignnone size-full wp-image-61406" /></p>
<p><em>In your game code, you can create a function that triggers when the additional data is passed to the app.</em></p>
<p></p><pre class="crayon-plain-tag">function DidReceiveRemoteNotification(message, additionalData, isActive)
   if (additionalData and additionalData.PromptToRate) then
       // Place your rate app prompt here.
   end
end</pre><p></p>
<p>We hope these tips were useful to you. As a developer, you should know your audience better than anyone. GameThrive offers more powerful ways to customize your Push Notifications for your specific needs and the above examples are just the beginning. We encourage you to try out more ways to do things and share them with the community, especially if you find out things that work for you! </p>
<p>If you’re not already on GameThrive, you can <a href=http://gamethrive.com>sign/ up for a free account here</a>.</p>
<p>You can find more information on using GameThrive Push Notifications in your Corona App <a href=http://docs.coronalabs.com/daily/plugin/GameThrivePushNotifications/>here</a>.</p>
]]></content:encoded>
			</item>
		<item>
		<title>Guest Post: Up Front Planning with App Briefs</title>
		<link>/blog/2015/01/08/guest-post-up-front-planning-with-app-briefs/</link>
		<comments>/blog/2015/01/08/guest-post-up-front-planning-with-app-briefs/#comments</comments>
		<pubDate>Thu, 08 Jan 2015 19:14:53 +0000</pubDate>
		<dc:creator><![CDATA[david]]></dc:creator>
				<category><![CDATA[Corona SDK]]></category>
		<category><![CDATA[Guest Bloggers]]></category>

		<guid isPermaLink="false">/?p=60767</guid>
		<description><![CDATA[John Luchin, of Classic Interactions, tells us about a useful tool they used in developing Lobster Tale with Corona.]]></description>
				<content:encoded><![CDATA[<p><em>Today&#8217;s guest post is by John Luchin, the founder of <a href=http://classicinteractions.com/>Classic Interactions LLC</a> and the Author/Illustrator of <a href=https://itunes.apple.com/us/app/lobster-tale-childrens-book/id928183628?mt=8>Lobster Tale</a>. </em></p>
<hr/>
<p><img src="/wordpress/wp-content/uploads/2015/01/AppBrief.png" alt="App Brief" width="250" height="293" class="alignright size-full wp-image-60824" />Classic Interactions launched <a href=https://itunes.apple.com/us/app/lobster-tale-childrens-book/id928183628?mt=8>Lobster Tale – Children’s Book and Game</a>, on November 6, 2014. The app was developed in <a href=/products/corona-sdk/>Corona</a> and rose to number 5 in the iPhone Paid Book Category. It was also featured in the Family Games Section of the App Store in over 110 countries, including the US. </p>
<p>Classic Interactions grew from a team of one to a team of four during Lobster Tale’s development and since this was our first children’s book app and the first time we utilized Corona SDK, we were pretty happy with the results. Looking back on everything we did leading up to launch day, I think the most important step we took was to create what I call an App Brief.</p>
<p><strong>What is an App Brief?</strong></p>
<p>Simply put, an App Brief is a PDF outlining all of the content to be included in your app. In our case, we went page-by-page or screen-by-screen of the children’s book app. A typical page in our app brief had three main elements: a description of the page/screen, a list of elements (interactions, sounds, animations, and transitions), and a screenshot mockup of the page/screen.  <a href=https://www.dropbox.com/s/1kacpkszdac1gzs/AppBriefFinal%20.pdf?dl=0>Click here</a> to download a copy of our app brief.</p>
<p><strong>Why did we create an App Brief?</strong></p>
<p>After doing the majority of development on our first 5 apps, I knew that I would need help with Lobster Tale. I was already 2 years into writing and illustrating the app content and I wasn’t up to the task of developing it on my own. I needed to find a good programmer, and once I found one I needed to be able to easily communicate my vision for the app. I’m way more designer than I am programmer and I’m smart enough to realize that designers and programmers communicate and problem solve differently. The App Brief was a way to bridge this gap. </p>
<p>I connected with Jason Sypolt of <a href=http://www.sypoltsystems.com/>Sypolt Systems</a> and from the beginning we were able to cut through a lot of back and forth that usually comes with developing an app because the App Brief was so detailed. A “we can decide on this and fix that later” type of attitude is a recipe for disaster when it comes to app development. Here is what Jason had to say about App Briefs: </p>
<blockquote><p>&#8220;Corona SDK gives us the ability to build interactive apps and iterate and evolve them extremely quickly. But that is all the more reason to have a plan in place before you start. You will work so much faster by slowing down at first to understand the big picture. Be methodical as a developer and diagram and describe every screen as well as everything that happens on every screen. Then fire up 3 or 4 Corona Simulators and some Corona Viewers for different devices and watch your app quickly come to life on all of them at once.&#8221; </p></blockquote>
<p><strong>Why do you need an App Brief?</strong></p>
<p>Our main reason for creating an App Brief was communication, but there are many other great reasons to create one for your next project. If you are contracting any part of your project out, an App Brief will make it easier for you to obtain a realistic quote and not run the risk of additional charges. If you have a great app idea and are looking for funding, a simple app mockup coupled with a detailed App Brief will help investors see your vision clearly. If you are working by yourself, it’s a great way to get all of your app’s functionality on paper and see the project holistically before the first line of code is even written.  If you are a designer working with a programmer, or vice versa, as I said above, a good App Brief can bridge the communication gap and work as a roadmap for your next project.</p>
<p><strong>Final Thoughts</strong></p>
<p><img src="/wordpress/wp-content/uploads/2015/01/AppIcon1-150x150.png" alt="Lobster Tale" width="150" height="150" class="alignright size-thumbnail wp-image-60826" srcset="/wordpress/wp-content/uploads/2015/01/AppIcon1-150x150.png 150w, /wordpress/wp-content/uploads/2015/01/AppIcon1.png 175w" sizes="(max-width: 150px) 100vw, 150px" />I started working on the draft outline of our next app a couple weeks ago and will definitely be creating a detailed App Brief for all of the reasons listed above. After releasing Lobster Tale, I realized that I missed the programming side of app development, so I am going to jump back in on the next app (I guarantee I’ll still need some help) and you better believe I will have my App Brief sitting next to me. </p>
<p><strong>About John</strong></p>
<p>John Luchin is the founder of Classic Interactions LLC and the Author/Illustrator of Lobster Tale. You can email John at <a href=mailto: jluchin@classicinteractions.com>jluchin@classicinteractions.com</a> or follow him <a href=http://www.twitter.com/classicinteract>@classicinteract</a>. <a href=https://itunes.apple.com/us/app/lobster-tale-childrens-book/id928183628?mt=8>Lobster Tale – Children’s Book and Game</a> is a universal app available free for limited time in the App Store, Google Play, and the Amazon Appstore.</p>
]]></content:encoded>
			<wfw:commentRss>/blog/2015/01/08/guest-post-up-front-planning-with-app-briefs/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>Tutorial: Local multiplayer with UDP/TCP</title>
		<link>/blog/2014/09/23/tutorial-local-multiplayer-with-udptcp/</link>
		<comments>/blog/2014/09/23/tutorial-local-multiplayer-with-udptcp/#comments</comments>
		<pubDate>Tue, 23 Sep 2014 21:56:05 +0000</pubDate>
		<dc:creator><![CDATA[Rob Miracle]]></dc:creator>
				<category><![CDATA[Guest Bloggers]]></category>
		<category><![CDATA[Tutorials, Tips and Demos]]></category>
		<category><![CDATA[LAN]]></category>
		<category><![CDATA[network]]></category>
		<category><![CDATA[peer-to-peer]]></category>
		<category><![CDATA[tutorial]]></category>

		<guid isPermaLink="false">/?p=59630</guid>
		<description><![CDATA[In this guest tutorial, Corona developer Mark Steelman discusses the implementation of local area networking between two devices using LuaSocket and UDP/TCP. Read further to learn how.]]></description>
				<content:encoded><![CDATA[<p><em>Today&#8217;s guest tutorial comes to you courtesy of Mark Steelman, founder of Steelman Games LLC. Mark is currently working on a turn-based RPG incorporating local multiplayer called <a href=http://www.legendofus.net/ target="_blank">Legend of Us Roleplaying Game</a>. Before becoming an indie developer, Mark worked for four years at Electronic Arts as a game designer. You can follow the progress of his projects on <a href=http://www.facebook.com/legendofusrpg target="_blank">Facebook</a>, <a title="Legend of Us RPG Google+" href=http://plus.google.com/+LegendofusNet target="_blank">Google+</a>, or by subscribing to his <a title="Legend of Us RPG main page" href=http://www.legendofus.net/ target="_blank">newsletter</a>.</em></p>
<hr />
<h3>Make devices find each other with UDP</h3>
<p>As noted in the introduction, I&#8217;m building a <a href=http://www.legendofus.net/ target="_blank">turn-based role-playing game</a> using Corona SDK. As part of the design, I wanted <strong>local multiplayer</strong> and I also wanted it to be <strong>cross-platform</strong>. After a lot of research, I figured out how to accomplish this and, in this tutorial, I will share some of what I learned. Even better: this architecture will work for both turn-based and action games, so stick around if you&#8217;re making an action game!</p>
<p>This tutorial assumes that you have a basic understanding of Corona SDK, Lua, and peer-to-peer networking. We are going to use <a title="link to LUA Socket documentation" href=http://w3.impa.br/~diego/software/luasocket/ target="_blank">LuaSocket</a> which is included in Corona SDK under the <a href=http://docs.coronalabs.com/api/library/socket/index.html target="_blank">socket</a> library. Because this design is intended for cross-platform multiplayer, it&#8217;s not going to use any native systems. While it does assume that the player has a Local Area Network (LAN), that network doesn’t need to be connected to the internet.</p>
<h3>Including LuaSocket</h3>
<p>In order to use LuaSocket, you must first include it:</p><pre class="crayon-plain-tag">local socket = require( &quot;socket&quot; )</pre><p>That&#8217;s the easy part &#8212; let&#8217;s continue&#8230;</p>
<h3>UDP and TCP</h3>
<p>First, let me give a brief explanation of <strong>UDP</strong> and <strong>TCP</strong>. Both of these are protocols which allow computers to talk to each other and each one has certain advantages and disadvantages. However, I’m only going to cover features that are relevant to the tutorial.</p>
<p><strong>UDP</strong> has the ability to send messages to an address without knowing if anything is there. It doesn’t check to see if the message made it anywhere &#8212; it simply transmits the message. UDP also allows you to listen to an address without being connected to a computer at that address.</p>
<p><strong>TCP</strong> is a reliable protocol. It sends messages to another computer that it&#8217;s connected to via a TCP socket. If the other computer responds that there was a problem with the message, it sends the message again.</p>
<p>Knowing this, you might ask &#8220;Why would anyone use UDP when TCP is so reliable?&#8221; Well, there are several reasons, but the reason most relevant to this tutorial is the fact that you must know the IP address of the server in order to use TCP. Any network which you can join without visiting the LAN administrator is assigning you a random IP address using DHCP. This means that we&#8217;ll need to discover the IP address of the server on our own. Fortunately, UDP can help with that.</p>
<h3>Advertise the server</h3>
<p>For local multiplayer to work, one of the devices must act as the server/host. The host doesn&#8217;t need to have special privileges in your game, but the primary record of the game in progress will be stored on this device. In the language of role-playing games, let&#8217;s call this player the <strong>game master</strong>. This game master is going to announce his/her presence to the local network via some method. I utilize an &#8220;Invite&#8221; button which calls the following function upon being pressed.</p><pre class="crayon-plain-tag">local advertiseServer = function( button )

&nbsp;&nbsp; &nbsp;local send = socket.udp()
&nbsp;&nbsp; &nbsp;send:settimeout( 0 )  --this is important (see notes below)

&nbsp;&nbsp; &nbsp;local stop

&nbsp;&nbsp; &nbsp;local counter = 0  --using this, we can advertise our IP address for a limited time

&nbsp;&nbsp; &nbsp;local function broadcast()
&nbsp; &nbsp; &nbsp; &nbsp; local msg = &quot;AwesomeGameServer&quot;
&nbsp; &nbsp; &nbsp; &nbsp; --multicast IP range from 224.0.0.0 to 239.255.255.255
&nbsp; &nbsp; &nbsp; &nbsp; send:sendto( msg, &quot;228.192.1.1&quot;, 11111 )
&nbsp; &nbsp; &nbsp; &nbsp; --not all devices can multicast so it's a good idea to broadcast too
&nbsp; &nbsp; &nbsp; &nbsp; --however, for broadcast to work, the network has to allow it
&nbsp; &nbsp; &nbsp; &nbsp; send:setoption( &quot;broadcast&quot;, true )  --turn on broadcast
&nbsp; &nbsp; &nbsp; &nbsp; send:sendto( msg, &quot;255.255.255.255&quot;, 11111 )
&nbsp; &nbsp; &nbsp; &nbsp; send:setoption( &quot;broadcast&quot;, false )  --turn off broadcast

&nbsp; &nbsp; &nbsp; &nbsp; counter = counter + 1
&nbsp; &nbsp; &nbsp; &nbsp; if ( counter == 80 ) then  --stop after 8 seconds
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;    stop()
&nbsp; &nbsp; &nbsp; &nbsp; end
&nbsp;&nbsp; &nbsp;end

&nbsp;&nbsp; &nbsp;--pulse 10 times per second
&nbsp;&nbsp; &nbsp;local serverBroadcast = timer.performWithDelay( 100, broadcast, 0 )

&nbsp;&nbsp; &nbsp;button.stopLooking = function()
&nbsp; &nbsp;     timer.cancel( serverBroadcast )  --cancel timer
&nbsp; &nbsp; &nbsp; &nbsp; button.stopLooking = nil
&nbsp;&nbsp; &nbsp;end
&nbsp;&nbsp; &nbsp;stop = button.stopLooking
end</pre><p>Here are some notes about this code:</p>
<ul>
<li><strong>Multicast</strong> is a device feature which allows one device to communicate with several. iPhones and iPads have it, but I&#8217;ve been told that iPods do not. I haven&#8217;t tried it on any Android devices, so maybe somebody can test it and report their results in the comments section. As a result of this inconsistency, we also use <strong>broadcast</strong>. &#8220;Why don&#8217;t we just use broadcast?&#8221; you might ask. Well, the catch with broadcast is that the LAN has to allow broadcasts. By using both, we are maximizing the chance of finding each other.</li>
<li>The &#8220;pulse&#8221; of the timer is ten times per second. I don&#8217;t recommend setting your timer pulse faster than that unless you have a good reason &#8212; after all, your game needs time to do other things. This is a standard pulse speed for most action games including MMOs.</li>
<li>The port you choose can be anything between <code>1</code> and <code>65535</code>, however, applications almost always block the port that they use and you&#8217;ll get an error if you try to bind to a port that is currently in use. Likewise, if you bind to a port, you need to unbind/close the port when you end the game so you don&#8217;t block it indefinitely on the players device. Lower number ports are used by commonly run applications, so it&#8217;s best to use a port between <code>1024</code> and <code>65535</code>.</li>
<li>The <code>settimeout()</code> function allows you to tell the socket how long to wait for a message before moving on. Default is to wait indefinitely, meaning that your game freezes until it gets a message. Setting it to <code>0</code> tells it to just check and if there&#8217;s nothing to receive and move on to the next task.</li>
</ul>
<h3>Finding the server</h3>
<p>The client will need to know its own IP address for the next step. Fortunately, UDP in LuaSocket can help with that:</p><pre class="crayon-plain-tag">local getIP = function()
&nbsp;&nbsp; &nbsp;local s = socket.udp()  --creates a UDP object
&nbsp;&nbsp; &nbsp;s:setpeername( &quot;74.125.115.104&quot;, 80 )  --Google website
&nbsp;&nbsp; &nbsp;local ip, sock = s:getsockname()
&nbsp;&nbsp; &nbsp;print( &quot;myIP:&quot;, ip, sock )
&nbsp;&nbsp; &nbsp;return ip
end</pre><p>The IP address in the above function is arbitrary &#8212; I used the Google address because I know it. You don&#8217;t even need to be connected to the internet for this function to return your IP address, but you must at least be on a local network.</p>
<h3>Listening for the server</h3>
<p>Now we are prepared to listen for the server. We will recognize the server because of the message <code>AwesomeGameServer</code>. Obviously, this could be any string; we are just going to match strings.</p><pre class="crayon-plain-tag">local function findServer( button )

&nbsp;&nbsp; &nbsp;local newServers = {}
&nbsp;&nbsp; &nbsp;local msg = &quot;AwesomeGameServer&quot;

&nbsp;&nbsp; &nbsp;local listen = socket.udp()
&nbsp;&nbsp; &nbsp;listen:setsockname( &quot;226.192.1.1&quot;, 11111 )  --this only works if the device supports multicast

&nbsp;&nbsp; &nbsp;local name = listen:getsockname()
&nbsp;&nbsp; &nbsp;if ( name ) then  --test to see if device supports multicast
&nbsp; &nbsp; &nbsp; &nbsp; listen:setoption( &quot;ip-add-membership&quot;, { multiaddr=&quot;226.192.1.1&quot;, interface = getIP() } )
&nbsp;&nbsp; &nbsp;else  --the device doesn't support multicast so we'll listen for broadcast
&nbsp; &nbsp; &nbsp; &nbsp; listen:close()  --first we close the old socket; this is important
&nbsp; &nbsp; &nbsp; &nbsp; listen = socket.udp()  --make a new socket
&nbsp; &nbsp; &nbsp; &nbsp; listen:setsockname( getIP(), 11111 )  --set the socket name to the real IP address
&nbsp;&nbsp; &nbsp;end

&nbsp;&nbsp; &nbsp;listen:settimeout( 0 )  --move along if there is nothing to hear

&nbsp;&nbsp; &nbsp;local stop

&nbsp;&nbsp; &nbsp;local counter = 0  --pulse counter

&nbsp;&nbsp; &nbsp;local function look()
&nbsp; &nbsp; &nbsp; &nbsp; repeat
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;local data, ip, port = listen:receivefrom()
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--print( &quot;data: &quot;, data, &quot;IP: &quot;, ip, &quot;port: &quot;, port )
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if data and data == msg then
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if not newServers[ip] then
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;    print( &quot;I hear a server:&quot;, ip, port )
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;local params = { [&quot;ip&quot;]=ip, [&quot;port&quot;]=22222 }
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;newServers[ip] = params
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end
&nbsp; &nbsp; &nbsp; &nbsp; until not data

&nbsp; &nbsp; &nbsp; &nbsp; counter = counter + 1
&nbsp; &nbsp; &nbsp; &nbsp; if counter == 20 then  --stop after 2 seconds
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;    stop()
&nbsp; &nbsp; &nbsp; &nbsp; end
&nbsp;&nbsp; &nbsp; end

     --pulse 10 times per second
&nbsp;&nbsp; &nbsp; local beginLooking = timer.performWithDelay( 100, look, 0 )

&nbsp;&nbsp; &nbsp; function stop()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;timer.cancel( beginLooking )
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button.stopLooking = nil
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;evaluateServerList( newServers ) --do something with your found servers
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;listen:close()&nbsp; --never forget to close the socket!
&nbsp;&nbsp; &nbsp; end
&nbsp;&nbsp; &nbsp; button.stopLooking = stopLooking
end</pre><p>I put a lot of inline comments above, but I&#8217;ll elaborate on a few things:</p>
<ul>
<li>Notice that we account for the fact that not all devices have Multicast.</li>
<li>The <code>receivefrom()</code> function is going to just pull in anything that&#8217;s at that address, so we need to filter it. This is why we have the string message to compare with.</li>
<li>When two devices find each other, it can get painful if they both have a short duration. I like to make the server wait much longer than the clients. If the server is advertising, the client finds them pretty quick. Basically, I just want to avoid &#8220;Can you try that again? I missed it.&#8221;</li>
<li>In this example, I&#8217;m passing in a reference to the button that the player pressed to activate the function. I do this because so the player can push it again and stop broadcasting. If you don&#8217;t want to do that, you don&#8217;t need the button reference.</li>
</ul>
<p>So, at this point, we know how to let the game master be discovered by the players. The essential IP address required to use TCP is attached to the UDP message. Now that we have the game master&#8217;s IP address, we can connect to their device using TCP.</p>
<h3>Swapping strings</h3>
<p>Now we&#8217;ll discuss how to create a TCP server, connect to it, and send messages back and forth.</p>
<p>First, let&#8217;s discuss what TCP will provide and what it won&#8217;t. Like I said above, once we have a connection between devices, they&#8217;ll be able to send messages back and forth. These messages will just be strings. Imagine it like a text message app &#8212; in this case, the app on one device sends texts to the app on another device. These messages are then interpreted by the apps on each device and some action occurs.</p>
<h3>Security</h3>
<p>This tutorial will not go in depth about security, but a couple points should be covered:</p>
<ul>
<li>The server and client can only control each other as far as you allow it. As I&#8217;ve iterated several times now, TCP just sends and receives text strings. For a Pac-Man clone that could be controlled by a second device, about the only information the server would need is &#8220;BEGIN&#8221;, &#8220;UP&#8221;, &#8220;DOWN&#8221;, &#8220;LEFT&#8221;, and &#8220;RIGHT&#8221; &#8212; all else could simply be ignored.</li>
<li>You should <strong>never</strong> try to make your app accept functions that have been turned into a string. Let the client and the server have their own functions and just use the transmitted text to call the functions. If your app accepts functions, you open up a very serious security vulnerability, so don&#8217;t do it! Instead, just pass commands with parameters.</li>
</ul>
<p>In any case, don&#8217;t lie awake at night worrying about this. Neither iOS nor Android will let you damage someone&#8217;s device with such foolishness, but it may ruin the install of your game!</p>
<h3>Starting the server</h3>
<p>The server runs in a periodic loop. On each iteration of the loop, it checks to see if any clients want to join and whether connected clients sent a message. If the buffer has any messages to send out, it sends them. Here&#8217;s a basic TCP server module with further explanation following:</p><pre class="crayon-plain-tag">local S = {}

local socket = require( &quot;socket&quot; )

local clientList = {}
local clientBuffer = {}

S.getIP = function()
&nbsp;&nbsp; &nbsp;local s = socket.udp()
&nbsp;&nbsp; &nbsp;s:setpeername( &quot;74.125.115.104&quot;, 80 )
&nbsp;&nbsp; &nbsp;local ip, sock = s:getsockname()
&nbsp;&nbsp; &nbsp;print( &quot;myIP:&quot;, ip, sock )
&nbsp;&nbsp; &nbsp;return ip
end

S.createServer = function()

&nbsp;&nbsp; &nbsp;local tcp, err = socket.bind( S.getIP(), 22222 )  --create a server object
&nbsp;&nbsp; &nbsp;tcp:settimeout( 0 )

&nbsp;&nbsp; &nbsp;local function sPulse()
&nbsp; &nbsp; &nbsp; &nbsp; repeat
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;local client = tcp:accept()  --allow a new client to connect
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if client then
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     print( &quot;found client&quot; )
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; client:settimeout( 0 )  --just check the socket and keep going
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --TO DO: implement a way to check to see if the client has connected previously
                --consider assigning the client a session ID and use it on reconnect.
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clientList[#clientList+1] = client
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clientBuffer[client] = { &quot;hello_client\n&quot; }  --just including something to send below
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end
&nbsp; &nbsp; &nbsp; &nbsp; until not client
&nbsp; &nbsp; &nbsp; &nbsp; 
        local ready, writeReady, err = socket.select( clientList, clientList, 0 )
&nbsp; &nbsp; &nbsp; &nbsp; if err == nil then
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;    for i = 1, #ready do&nbsp; --list of clients who are available
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     local client = ready[i]
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local allData = {}  --this holds all lines from a given client

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; repeat
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;local data, err = client:receive()  --get a line of data from the client, if any
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if data then
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allData[#allData+1] = data
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; until not data

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ( #allData &gt; 0 ) then  --figure out what the client said to the server
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for i, thisData in ipairs( allData ) do
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print( &quot;thisData: &quot;, thisData )
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --do stuff with data
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end

&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for sock, buffer in pairs( clientBuffer ) do
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     for _, msg in pairs( buffer ) do  --might be empty
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;    local data, err = sock:send( msg )  --send the message to the client
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end
&nbsp; &nbsp; &nbsp; &nbsp; end
&nbsp;&nbsp; &nbsp;end

    --pulse 10 times per second
&nbsp;&nbsp; &nbsp;local serverPulse = timer.performWithDelay( 100, sPulse, 0 )

&nbsp;&nbsp; &nbsp;local function stopServer()
&nbsp; &nbsp; &nbsp; &nbsp; timer.cancel( serverPulse )  --cancel timer
&nbsp; &nbsp; &nbsp; &nbsp; tcp:close()
&nbsp; &nbsp; &nbsp; &nbsp; for i, v in pairs( clientList ) do
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;    v:close()
&nbsp; &nbsp; &nbsp; &nbsp; end
&nbsp;&nbsp; &nbsp;end
&nbsp;&nbsp; &nbsp;return stopServer
end

return S</pre><p>And that is a basic server. Let&#8217;s start at the top with some explanation:</p>
<ul>
<li><code>socket.bind()</code> creates a server object which you bind to the port of your choice. I used <code>11111</code>, but you can use any that we listed in the earlier section. Remember to close the TCP object when you shut down the server via the <code>stopServer()</code> function!</li>
<li><code>settimeout( 0 )</code> tells LuaSocket to move on if there&#8217;s no information waiting at the socket.</li>
<li><code>accept()</code> returns a client object which represents the connection to the other device. Each client will get their own object and each one will need to be closed when the game is done. We do this in the function at the bottom called <code>stopServer()</code>.</li>
<li><code>socket.select()</code> goes through our list of client connections to see which are available. Any that are not available are ignored but not closed.</li>
<li><code>receive()</code> receives one line of data. You can designate a line of data in a string by putting <code>\n</code> at the end. It&#8217;s simple and you&#8217;ll be able to create bite-sized pieces of data. This function is structured so that you end up with a numbered table of string lines. They are numbered in the order that they were received, but you can&#8217;t rely on the lines you send being received in the order you sent them. If this is important, and it often is, you&#8217;ll need to create a way for the server to know if a line is in the right order.</li>
<li>Next we go through the list of lines and interpret them. This is usually just a series of <code>if</code>&#8211;<code>then</code> statements with a liberal use of the <a href=http://docs.coronalabs.com/api/library/string/index.html target="_blank">string</a> library.</li>
<li>Finally, we send whatever is in the buffer. The buffer is another list of strings. Again, you can&#8217;t absolutely control the order in which they are received. You don&#8217;t have to use a buffer, but when you are using a multi-use device like a phone as a server, it&#8217;s a good idea. You may just <code>:send()</code> to a client socket at any time but the only way the device knows that the message didn&#8217;t go through is if the other device responds. If the other device is taking a call, it will ignore your message and the message will be lost. If you implement a buffer, it sends the message every pulse until something happens that removes the message from the buffer, however you&#8217;ll need to implement a way of knowing when to remove items from the buffer.</li>
</ul>
<h3>Connecting to the server</h3>
<p>Connecting to the server is much simpler:</p><pre class="crayon-plain-tag">local function connectToServer( ip, port )
&nbsp;&nbsp; &nbsp;local sock, err = socket.connect( ip, port )
&nbsp;&nbsp; &nbsp;if sock == nil then
&nbsp; &nbsp; &nbsp; &nbsp; return false
&nbsp;&nbsp; &nbsp;end
&nbsp;&nbsp; &nbsp;sock:settimeout( 0 )
&nbsp;&nbsp; &nbsp;sock:setoption( &quot;tcp-nodelay&quot;, true )  --disable Nagle's algorithm
&nbsp;&nbsp; &nbsp;sock:send( &quot;we are connected\n&quot; )
&nbsp;&nbsp; &nbsp;return sock
end</pre><p>To elaborate on this slightly:</p>
<ul>
<li><code>socket.connect</code> is pretty self explanatory: attempt to connect to the server at that address.</li>
<li><code>settimeout( 0 )</code> again lets the socket know that you want it to just check the socket and move on if there&#8217;s no incoming message.</li>
<li>Nagle&#8217;s algorithm is a standard function that causes the socket to aggregate data until the data is of a certain size, then send it. If you are just going to send &#8220;UP&#8221; and you want it sent right away, you&#8217;ll want this off.</li>
</ul>
<p>What&#8217;s not included in this example is a method to determine if the client is connecting for the first time or reconnecting (return session). This is outside the scope of this tutorial, but one option is to use a session ID which the client gets the first time it connects to the server. In this case, both the client and the server save the ID. Then, if the client loses the connection, this ID is sent upon reconnection and the server can update the client&#8217;s data with the new client socket.</p>
<h3>Client loop</h3>
<p>The final piece of the puzzle is the client loop. This will look very much like the server loop, but it never tries to accept connections.</p><pre class="crayon-plain-tag">local function createClientLoop( sock, ip, port )

&nbsp;&nbsp; &nbsp;local buffer = {}
&nbsp;&nbsp; &nbsp;local clientPulse

&nbsp;&nbsp; &nbsp;local function cPulse()
&nbsp; &nbsp; &nbsp; &nbsp; local allData = {}
&nbsp; &nbsp; &nbsp; &nbsp; local data, err

&nbsp; &nbsp; &nbsp; &nbsp; repeat
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;data, err = sock:receive()
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if data then
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allData[#allData+1] = data
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if ( err == &quot;closed&quot; and clientPulse ) then  --try again if connection closed
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     connectToServer( ip, port )
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data, err = sock:receive()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if data then
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;    allData[#allData+1] = data
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end
&nbsp; &nbsp; &nbsp; &nbsp; until not data

&nbsp; &nbsp; &nbsp; &nbsp; if ( #allData &gt; 0 ) then
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;    for i, thisData in ipairs( allData ) do
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     print( &quot;thisData: &quot;, thisData )
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --react to incoming data&nbsp;
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end
&nbsp; &nbsp; &nbsp; &nbsp; end

&nbsp; &nbsp; &nbsp; &nbsp; for i, msg in pairs( buffer ) do
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;    local data, err = sock:send(msg)
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if ( err == &quot;closed&quot; and clientPulse ) then  --try to reconnect and resend
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     connectToServer( ip, port )
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data, err = sock:send( msg )
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end
&nbsp; &nbsp; &nbsp; &nbsp; end
&nbsp;&nbsp; &nbsp;end

    --pulse 10 times per second
&nbsp;&nbsp; &nbsp;clientPulse = timer.performWithDelay( 100, cPulse, 0 )

&nbsp;&nbsp; &nbsp;local function stopClient()
&nbsp; &nbsp;     timer.cancel( clientPulse )  --cancel timer
&nbsp; &nbsp; &nbsp; &nbsp; clientPulse = nil
&nbsp; &nbsp; &nbsp; &nbsp; sock:close()
&nbsp;&nbsp; &nbsp;end
&nbsp;&nbsp; &nbsp;return stopClient
end</pre><p>Note that the client is always responsible for making the connection to the server. The server never tries to reach the client — it has enough to handle already. Beyond that, there isn&#8217;t anything clarify that wasn&#8217;t already covered in the server loop section.</p>
<h3>Conclusion</h3>
<p>I hope this tutorial helps you achieve your multiplayer dreams! While it&#8217;s not intended to be a comprehensive tutorial on networking, what I accomplished should help you get two devices talking with each other using TCP.</p>
<p>Thank you for reading and remember to check out <a href=http://www.legendofus.net/ target="_blank">Legend of Us Roleplaying Game</a> which inspired me to figure all of this out.</p>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2014/09/23/tutorial-local-multiplayer-with-udptcp/feed/</wfw:commentRss>
		<slash:comments>25</slash:comments>
		</item>
	</channel>
</rss>
