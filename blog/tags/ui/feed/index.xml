<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>ui &#8211; Corona Labs</title>
	<atom:link href="/blog/tags/ui/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description></description>
	<lastBuildDate>Mon, 19 Oct 2020 12:16:12 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.8</generator>

<image>
	<url>/wordpress/wp-content/uploads/2017/06/cropped-icon_32x32@2x-32x32.png</url>
	<title>ui &#8211; Corona Labs</title>
	<link>/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>From the Forum — Issue #128</title>
		<link>/blog/2016/06/17/from-the-forum-issue-128/</link>
		<pubDate>Sat, 18 Jun 2016 00:04:02 +0000</pubDate>
		<dc:creator><![CDATA[alex]]></dc:creator>
				<category><![CDATA[From the Forum]]></category>
		<category><![CDATA[android]]></category>
		<category><![CDATA[high score]]></category>
		<category><![CDATA[Material]]></category>
		<category><![CDATA[score keeping]]></category>
		<category><![CDATA[scores]]></category>
		<category><![CDATA[sprite]]></category>
		<category><![CDATA[sprite edtior]]></category>
		<category><![CDATA[ui]]></category>

		<guid isPermaLink="false">/?p=67198</guid>
		<description><![CDATA[Welcome to the latest installment of From the Forum. In this series, guest blogger Alex Jackson highlights outstanding threads from the Corona Forum. The goal is to bring attention to the most captivating, interesting, and thought-provoking discussions taking place in our very own backyard.]]></description>
				<content:encoded><![CDATA[<p><img class="alignright size-full wp-image-54943" style="margin: 0px 0px 10px 10px;" src="/wordpress/wp-content/uploads/2014/01/Icon_Resources_Forum.png" alt="From the Forum" /><em>Welcome to the latest installment of <strong>From the Forum</strong>. In <em>this series</em>, guest blogger Alex Jackson highlights outstanding threads from the <a href=http://forum.coronalabs.com/ target="_blank">Corona Forum</a>. The goal is to bring attention to the most captivating, interesting, and thought-provoking discussions taking place in our very own backyard.</em></p>
<p><em>Please <a href=http://forum.coronalabs.com/ target="_blank">visit the forum</a> to join these conversations or start your own!</em></p>
<hr />
<h3>A scorekeeping module keeping up with the best in branding</h3>
<p>I’m all for making things easier in life. Superstar developer <strong>DevilSquid</strong> provided a very useful module that saves us time when handling scores in your game. It lets you use your own bitmap fonts, and has some nifty particle effects to give boring old text a little razzle dazzle.</p>
<p>Come on over and check out the <a href=https://forums.coronalabs.com/topic/63466-uberscore-%E2%80%93-animated-score-counter-quick-easy/ target="_blank">original thread here</a>!</p>
<h3>Crowd-sourced Material UI</h3>
<p>I’m a pretty big fan of a unified user interface. Something about a well-thought-out UI marrying intuitive functionality with practicality turns an otherwise simple app into something I cannot do without.</p>
<p>Google Material is one design scheme that hits every one of my interest points. That’s why, when another Corona developer took it upon themselves to re-create Google Material within Corona SDK, I applauded. When they decided to turn it into a publicly available module, complete with a home on Github, I knew that I had to do whatever I could to make sure that the project received as many eyeballs as possible.</p>
<p>It’s already relatively robust, with <a href=https://forums.coronalabs.com/topic/62108-implementing-ui-based-on-ios-7-google-material/ target="_blank">the original thread</a> showing off some basic features and Material aesthetics. The best part of this story is that we can all add onto this great work! Make a pull request and you can contribute right now!</p>
<h3>Community suggestions on the best sprite editor</h3>
<p>We all have our preferences when it comes to digital editing suites. It’s difficult to find one that scratches every single itch that we developers have, but it’s possible to get pretty close.</p>
<p>To this end, a developer was recently looking for suggestions on what Sprite editors the Corona community favored. The answers that came back ran the gamut between obscure and well-known. Anyone looking to change their graphics editing routine (or perhaps, looking for something to start out with) would do well to check out <a href=https://forums.coronalabs.com/topic/63563-sprite-editor/ target="_blank">the original thread</a>!</p>
<h4>About Alex</h4>
<p>Alex Jackson is an indie developer and the founder of <a href=http://www.panc.co/ target="_blank">Panc Interactive</a>, specializing in retro-style gaming. He has created several mobile applications, enjoys long walks on the beach, pixel art, and reading the Corona forums. Contact him by <a href=mailto:alex@panc.co>email</a> or follow him on Twitter: <a href=http://twitter.com/pancinteractive>@pancinteractive</a>. Check out his new game <a href=http://www.panc.co/segreta-download-page.html target="_blank">Segreta</a> on iOS, Android, Windows Phone and Amazon devices.</p>
]]></content:encoded>
			</item>
		<item>
		<title>Tutorial: New native text input features</title>
		<link>/blog/2014/12/16/tutorial-new-native-text-input-features/</link>
		<comments>/blog/2014/12/16/tutorial-new-native-text-input-features/#comments</comments>
		<pubDate>Tue, 16 Dec 2014 19:00:41 +0000</pubDate>
		<dc:creator><![CDATA[Rob Miracle]]></dc:creator>
				<category><![CDATA[Tutorials, Tips and Demos]]></category>
		<category><![CDATA[native text input]]></category>
		<category><![CDATA[tutorial]]></category>
		<category><![CDATA[ui]]></category>

		<guid isPermaLink="false">/?p=60567</guid>
		<description><![CDATA[Starting with Daily Build #2520, some new functions have been introduced to control and adapt native input fields/boxes to specific font sizes or field heights. These additions will help in the development of user interfaces for cross-platform apps. Read further to learn how these features may impact your current development.]]></description>
				<content:encoded><![CDATA[<p>Starting with <a href=http://developer.coronalabs.com/downloads/daily-builds/ target="_blank">Daily Build #2520</a>, the Corona Labs engineering team made some significant updates to the two native text entry API functions, <a href=http://docs.coronalabs.com/daily/api/library/native/newTextField.html target="_blank">native.newTextField()</a> and <a href=http://docs.coronalabs.com/daily/api/library/native/newTextBox.html target="_blank">native.newTextBox()</a>. Some of these are <strong>breaking</strong> changes, meaning that they will cause your apps to behave differently.</p>
<p>Before we talk about these changes, let&#8217;s discuss why they were implemented. Essentially, the <a href=http://docs.coronalabs.com/daily/api/library/native/index.html target="_blank">native</a> API features live outside of the Corona SDK OpenGL display hierarchy. If you define your content area as 320×480, create a <a href=http://docs.coronalabs.com/daily/api/library/display/newText.html target="_blank">display.newText()</a> object with a <strong>20</strong> point font, and run the app on an iPhone 5S (640×1136), Corona SDK will automatically make that a <strong>40</strong> pixel text object. In this same case, if the text inside a <a href=http://docs.coronalabs.com/daily/api/library/native/index.html target="_blank">native</a> input field is also 20 points, the operating system will scale the font from 20 points to 40 points so that it fits. However, if your content area isn&#8217;t pixel perfect &#8212; say 320 points on what should be a 360 point iPad &#8212; or if you&#8217;re trying to adapt it to Android&#8217;s 160-ppi setup, the scaling may not end up matching. In addition, on iOS, OS X, and Android, the amount of &#8220;chrome&#8221; (decoration/border around the input area) varies, thus compounding the overall issue.</p>
<p>With this in mind, let&#8217;s explore the changes and how they impact these two API calls.</p>
<h3>native.newTextField() and native.newTextBox() now use scaled fonts</h3>
<p>This is a <strong>breaking</strong> change. Now, when using <a href=http://docs.coronalabs.com/daily/api/library/native/newTextField.html target="_blank">native.newTextField()</a> or <a href=http://docs.coronalabs.com/daily/api/library/native/newTextBox.html target="_blank">native.newTextBox()</a>, the specified font size will match the size of a <a href=http://docs.coronalabs.com/daily/api/library/display/newText.html target="_blank">display.newText()</a> object that uses the same font size (previously this was based on the device&#8217;s native point size).</p>
<p>Because this is a breaking change, and you may have implemented a workaround for font scaling, we&#8217;ve provided two new &#8220;legacy&#8221; setting options via <a href=http://docs.coronalabs.com/daily/api/library/display/setDefault.html target="_blank">display.setDefault()</a>. Note that there is a distinct option for native text input <strong>fields</strong> and <strong>boxes</strong>:</p>
<ul>
<li>Input <strong>field</strong> &#8212; <code>display.setDefault( "isNativeTextFieldFontSizeScaled", false )</code></li>
<li>Input <strong>box</strong> &#8212; <code>display.setDefault( "isNativeTextBoxFontSizeScaled", false )</code></li>
</ul>
<h3>Fonts automatically resize to fit the field height</h3>
<p>In a previous <a href=/blog/2014/12/02/tutorial-sizing-text-input-fields/ target="_blank">tutorial</a>, we introduced a couple functions to help size your text input fields and the text within them. One of the sample functions allowed you to specify the desired height of the field and have the font fit the field. This is now the <strong>default</strong> behavior for <a href=http://docs.coronalabs.com/daily/api/library/native/newTextField.html target="_blank">native.newTextField()</a>.</p>
<p>However, if you&#8217;ve already implemented a workaround, you can change this behavior as well. You can either have the font resize to fit the field <strong>or</strong> the field resize to contain the font. This is achieved via two new functions:</p>
<ul>
<li><a href=http://docs.coronalabs.com/daily/api/type/TextField/resizeFontToFitHeight.html target="_blank">object:resizeFontToFitHeight()</a></li>
<li><a href=http://docs.coronalabs.com/daily/api/type/TextField/resizeHeightToFitFont.html target="_blank">object:resizeHeightToFitFont()</a></li>
</ul>
<p>The first of these functions (<a href=http://docs.coronalabs.com/daily/api/type/TextField/resizeFontToFitHeight.html target="_blank">object:resizeFontToFitHeight()</a>) is useful if you change the input field&#8217;s height sometime after the field is created, and you want to resize the font to fit within the field. For example:</p><pre class="crayon-plain-tag">local textField = native.newTextField( 160, 240, 280, 40 )
textField.text = &quot;Hello World&quot;

-- Change the height of the text field
textField.height = 60
-- Resize the font to best fit the text field's new height
textField:resizeFontToFitHeight()</pre><p>The second function (<a href=http://docs.coronalabs.com/daily/api/type/TextField/resizeHeightToFitFont.html target="_blank">object:resizeHeightToFitFont()</a>) is useful when the font size is the higher priority, and the field can be a variable size to accommodate the font size.</p><pre class="crayon-plain-tag">local textField = native.newTextField( 160, 240, 280, 40 )
textField.text = &quot;Hello World&quot;

-- Change the text field's font size to the system default
textField.size = 60
-- Resize the text field's height to best fit the font
textField:resizeHeightToFitFont()</pre><p><strong>IMPORTANT:</strong> If you choose to use these new scaling methods, you should <strong>not</strong> use the functions presented in the previous tutorial.</p>
<h3>Better use of chrome on Android</h3>
<p>On Android, the &#8220;chrome&#8221; around the text field comes from a 9-slice image sheet (in Corona terms). This contains some extra transparency which causes the box to be smaller than it needs to be. Now, we look through the pixels to scale the text field so that it better matches what you see in the Corona Simulator and on iOS devices. This should make building multi-platform apps easier.</p>
<p><a href=/wordpress/wp-content/uploads/2014/12/textfieldsizechanges.png><img class="alignnone size-full wp-image-60570" src=/wordpress/wp-content/uploads/2014/12/textfieldsizechanges.png alt="textfieldsizechanges" width="800" height="640" /></a></p>
<p>In the diagram above, the green area represents the extra transparency that was making the fields a bit smaller than they should have been. Because of this change, your existing text fields will become slightly larger when  you rebuild your app using Daily Build #2520 or later.</p>
<h3>The Corona Simulator for OS X now resizes fonts</h3>
<p>One of the caveats in the previous tutorial involved font scaling in the Corona Simulator for OS X. If the Simulator &#8220;skin&#8221; was not at 100% zoom, the font would appear too large. As such, you could only use the new functions we introduced while the skin was at 100% zoom. Now, native fonts will resize correctly in the Corona Simulator for OS X.</p>
<h3>Support for the system default font size</h3>
<p>Corona SDK now lets you set the font size for native text input objects to match the user&#8217;s selected system default size. To do so, simply set the font&#8217;s size to <code>nil</code> and the font size for <a href=http://docs.coronalabs.com/daily/api/library/native/newTextField.html target="_blank">native.newTextField()</a> and <a href=http://docs.coronalabs.com/daily/api/library/native/newTextBox.html target="_blank">native.newTextBox()</a> will obey the system default.</p><pre class="crayon-plain-tag">local textField = native.newText( 160, 240, 280, 30 )
textField.size = nil  -- Set font size to the system default
textField:resizeHeightToFitFont()</pre><p>This is a very useful feature, but you may need to put in more effort to lay out the text fields since the default font size can vary wildly between devices. If you pass in <code>nil</code> as the <code>fontSize</code> property of <a href=http://docs.coronalabs.com/daily/api/library/display/newText.html target="_blank">display.newText()</a> or <a href=http://docs.coronalabs.com/daily/api/library/display/newEmbossedText.html target="_blank">display.newEmbossedText()</a> (or simply omit it entirely), those objects will use the default font size as well.</p>
<h3>Other miscellaneous fixes</h3>
<p>Two other features/fixes related to fonts were also implemented as of Daily Build #2520:</p>
<ol>
<li>Previously, on iOS, there was a bug that prevented you from changing the size of a <a href=http://docs.coronalabs.com/daily/api/library/native/newTextBox.html target="_blank">native.newTextBox()</a> until <strong>after</strong> the box had text inside it. This bug has been fixed.</li>
<li>Before, if you wanted to change the font on a <a href=http://docs.coronalabs.com/daily/api/library/native/newTextField.html target="_blank">native.newTextField()</a> or <a href=http://docs.coronalabs.com/daily/api/library/native/newTextBox.html target="_blank">native.newTextBox()</a>, you had to call the <a href=http://docs.coronalabs.com/daily/api/library/native/newFont.html target="_blank">native.newFont()</a> API, yet for <a href=http://docs.coronalabs.com/daily/api/library/display/newText.html target="_blank">display.newText()</a> you were always expected to specify a string for the font name. Now, for consistency, you can pass a <a href=http://docs.coronalabs.com/daily/api/library/native/newFont.html target="_blank">native.newFont()</a> value to <a href=http://docs.coronalabs.com/daily/api/library/display/newText.html target="_blank">display.newText()</a> as well.</li>
</ol>
<h3>Conclusion</h3>
<p>With these new features to control and adapt native input fields/boxes to specific font sizes or field heights, developing user interfaces for cross-platform apps using Corona is now easier and more cohesive.</p>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2014/12/16/tutorial-new-native-text-input-features/feed/</wfw:commentRss>
		<slash:comments>8</slash:comments>
		</item>
		<item>
		<title>Tutorial: Moving native text input fields/boxes</title>
		<link>/blog/2014/11/18/tutorial-moving-native-textfieldtextbox-objects/</link>
		<comments>/blog/2014/11/18/tutorial-moving-native-textfieldtextbox-objects/#comments</comments>
		<pubDate>Tue, 18 Nov 2014 22:14:44 +0000</pubDate>
		<dc:creator><![CDATA[Rob Miracle]]></dc:creator>
				<category><![CDATA[Tutorials, Tips and Demos]]></category>
		<category><![CDATA[keyboard]]></category>
		<category><![CDATA[native text input]]></category>
		<category><![CDATA[text input]]></category>
		<category><![CDATA[tutorial]]></category>
		<category><![CDATA[ui]]></category>

		<guid isPermaLink="false">/?p=60212</guid>
		<description><![CDATA[If you develop a mobile app user interface where native text input objects exist in the lower half of the screen, those objects are prone to being covered by the device's keyboard. In this tutorial, we'll explore a simple method to prevent this.]]></description>
				<content:encoded><![CDATA[<p>One challenge for Corona developers is how to deal with <a href=http://docs.coronalabs.com/api/library/native/newTextField.html target="_blank">native.newTextField()</a> and <a href=http://docs.coronalabs.com/api/library/native/newTextBox.html target="_blank">native.newTextBox()</a> objects, in particular when they are located in the lower half of the screen where they can be covered by the device&#8217;s keyboard. A common solution is to explicitly move native text field/box objects upward by some variable &#8220;keyboard height&#8221; when the keyboard becomes active, thus keeping them within view/access of the user.</p>
<h3>Using display groups</h3>
<p>For simplicity, native objects can be moved as one &#8220;unit,&#8221; specifically as part of a <a href=http://docs.coronalabs.com/api/library/display/newGroup.html target="_blank">display.newGroup()</a> which may contain supporting objects like a background, images, buttons, etc. Consider this code:</p><pre class="crayon-plain-tag">display.setDefault( &quot;background&quot;, 0.5 )

-- Create forward references for UI objects
local value1, value2, result

-- Create new display group for the UI objects
local UIGroup = display.newGroup()

-- Listener function for text input events
local function textListener( event )

    if ( event.phase == &quot;began&quot; ) then

        -- Transition group upward to y=50
        transition.to( UIGroup, { time=1000, y=50 } )

    elseif ( event.phase == &quot;ended&quot; or event.phase == &quot;submitted&quot; ) then

        local v1 = tonumber( value1.text )
        local v2 = tonumber( value2.text )
        if ( v1 and v2 ) then
            -- Update the &quot;result&quot; text object
            result.text = v1 + v2
            -- Dismiss (hide) the native keyboard
            native.setKeyboardFocus( nil )
            -- Transition group back down to y=300
            transition.to( UIGroup, { time = 1000, y = 300 })
        end
    end
end

local title = display.newText( &quot;Add two numbers&quot;, display.contentCenterX, 75, native.systemFont, 40 )
title:setFillColor( 0, 0, 0 )
UIGroup:insert( title )

value1 = native.newTextField( display.contentCenterX, 150, 160, 40 )
UIGroup:insert( value1 )
value1:addEventListener( &quot;userInput&quot;, textListener )
value1.inputType = &quot;number&quot;

value2 = native.newTextField( display.contentCenterX, 225, 160, 40 )
UIGroup:insert( value2 )
value2:addEventListener( &quot;userInput&quot;, textListener )
value2.inputType = &quot;number&quot;

local plus = display.newText( &quot;+&quot;, display.contentCenterX-120, 215, native.systemFont, 80 )
plus:setFillColor( 0, 0, 0 )
UIGroup:insert( plus )

result = display.newText( &quot;______&quot;, display.contentCenterX, 300, native.systemFont, 80 )
result:setFillColor( 0, 0, 0 )
UIGroup:insert( result )

local equals = display.newText( &quot;=&quot;, display.contentCenterX-120, 300, native.systemFont, 80 )
equals:setFillColor( 0, 0, 0 )
UIGroup:insert( equals )

-- Initially position the group at y=300
UIGroup.y = 300</pre><p>This code creates a simple UI (User Interface) consisting of two text fields named <code>value1</code> and <code>value2</code>, plus (<strong>+</strong>) and equal (<strong>=</strong>) text objects, a <strong>title</strong> text label, and a label to hold the results of summing the two fields. All of these objects are inserted within the <code>UIGroup</code> display group, including the native text fields. Thus, when we position the group &#8212; or transition it upwards or downwards &#8212; everything moves in unison.</p>
<p>Of course, this doesn&#8217;t mean that you can position native objects in front of normal display objects &#8212; native objects will <strong>always</strong> appear in front of other display objects, but we can still handle the movement and positioning of these objects as one collective group.</p>
<p>Note that when handling the text field inputs, we confirm that a value has been entered into <strong>both</strong> fields before transitioning the group back down. We also confirm that each value is a number to avoid any potential errors in summing them together. With these two checks in place, the fields will remain accessible above the keyboard while the user interacts with them, and then when both have valid entries, the group can transition back down while the keyboard is simultaneously dismissed/hidden. Of course, depending on your own design, this approach may vary, but you should ensure that the input fields remain accessible for the duration of the required interactivity.</p>
<h3>Conclusion</h3>
<p>As demonstrated, this method is useful for handling native input objects. It can benefit developers of business/utility apps in particular, since apps in these categories often rely on keyboard-based interaction.</p>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2014/11/18/tutorial-moving-native-textfieldtextbox-objects/feed/</wfw:commentRss>
		<slash:comments>7</slash:comments>
		</item>
		<item>
		<title>Widgets — Creating a sliding panel</title>
		<link>/blog/2014/04/08/widgets-creating-a-sliding-panel/</link>
		<comments>/blog/2014/04/08/widgets-creating-a-sliding-panel/#comments</comments>
		<pubDate>Wed, 09 Apr 2014 01:21:38 +0000</pubDate>
		<dc:creator><![CDATA[Rob Miracle]]></dc:creator>
				<category><![CDATA[Tutorials, Tips and Demos]]></category>
		<category><![CDATA[panel]]></category>
		<category><![CDATA[tutorial]]></category>
		<category><![CDATA[ui]]></category>
		<category><![CDATA[widget]]></category>

		<guid isPermaLink="false">/?p=57969</guid>
		<description><![CDATA[Today's tutorial demonstrates how to create a sliding panel that has many uses, ranging from games to business applications. Using just one core function, you can easily implement a wide variety of panels that appear from different sides of the screen and utilize unique easing transitions.]]></description>
				<content:encoded><![CDATA[<p>Today&#8217;s tutorial demonstrates how to create a <strong>sliding panel</strong> that has many uses, ranging from games to business applications. You might build an adventure game where the player&#8217;s inventory needs to slide on the screen, then hide itself when the user is done. Or you might build a menu that slides in when the player taps the infamous &#8220;hamburger&#8221; menu icon. Yet another possibility is sliding notices in and out.</p>
<p>As with the previous UI tutorials on <a href=http://www.coronalabs.com/blog/2013/12/31/tutorial-extending-widgets-with-a-navigation-bar/ target="_blank">navigation panels</a> and <a href=http://www.coronalabs.com/blog/2013/12/03/tutorial-customizing-text-input/ target="_blank">text fields</a>, this tutorial will extend the <a href=http://docs.coronalabs.com/api/library/widget/index.html target="_blank">widget</a> library, creating a <strong>new</strong> widget called <code>widget.newPanel()</code>. Let&#8217;s look at the entire function:</p><pre class="crayon-plain-tag">function widget.newPanel( options )
    local customOptions = options or {}
    local opt = {}

    opt.location = customOptions.location or &quot;top&quot;

    local default_width, default_height
    if ( opt.location == &quot;top&quot; or opt.location == &quot;bottom&quot; ) then
        default_width = display.contentWidth
        default_height = display.contentHeight * 0.33
    else
        default_width = display.contentWidth * 0.33
        default_height = display.contentHeight
    end

    opt.width = customOptions.width or default_width
    opt.height = customOptions.height or default_height

    opt.speed = customOptions.speed or 500
    opt.inEasing = customOptions.inEasing or easing.linear
    opt.outEasing = customOptions.outEasing or easing.linear

    if ( customOptions.onComplete and type(customOptions.onComplete) == &quot;function&quot; ) then
        opt.listener = customOptions.onComplete
    else 
        opt.listener = nil
    end

    local container = display.newContainer( opt.width, opt.height )

    if ( opt.location == &quot;left&quot; ) then
        container.anchorX = 1.0
        container.x = display.screenOriginX
        container.anchorY = 0.5
        container.y = display.contentCenterY
    elseif ( opt.location == &quot;right&quot; ) then
        container.anchorX = 0.0
        container.x = display.actualContentWidth
        container.anchorY = 0.5
        container.y = display.contentCenterY
    elseif ( opt.location == &quot;top&quot; ) then
        container.anchorX = 0.5
        container.x = display.contentCenterX
        container.anchorY = 1.0
        container.y = display.screenOriginY
    else
        container.anchorX = 0.5
        container.x = display.contentCenterX
        container.anchorY = 0.0
        container.y = display.actualContentHeight
    end

    function container:show()
        local options = {
            time = opt.speed,
            transition = opt.inEasing
        }
        if ( opt.listener ) then
            options.onComplete = opt.listener
            self.completeState = &quot;shown&quot;
        end
        if ( opt.location == &quot;top&quot; ) then
            options.y = display.screenOriginY + opt.height
        elseif ( opt.location == &quot;bottom&quot; ) then
            options.y = display.actualContentHeight - opt.height
        elseif ( opt.location == &quot;left&quot; ) then
            options.x = display.screenOriginX + opt.width
        else
            options.x = display.actualContentWidth - opt.width
        end 
        transition.to( self, options )
    end

    function container:hide()
        local options = {
            time = opt.speed,
            transition = opt.outEasing
        }
        if ( opt.listener ) then
            options.onComplete = opt.listener
            self.completeState = &quot;hidden&quot;
        end
        if ( opt.location == &quot;top&quot; ) then
            options.y = display.screenOriginY
        elseif ( opt.location == &quot;bottom&quot; ) then
            options.y = display.actualContentHeight
        elseif ( opt.location == &quot;left&quot; ) then
            options.x = display.screenOriginX
        else
            options.x = display.actualContentWidth
        end 
        transition.to( self, options )
    end

    return container
end</pre><p>For consistency, this new widget will follow the coding standard of the other widgets in the Corona <a href=https://github.com/coronalabs/framework-widget target="_blank">open source</a> widget library. Like other widgets, we begin by passing in a table of parameters necessary to create the panel (lines 5 through 27). These include:</p>
<ul>
<li><code>location</code> — where the panel originates from (left, right, top, or bottom).</li>
<li><code>width</code> — the width of the panel.</li>
<li><code>height</code> — the height of the panel.</li>
<li><code>speed</code> — how fast the panel shows and hides (slides in or out).</li>
<li><code>inEasing</code> — the transition <a href=http://docs.coronalabs.com/api/library/easing/index.html target="_blank">easing</a> method used when the panel shows.</li>
<li><code>outEasing</code> — the transition <a href=http://docs.coronalabs.com/api/library/easing/index.html target="_blank">easing</a> method used when the panel hides.</li>
<li><code>onComplete</code> — a function to execute when the panel completes showing and hiding.</li>
</ul>
<p>All parameters are optional and are set to reasonable defaults. The <code>location</code> parameter is a string value of either <code>"left"</code>, <code>"right"</code>, <code>"top"</code> or <code>"bottom"</code> that defaults to <code>"top"</code>. The <code>speed</code> parameter defaults to <strong>500</strong> milliseconds. <code>inEasing</code> and <code>outEasing</code> are <strong>linear</strong> by default but can be set to any of the standard <a href=http://docs.coronalabs.com/api/library/easing/index.html target="_blank">easing</a> methods.</p>
<p><code>onComplete</code> is optional and defaults to <code>nil</code>. In the above example, we actually create two completion listeners, one for each of the actions the panel supports (<code>panel:show()</code> and <code>panel:hide()</code>).</p>
<h4>Code notes</h4>
<p>Let&#8217;s step through the function code and inspect some important aspects:</p>
<ul>
<li>When adding the code to define the listener (lines 23-27), it&#8217;s helpful to make sure that a parameter was passed, but also that it&#8217;s a function and not some other variable type.</li>
<li>If a panel slides in from the left or right, it&#8217;s reasonable to take up the full height of the visible screen, but the width would need to be specific to the app. Panels coming in from the top or bottom may take up the full width of the device but be limited to 1/3 of the screen.</li>
<li>Line 29 creates a <a href=http://docs.coronalabs.com/api/library/display/newContainer.html target="_blank">display.newContainer()</a>. This is similar to <a href=http://docs.coronalabs.com/api/library/display/newGroup.html target="_blank">display.newGroup()</a>, except that its bounds are automatically clipped to the defined width and height. This container object is returned on line 95 to the calling function.</li>
<li>The panel is positioned off screen based on the location specified. Since there are many ways to set up the size and scale in <code>config.lua</code>, this function uses <code>display.screenOriginX</code> and <code>display.screenOriginY</code> to reference the left and top of the screen. Likewise, <code>display.actualContentWidth</code> and <code>display.actualContentHeight</code> represents the right and bottom edges of the screen. By setting the anchor point to the side of the container that faces the content area, we can use these values to position it. The other value will simply center the container along that edge.</li>
<li>To show and hide the panel, two methods are included named <code>show()</code> and <code>hide()</code>. Lines 53-93 implement these two functions. The panels will be shown or hidden using a simple <code>transition.to()</code> call, but first we need to determine where to move the panel to. If we&#8217;re sliding the panel in/out from the top or bottom, we need to transition the <strong>y</strong> value. If we&#8217;re sliding it in/out from either side, we need to use the <strong>x</strong> value. Again, we use the defined points for the sides of the screen and either add or subtract the width or height of the panel.</li>
</ul>
<h3>Using the &#8220;widget.newPanel()&#8221;</h3>
<p>To use the panel, simply create a new object, in this case <code>panel</code>, and above that, the optional listener function that&#8217;s specified as the <code>onComplete</code> parameter:</p><pre class="crayon-plain-tag">local function panelTransDone( target )
    native.showAlert( &quot;Panel&quot;, &quot;Complete&quot;, { &quot;Okay&quot; } )
    if ( target.completeState ) then
        print( &quot;PANEL STATE IS: &quot;..target.completeState )
    end
end

local panel = widget.newPanel{
    location = &quot;top&quot;,
    onComplete = panelTransDone,
    width = display.contentWidth * 0.8,
    height = display.contentHeight * 0.8,
    speed = 250,
    inEasing = easing.outBack,
    outEasing = easing.outCubic
}</pre><p>When done, <code>panel</code> will be the container object to which we can add whatever content desired using the <code>object:insert()</code> call. To keep things more organized, display objects can optionally be added directly to the panel object:</p><pre class="crayon-plain-tag">panel.background = display.newRect( 0, 0, panel.width, panel.height )
panel.background:setFillColor( 0, 0.25, 0.5 )
panel:insert( panel.background )

panel.title = display.newText( &quot;menu&quot;, 0, 0, native.systemFontBold, 18 )
panel.title:setFillColor( 1, 1, 1 )
panel:insert( panel.title )</pre><p></p>
<h4>Showing and hiding</h4>
<p>When desired, we can show or hide the panel by simply calling the proper method:</p><pre class="crayon-plain-tag">panel:show()
panel:hide()</pre><p></p>
<h4>Composer notes</h4>
<p>If you&#8217;re using <a href=http://docs.coronalabs.com/guide/system/composer/index.html target="_blank">Composer</a>, you may not want to insert the panel into the Composer group because the panel is generally intended to slide <strong>over</strong> anything else in the scene. However, if you choose to add it to the scene&#8217;s view, it should be the <strong>last</strong> thing inserted into the scene, or else you should call <a href=http://docs.coronalabs.com/api/type/DisplayObject/toFront.html target="_blank">object:toFront()</a> to move it to the top of the scene&#8217;s view.</p>
<p>On the general topic of Composer, you may ask &#8220;shouldn&#8217;t this be done with an overlay?&#8221;. While that is a valid approach, overlays are individual scenes and it takes more effort to construct and deconstruct a scene. In contrast, <code>widget.newPanel()</code> yields a simple slide-in/out unit which can be used with or without Composer.</p>
<h3>In summary</h3>
<p>This tutorial should get you started with implementing basic sliding panels in your app. With some clever adjustments to the various parameters, you can easily implement a wide variety of panels that appear from different sides of the screen and utilize unique easing transitions.</p>
<p>To use this widget in your own projects, please download the code from our GitHub <a href=https://github.com/coronalabs/sample-widget-panel target="_blank">repository</a>.</p>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2014/04/08/widgets-creating-a-sliding-panel/feed/</wfw:commentRss>
		<slash:comments>30</slash:comments>
		</item>
		<item>
		<title>Tutorial: Customizing text input</title>
		<link>/blog/2013/12/03/tutorial-customizing-text-input/</link>
		<comments>/blog/2013/12/03/tutorial-customizing-text-input/#comments</comments>
		<pubDate>Tue, 03 Dec 2013 22:33:22 +0000</pubDate>
		<dc:creator><![CDATA[Rob Miracle]]></dc:creator>
				<category><![CDATA[Tutorials, Tips and Demos]]></category>
		<category><![CDATA[native text input]]></category>
		<category><![CDATA[tutorial]]></category>
		<category><![CDATA[ui]]></category>

		<guid isPermaLink="false">http://www.coronalabs.com/?p=53051</guid>
		<description><![CDATA[One commonly requested feature is a "widget-based" text input field — one that allows for more "styling" than a device's native input field. Today's tutorial gives you a foundation to build this.]]></description>
				<content:encoded><![CDATA[<p>One commonly requested feature is a &#8220;widget-based&#8221; text input field and today&#8217;s tutorial gives you a foundation to build your own. This isn&#8217;t a complete implementation, and it only overcomes a few issues related with <a href=http://docs.coronalabs.com/api/library/native/newTextField.html target="_blank">native.newTextField()</a>, but it should provide a good starting point.</p>
<p>Let&#8217;s begin with some basic setup code:</p><pre class="crayon-plain-tag">local myTextField = widget.newTextField(
   {
   top = 10,
   left = 20,
   width = 200,
   height = 30,
   cornerRadius = 8,
   strokeWidth = 3,
   backgroundColor = { 1, 1, 1 },
   strokeColor = { 0, 0, 0 },
   font = &quot;Helvetica&quot;,
   fontSize = 24,
   listener = textFieldHandler
   }
)</pre><p>Naturally, a widget like this could end up with an enormous number of options, but let&#8217;s start by considering some basic options:</p>
<ul>
<li><strong>top</strong> — distance from the top of the screen</li>
<li><strong>left</strong> — distance from the left of the screen</li>
<li><strong>x</strong> — location of the widget horizontally (center)</li>
<li><strong>y</strong> — location of the widget vertically (center)</li>
<li><strong>width</strong> — width of the field</li>
<li><strong>height</strong> — height of the field</li>
<li><strong>font</strong> — Font to use</li>
<li><strong>fontSize</strong> — size of the font</li>
<li><strong>backgroundColor</strong> — the color behind the text</li>
<li><strong>strokeColor</strong> — the color of the stroke around the field</li>
<li><strong>strokeWidth</strong> — the size of the stroke</li>
<li><strong>cornerRadius</strong> — if you want rounded corners</li>
<li><strong>text</strong> — the initial text</li>
<li><strong>inputType</strong> — the type of keyboard to show</li>
<li><strong>listener</strong> — the input handler</li>
</ul>
<p>Obviously this could be extended to include things like the value of the &#8220;return&#8221; button, having placeholder text that disappears when you first start editing the field, and even skinning features. However, since this function is going to use a native text field, we&#8217;ll need to write — at the core — a function to handle editing of the field:</p><pre class="crayon-plain-tag">local function textFieldHandler( event )

   -- &quot;event.text&quot; only exists during the editing phase to show what's being edited; 
   -- it is NOT the field's &quot;.text&quot; attribute (that is &quot;event.target.text&quot;).

   if ( event.phase == &quot;began&quot; ) then
      -- user begins editing textField
      print( &quot;Begin editing&quot;, event.target.text )
   elseif ( event.phase == &quot;ended&quot; or event.phase == &quot;submitted&quot; ) then
      -- do something with defaulField's text
      print( &quot;Final Text: &quot;, event.target.text )
      native.setKeyboardFocus( nil )
   elseif ( event.phase == &quot;editing&quot; ) then
      print( event.newCharacters )
      print( event.oldText )
      print( event.startPosition )
      print( event.text )
   end
end</pre><p>If we want this to be part of the widget library, we simply add it to a module and include the widget library:</p><pre class="crayon-plain-tag">local widget = require( &quot;widget&quot; )
function widget.newTextField( options )
   ...
end</pre><p>This will cause a new function, <code>newTextField()</code>, to be added to the instance of the widget library that has been included in your project. Then, in any scene or module where you require the <a href=https://docs.coronalabs.com/api/library/widget/index.html target="_blank">widget</a> library, the function will be available.</p>
<p>Now let&#8217;s define the default option values:</p><pre class="crayon-plain-tag">function widget.newTextField( options )
   local customOptions = options or {}
   local opt = {}
   opt.left = customOptions.left or 0
   opt.top = customOptions.top or 0
   opt.x = customOptions.x or 0
   opt.y = customOptions.y or 0
   opt.width = customOptions.width or (display.contentWidth * 0.75)
   opt.height = customOptions.height or 20
   opt.id = customOptions.id
   opt.listener = customOptions.listener or nil
   opt.text = customOptions.text or &quot;&quot;
   opt.inputType = customOptions.inputType or &quot;default&quot;
   opt.font = customOptions.font or native.systemFont
   opt.fontSize = customOptions.fontSize or opt.height * 0.67

   -- Vector options
   opt.strokeWidth = customOptions.strokeWidth or 2
   opt.cornerRadius = customOptions.cornerRadius or opt.height * 0.33 or 10
   opt.strokeColor = customOptions.strokeColor or { 0, 0, 0 }
   opt.backgroundColor = customOptions.backgroundColor or { 1, 1, 1 }
   ...</pre><p>The code above may seem a bit confusing, but we&#8217;re simply accepting a parameter to the function called <code>options</code>. The first line creates a table named <code>customOptions</code> which makes sure it&#8217;s a Lua table. If you don&#8217;t pass the <code>options</code> parameter, an empty table is created. After that, we just set each of the individual options to either the passed value or a default value. For this widget, things like the corner radius and the font size should default to values that adapt to the size of the field.</p>
<h3>Creating the visual elements</h3>
<p>In this section, we&#8217;ll create the visual part of our text field widget, including the <strong>native</strong> UI element to pair it with:</p><pre class="crayon-plain-tag">local field = display.newGroup()

local background = display.newRoundedRect( 0, 0, opt.width, opt.height, opt.cornerRadius )
background:setFillColor( unpack(opt.backgroundColor) )
background.strokeWidth = opt.strokeWidth
background.stroke = opt.strokeColor
field:insert( background )

if ( opt.x ) then
   field.x = opt.x
elseif ( opt.left ) then
   field.x = opt.left + opt.width * 0.5
end
if ( opt.y ) then
   field.y = opt.y
elseif ( opt.top ) then
   field.y = opt.top + opt.height * 0.5
end

-- Native UI element
local tHeight = opt.height - opt.strokeWidth * 2
if &quot;Android&quot; == system.getInfo(&quot;platformName&quot;) then
    --
    -- Older Android devices have extra &quot;chrome&quot; that needs to be compesnated for.
    --
    tHeight = tHeight + 10
end

field.textField = native.newTextField( 0, 0, opt.width - opt.cornerRadius, tHeight )
field.textField.x = field.x
field.textField.y = field.y
field.textField.hasBackground = false
field.textField.inputType = opt.inputType
field.textField.text = opt.text
print( opt.listener, type(opt.listener) )
if ( opt.listener and type(opt.listener) == &quot;function&quot; ) then
   field.textField:addEventListener( &quot;userInput&quot;, opt.listener )
end

local deviceScale = ( display.pixelWidth / display.contentWidth ) * 0.5

field.textField.font = native.newFont( opt.font )
field.textField.size = opt.fontSize * deviceScale</pre><p>Here are a few points to consider as you inspect this code:</p>
<ul>
<li>If you round the corners, don&#8217;t let the actual text field extend into the corners.</li>
<li>Remember to hide the native text field background so that your custom visuals show up.</li>
<li><a href=https://docs.coronalabs.com/api/library/native/newTextField.html>native.newTextField()</a> needs the font string name converted to a <a href=https://docs.coronalabs.com/api/library/native/newFont.html target="_blank">native.newFont()</a>. However, the size is a bit tricky because native text fields do not automatically scale. Thus, we must calculate the device&#8217;s real scale factor and then multiply the desired font size by that scale factor.</li>
</ul>
<h3>Removing the elements</h3>
<p>We need to make sure that when the widget gets removed, the native text field gets removed as well. Previously, we would need to override the <a href=https://docs.coronalabs.com/api/type/DisplayObject/removeSelf.html target="_blank">removeSelf()</a> function with our own function that would eventually call the original <a href=https://docs.coronalabs.com/api/type/DisplayObject/removeSelf.html target="_blank">removeSelf()</a>. However, the new <a href=http://docs.coronalabs.com/api/event/finalize/index.html target="_blank">finalize</a> event makes this process easier. This allows us to set up a function that&#8217;s executed <em>just before the display object is removed from the stage</em>, in case there are related cleanup tasks we need to handle — in this case, removing the native text field just before our custom text field group is removed.</p><pre class="crayon-plain-tag">function field:finalize( event )
   event.target.textField:removeSelf()
end
field:addEventListener( &quot;finalize&quot; ) 

return field</pre><p></p>
<h3>Using the custom text field</h3>
<p>Using our new &#8220;widget&#8221; text field is simple. To place it on screen, our code may look like this:</p><pre class="crayon-plain-tag">local myTextField = widget.newTextField(
   {
   width = 250,
   height = 30,
   text = &quot;Hello World!&quot;,
   fontSize = 18,
   font = &quot;HelveticaNeue-Light&quot;,
   listener = textFieldHandler
   }
)

myTextField.x = display.contentCenterX
myTextField.y = 100</pre><p></p>
<h4>Retrieve the value of the text field</h4>
<p></p><pre class="crayon-plain-tag">local myText = myTextField.textField.text</pre><p></p>
<h4>Set the value of the text field</h4>
<p></p><pre class="crayon-plain-tag">myTextField.textField.text = &quot;Edited Value&quot;</pre><p></p>
<h3>In summary</h3>
<p>This tutorial should get you started with implementing &#8220;styled&#8221; text input fields and, hopefully, extending them to more complex use cases.</p>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2013/12/03/tutorial-customizing-text-input/feed/</wfw:commentRss>
		<slash:comments>19</slash:comments>
		</item>
	</channel>
</rss>
