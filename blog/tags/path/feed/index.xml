<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>path &#8211; Corona Labs</title>
	<atom:link href="/blog/tags/path/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description></description>
	<lastBuildDate>Mon, 19 Oct 2020 12:16:12 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.8</generator>

<image>
	<url>/wordpress/wp-content/uploads/2017/06/cropped-icon_32x32@2x-32x32.png</url>
	<title>path &#8211; Corona Labs</title>
	<link>/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Tutorial: Working with curved paths</title>
		<link>/blog/2014/09/09/tutorial-working-with-curved-paths/</link>
		<comments>/blog/2014/09/09/tutorial-working-with-curved-paths/#comments</comments>
		<pubDate>Tue, 09 Sep 2014 22:41:56 +0000</pubDate>
		<dc:creator><![CDATA[Brent Sorrentino]]></dc:creator>
				<category><![CDATA[Tutorials, Tips and Demos]]></category>
		<category><![CDATA[bezier]]></category>
		<category><![CDATA[curve]]></category>
		<category><![CDATA[path]]></category>
		<category><![CDATA[tutorial]]></category>

		<guid isPermaLink="false">/?p=59494</guid>
		<description><![CDATA[If you want to move an object from point A to point B, the simplest approach is to use a transition, but what if you need to move it along a curved path generated by a bezier algorithm or the user's "drawn" path on the screen? This tutorial outlines how to achieve both methods and set an object to follow the resulting path.]]></description>
				<content:encoded><![CDATA[<p>Since the previous tutorial on <a href=/blog/2014/01/07/tutorial-moving-objects-along-a-path/ target="_blank">moving objects along a path</a>, we&#8217;ve received many requests for a tutorial that deals with <strong>curved</strong> paths, either generated via a bezier curve algorithm or &#8220;drawn&#8221; by the user&#8217;s touch on the screen. Today&#8217;s tutorial will cover both methods, including sample projects for download. In addition, we&#8217;ll walk through a basic module that makes an object follow the curved path.</p>
<h3>Bezier method</h3>
<p><img class="alignright wp-image-59499 size-medium" style="margin: 2px 1px 20px 30px;" src="/wordpress/wp-content/uploads/2014/09/bezier-300x195.png" alt="bezier" width="300" height="195" /></p>
<p>The first sample project, available for <a href=https://www.dropbox.com/s/nbi4scf79on8kkd/CurveDrawing.zip?dl=0 target="_blank">download</a>, lets the user touch one point on the screen to set the <strong>starting</strong> point of the curve, then the user may drag outward to create a &#8220;handle&#8221; that will adjust the curve. Next, the user may touch a second point to indicate the <strong>ending</strong> point of the curve and likewise drag outward to adjust the handle. For anybody who has worked with paths in an image/vector editing program like Photoshop or Illustrator, this process will be very familiar.</p>
<p>Dissecting the entire sample project is beyond the scope of this tutorial, but a few elements near the top of the code are important to understand:</p><pre class="crayon-plain-tag">local curve</pre><p>This is simply an up-value reference to what will become, during manipulation of the anchors and handles, the display object (<a href=http://docs.coronalabs.com/api/library/display/newLine.html target="_blank">display.newLine()</a>) for the generated curve. Instead of creating a separate object for each segment in the curve, we&#8217;ll use the convenient <a href=http://docs.coronalabs.com/api/type/LineObject/append.html target="_blank">append()</a> function to add segments to a core line object.</p><pre class="crayon-plain-tag">local pathPoints = {}</pre><p>This table will contain an ordered series of sub-tables, each of which will contain the <code>x</code> and <code>y</code> position of a point along the curve. The structure of each sub-table is very simple, for example: <code>{ x=10, y=24 }</code>. These points will also be passed to the <code>follow.lua</code> module that places an object at the starting point and transitions it from point to point &#8212; this will be discussed further down.</p><pre class="crayon-plain-tag">local curveSegments = 100</pre><p>This variable is important to mention since it allows us to easily adjust the &#8220;smoothness&#8221; of the curve. More specifically, this value represents the total number of segments which will constitute the curve, and thus, higher values will yield a smoother curve. The default is <code>100</code> which should be sufficient for most scenarios.</p><pre class="crayon-plain-tag">local followParams = { segmentTime=50, constantRate=true, showPoints=true }</pre><p>This table is also passed to the <code>follow.lua</code> module and it allows us to adjust the behavior of the routine via the following key-value pairs:</p>
<ul>
<li><code>segmentTime</code> &#8212; The time of the transition between each point along the curve.</li>
<li><code>constantRate</code> &#8212; Because the distance between points will vary, this sets the rate of movement to be more constant by using the length of the first segment as a basis and then adjusting the transition time of subsequent segments accordingly.</li>
<li><code>showPoints</code> &#8212; If <code>true</code>, this will place a dot along each point in the curve.</li>
</ul>
<h3>Drawing method</h3>
<p><img class="alignright wp-image-59506 size-medium" style="margin: 2px 1px 20px 30px;" src="/wordpress/wp-content/uploads/2014/09/path-300x195.png" alt="path" width="300" height="195" />For generating a more &#8220;organic&#8221; path, we can use a path drawing module, also available for <a href=https://www.dropbox.com/s/z746t25j1e627q2/PathDrawing.zip?dl=0 target="_blank">download</a>. This method simply lets the user draw a path of any length by touching and dragging around the screen.</p>
<p>As above, dissecting the entire project is beyond the scope of this tutorial, but a few elements should be explained:</p><pre class="crayon-plain-tag">local path</pre><p>Similar to the bezier method, this is simply an up-value reference to what will become, as the user begins drawing, the display object for the path.</p><pre class="crayon-plain-tag">local pathPoints = {}</pre><p>This table serves the same purpose as in the bezier module. It will contain an ordered series of sub-tables, each of which will contain the <code>x</code> and <code>y</code> position of a point along the curve.</p><pre class="crayon-plain-tag">local pathPrecision = 20</pre><p>This value represents the <strong>minimum</strong> distance between any two points along the path. This is especially important because, in the <code>"moved"</code> phase of a touch event, the user&#8217;s touch will be registered at very small increments and, if we created a path point on each increment, the <code>pathPoints</code> table would potentially be populated by hundreds or even thousands of coordinate sub-tables. That would result in an extremely &#8220;smooth&#8221; curve, but it&#8217;s more detail than necessary in most cases. Thus, the drawing routine will only register a new coordinate point if the distance from the previous point is greater than or equal to <code>pathPrecision</code>.</p><pre class="crayon-plain-tag">local followParams = { segmentTime=50, constantRate=true, showPoints=true }</pre><p>This table is serves the same purpose as in the bezier example, where <code>segmentTime</code> sets the transition time between points on the path, <code>constantRate</code> makes the movement speed more even, and <code>showPoints</code> plots the points along the path.</p>
<h3>Object following the curve/path</h3>
<p>For this tutorial, our <code>follow.lua</code> module uses basic <a href=http://docs.coronalabs.com/api/library/transition/index.html target="_blank">transitions</a> to move an object from point to point along the path. In addition, it uses a basic <code>angleBetween()</code> function to make the object face toward the next point as it moves along the path:</p><pre class="crayon-plain-tag">local function angleBetween( srcX, srcY, dstX, dstY )
   local angle = ( math.deg( math.atan2( dstY-srcY, dstX-srcX ) )+90 )
   return angle % 360
end</pre><p></p>
<h4>init() function</h4>
<p>The <code>follow.lua</code> module is initially set up via the <code>init()</code> function which is called from either of the demo projects outlined above. First, this function creates a polygon display object, places it at the <code>x</code> and <code>y</code> location of the path starting point (passed in as the <code>startPoint</code> argument), and sets its rotation to face the second point:</p><pre class="crayon-plain-tag">function M.init( params, pathPoints, pathPrecision, startPoint )

   local follower = display.newPolygon( 0, 0, { 0,-28, 30,28, 0,20, -30,28 } )
   follower:setFillColor( 1 )
   follower.x = startPoint.x
   follower.y = startPoint.y

   follower.rotation = angleBetween( pathPoints[1].x, pathPoints[1].y, pathPoints[2].x, pathPoints[2].y )</pre><p>A few lines after, we set a local variable <code>precision</code> with a default value equal to the <code>pathPrecision</code> argument. This is intended for compatibility between both the bezier example and the drawing example. In the bezier example, this argument can simply be passed in as a value of <code>0</code> because, in that module, there is no explicit set value for the distance between path points &#8212; instead, the algorithm creates the bezier based on a total number of segments. As a result, we must calculate a <code>precision</code> value based on the distance between the starting point and the second point, as indicated on line 75.</p><pre class="crayon-plain-tag">local precision = pathPrecision
   if ( pathPrecision == 0 ) then
      precision = distBetween( pathPoints[1].x, pathPoints[1].y, pathPoints[2].x, pathPoints[2].y )
   end</pre><p>Next, we check if the <code>showPoints</code> parameter is true, we generate a dot along each point in the path by looping through the <code>pathPoints</code> table. Each point is added to a display group, <code>pathPointsGroup</code>, for easier cleanup when the curve is re-drawn.</p><pre class="crayon-plain-tag">if ( params.showPoints == true ) then
      local pathPointsGroup = display.newGroup() ; pathPointsGroup:toBack()
      for p = 1,#pathPoints do
         local dot = display.newCircle( pathPointsGroup, 0, 0, 8 )
         dot:setFillColor( 1, 1, 1, 0.4 )
         dot.x = pathPoints[p].x
         dot.y = pathPoints[p].y
      end
      M.ppg = pathPointsGroup
   end</pre><p>Finally, we call the <code>follow()</code> function and pass some core arguments to it:</p><pre class="crayon-plain-tag">follow( params, follower, pathPoints, precision )</pre><p></p>
<h4>Follow function</h4>
<p>The <code>follow()</code> function essentially performs some calculations and begins a series of <a href=http://docs.coronalabs.com/api/library/transition/index.html target="_blank">transitions</a> where each subsequent transition is queued by the completion of the previous transition. The calculations include an adjustment of the transition time if the <code>constantRate</code> boolean is <code>true</code>.</p><pre class="crayon-plain-tag">local transTime = params.segmentTime
         --if &quot;params.constantRate&quot; is true, adjust time according to segment distance
         if ( params.constantRate == true ) then
            local dist = distBetween( obj.x, obj.y, pathPoints[obj.nextPoint].x, pathPoints[obj.nextPoint].y )
            transTime = (dist/pathPrecision) * params.segmentTime
         end</pre><p>Additionally, we rotate the object to face the next point using the <code>angleBetween()</code> function:</p><pre class="crayon-plain-tag">--rotate object to face next point
         if ( obj.nextPoint &lt; #pathPoints ) then
            obj.rotation = angleBetween( obj.x, obj.y, pathPoints[obj.nextPoint].x, pathPoints[obj.nextPoint].y )
         end</pre><p>For the actual transition, we simply pass in some core parameters including the <code>transTime</code> calculated above and the <code>x</code> and <code>y</code> destination point. Additionally, we tag the transition with <code>"moveObject"</code> so it can easily be paused, resumed, or canceled, and we set the <code>onComplete</code> function to <code>nextTransition</code> so the process repeats until the object reaches the ending point. Finally, as each iteration occurs, we increment <code>obj.nextPoint</code> so the next transition moves to the next point along the path.</p><pre class="crayon-plain-tag">transition.to( obj, {
            tag = &quot;moveObject&quot;,
            time = transTime,
            x = pathPoints[obj.nextPoint].x,
            y = pathPoints[obj.nextPoint].y,
            onComplete = nextTransition
         })
         obj.nextPoint = obj.nextPoint+1</pre><p></p>
<h4>Pausing, resuming, canceling</h4>
<p>Because we tag each transition in the sequence with <code>"moveObject"</code>, pausing, resuming, or canceling is simple — just pass the tag name to one of the transition control APIs:</p><pre class="crayon-plain-tag">--pause the sequence
transition.pause( &quot;moveObject&quot; )
--some time later, resume it
transition.resume( &quot;moveObject&quot; )
--all finished... cancel it!
transition.cancel( &quot;moveObject&quot; )</pre><p></p>
<h3>In summary</h3>
<p>Hopefully this tutorial gets you started on curve-based path movement in Corona. Remember to download and carefully inspect the sample code used in this tutorial:</p>
<ul>
<li><a href=https://www.dropbox.com/s/nbi4scf79on8kkd/CurveDrawing.zip?dl=0 target="_blank">CurveDrawing.zip</a> — bezier module</li>
<li><a href=https://www.dropbox.com/s/z746t25j1e627q2/PathDrawing.zip?dl=0 target="_blank">PathDrawing.zip</a> — drawing module</li>
</ul>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2014/09/09/tutorial-working-with-curved-paths/feed/</wfw:commentRss>
		<slash:comments>7</slash:comments>
		</item>
		<item>
		<title>Tutorial: Moving objects along a path</title>
		<link>/blog/2014/01/07/tutorial-moving-objects-along-a-path/</link>
		<comments>/blog/2014/01/07/tutorial-moving-objects-along-a-path/#comments</comments>
		<pubDate>Tue, 07 Jan 2014 21:31:50 +0000</pubDate>
		<dc:creator><![CDATA[Brent Sorrentino]]></dc:creator>
				<category><![CDATA[Tutorials, Tips and Demos]]></category>
		<category><![CDATA[path]]></category>
		<category><![CDATA[transition]]></category>
		<category><![CDATA[tutorial]]></category>

		<guid isPermaLink="false">/?p=55020</guid>
		<description><![CDATA[There are many ways to move objects in Corona SDK. If you want to move an object from point A to point B, the simplest approach is to use a transition. But what if you need to move it along a path with multiple segments, like moving a knight on a chess board in its unique "L" pattern? This tutorial outlines how to achieve sequential movement via a series of queued transitions.]]></description>
				<content:encoded><![CDATA[<p>There are many ways to move objects in Corona SDK. If you want to move an object from point A to B, the simplest approach is to use <a href=http://docs.coronalabs.com/api/library/transition/to.html target="_blank">transition.to()</a>. But what if you need to move it along a path with multiple segments, like moving a knight on a chess board in its unique &#8220;<strong>L</strong>&#8221; pattern? This tutorial outlines how to achieve sequential movement via a series of <strong>queued</strong> transitions.</p>
<h3>Initial setup</h3>
<p>The basis of this process is a table of <code>x</code> and <code>y</code> coordinate pairs to move the object along, in sequence. In its most simple format, the table may look like this:</p><pre class="crayon-plain-tag">local movePath = {}
movePath[1] = { x=200, y=0 }
movePath[2] = { x=200, y=200 }
movePath[3] = { x=0, y=200 }
movePath[4] = { x=200, y=300 }
movePath[5] = { x=150, y=200 }
movePath[6] = { x=200, y=100 }
movePath[7] = { x=100, y=200 }
movePath[8] = { x=0, y=0 }</pre><p>This just declares a series of movement points, starting at index 1 and progressing across as many points as you wish. By default, these points equate to specific coordinates on the screen, <strong>not</strong> points relative to the object&#8217;s starting position, but we&#8217;ll include a setting to let you choose which option is most suitable to your application.</p>
<h4>Customizing the path parameters</h4>
<p>In addition to the basic <code>x</code> and <code>y</code> coordinate setup, we&#8217;ll allow two additional parameters for each &#8220;segment&#8221; in the path: <code>time</code> and <code>easingMethod</code>. For example, we may expand our table like this:</p><pre class="crayon-plain-tag">local movePath = {}
movePath[1] = { x=200, y=0 }
movePath[2] = { x=200, y=200 }
movePath[3] = { x=0, y=200, time=500 }
movePath[4] = { x=200, y=300, time=500 }
movePath[5] = { x=150, y=200, time=250, easingMethod=easing.inOutExpo }
movePath[6] = { x=200, y=100, time=2000 }
movePath[7] = { x=100, y=200, time=500 }
movePath[8] = { x=0, y=0, time=500, easingMethod=easing.outQuad }</pre><p>If a custom <code>time</code> parameter is specified, it will override any other time settings, and the object will move to that point over that exact duration. Similarly, if <code>easingMethod</code> is defined and set to one of Corona&#8217;s <a href=http://docs.coronalabs.com/api/library/easing/index.html target="_blank">easing</a> methods, the object will move to that point using that easing method, not the default linear interpolation.</p>
<h4>Distance function</h4>
<p>For calculating the distance between two points, we&#8217;ll need to include a quick function. The purpose of this will be explained later, but let&#8217;s add it now:</p><pre class="crayon-plain-tag">local function distBetween( x1, y1, x2, y2 )
   local xFactor = x2 - x1
   local yFactor = y2 - y1
   local dist = math.sqrt( (xFactor*xFactor) + (yFactor*yFactor) )
   return dist
end</pre><p></p>
<h4>Create the object(s)</h4>
<p>Obviously, we&#8217;ll need one or more objects to move along the path we created. Let&#8217;s create two basic circles now:</p><pre class="crayon-plain-tag">local circle1 = display.newCircle( 60, 100, 15 )
circle1:setFillColor( 1, 0, 0.4 )
local circle2 = display.newCircle( 120, 100, 15 )
circle2:setFillColor( 1, 0.8, 0.4 )</pre><p></p>
<h3>The setPath() function</h3>
<p>Now that we&#8217;ve done the basic setup, let&#8217;s explore the function which will queue up all of the transitions for an object. Let&#8217;s call the function <code>setPath()</code> and provide it with three arguments: the <code>object</code> to move, the <code>path</code> to move along, and a table of <code>params</code> which we can use to customize the movement.</p><pre class="crayon-plain-tag">local function setPath( object, path, params )

   local delta = params.useDelta or nil
   local deltaX = 0
   local deltaY = 0
   local constant = params.constantTime or nil
   local ease = params.easingMethod or easing.linear
   local tag = params.tag or nil
   local delay = params.delay or 0
   local speedFactor = 1</pre><p>In the first several lines of the function, we set some local variables, most of which are used to check if various parameters are passed in via the <code>params</code> table. Each of these parameters will be explained as we step through the tutorial.</p>
<h4>Delta</h4>
<p>This gives us the option to use <strong>delta</strong> position via a boolean value — <code>useDelta</code> — passed in via the <code>params</code> table. If set to <code>true</code>, the object&#8217;s path will be relative to its starting position. If set to <code>false</code>, or omitted, the path points will equate to explicit screen coordinates instead.</p>
<p>Whether to use <code>params.useDelta = true</code> depends on the scenario. For moving a knight on a chess board, delta would be the logical choice, since the knight may reside on any square of the board and we&#8217;d need to move it in its &#8220;<strong>L</strong>&#8221; pattern from the current square to another valid square.</p>
<p>If <code>useDelta</code> is passed in the <code>params</code> table, let&#8217;s set <code>deltaX</code> and <code>deltaY</code> to the object&#8217;s starting position, instead of their default of <code>0</code>. When the transitions are set up, this will be used to offset each point along the path by the object&#8217;s starting position. It will also be used to refactor the constant rate of movement, discussed in a moment.</p><pre class="crayon-plain-tag">if ( delta ) then
      deltaX = object.x
      deltaY = object.y
   end</pre><p></p>
<h4>Constant rate of movement</h4>
<p>Another option we&#8217;ll add is the ability to set a &#8220;constant rate of movement.&#8221; For example, we may wish to move the object at a steady, constant rate across the entire path, even if the distance between the starting point and the 2nd point is 100 pixels but the distance between the 2nd and 3rd point is 280 pixels. To accomplish this, we just need to calculate a speed factor based on a &#8220;time&#8221; value passed in via <code>params.constantTime</code>.</p><pre class="crayon-plain-tag">if ( constant ) then
      local dist = distBetween( object.x, object.y, deltaX+path[1].x, deltaY+path[1].y )
      speedFactor = constant/dist
   end</pre><p>The value that should be passed to <code>params.constantTime</code> is simply an integer &#8220;time&#8221; value, and <code>speedFactor</code> is calculated by the <strong>distance between the starting point and the 2nd point</strong>. In other words, if we use a value of 1200, the object will move from the starting point to the 2nd point in 1200 milliseconds, and the speed established along that segment will be applied to all other segments in the path, no matter their distance apart.</p>
<h4>Default easing method</h4>
<p>If we wish to use a non-linear easing method for all segments in the path, we can tell the module to use any of the <a href=http://docs.coronalabs.com/api/library/easing/index.html target="_blank">easing</a> methods. For example, to use a <strong>quadratic-in-out</strong> method, we can pass <code>easingMethod = easing.inOutQuad</code> in the <code>params</code> table. This easing method will be applied to all transitions along the path <strong>except</strong> those with a specific <code>easingMethod</code> setting in the path table.</p>
<h4>Transition tagging</h4>
<p>One of the features in the <a href=http://docs.coronalabs.com/api/library/transition/index.html target="_blank">transition</a> library is the ability to tag (name) any number of transitions and then <a href=http://docs.coronalabs.com/api/library/transition/cancel.html target="_blank">cancel</a>, <a href=http://docs.coronalabs.com/api/library/transition/pause.html target="_blank">pause</a>, or <a href=http://docs.coronalabs.com/api/library/transition/resume.html target="_blank">resume</a> all transitions sharing the same tag. Since we&#8217;ll be building paths that consist of multiple related transitions, tagging is essential if you want to pause or resume the path movement as it progresses from point to point. To tag all of the transitions that will collectively make up the path, just pass the <code>tag</code> parameter (string value) in the <code>params</code> table.</p>
<h4>Looping through the points</h4>
<p>Now, let&#8217;s loop through our points and set up the queue of transitions. For simplicity, we&#8217;ll declare all of them initially and apply a <code>delay</code> parameter on each, so each transition starts when the previous one is finished.</p>
<p>First, we&#8217;ll start our loop and immediately set a default <code>segmentTime</code> of 500 milliseconds. Then, we&#8217;ll check if <code>params.constantTime</code> has been supplied and, if so, we&#8217;ll overwrite <code>segmentTime</code> with a refactored time — specifically, the distance between the points multiplied by the <code>speedFactor</code> that we calculated above:</p><pre class="crayon-plain-tag">for i = 1,#path do

      local segmentTime = 500

      --if &quot;constant&quot; is defined, refactor transition time based on distance between points
      if ( constant ) then
         local dist
         if ( i == 1 ) then
            dist = distBetween( object.x, object.y, deltaX+path[i].x, deltaY+path[i].y )
         else
            dist = distBetween( path[i-1].x, path[i-1].y, path[i].x, path[i].y )
         end
         segmentTime = dist*speedFactor</pre><p>As mentioned above, we can optionally set a custom <strong>time</strong> on any specific segment in the path. If supplied, this value will override both the default of 500 milliseconds <strong>and</strong> the &#8220;constant rate&#8221; value, if it&#8217;s being used. Let&#8217;s check if a custom time has been specified for this segment:</p><pre class="crayon-plain-tag">else
         --if this path segment has a custom time, use it
         if ( path[i].time ) then segmentTime = path[i].time end
      end</pre><p>In addition, let&#8217;s check if a custom <code>easingMethod</code> parameter has been set on this specific path segment. If declared, this will override the optional <strong>default</strong> easing method applied to the path as a whole.</p><pre class="crayon-plain-tag">--if this segment has custom easing, override the default method (if any)
      if ( path[i].easingMethod ) then ease = path[i].easingMethod end</pre><p>And finally, the heart of the entire process — creating each transition for the path:</p><pre class="crayon-plain-tag">transition.to( object, { tag=tag, time=segmentTime, x=deltaX+path[i].x, y=deltaY+path[i].y, delay=delay, transition=ease } )
      delay = delay + segmentTime
   end
end</pre><p>Notice that the parameters table for each actual transition is populated based on the values we gathered or calculated in the lines above. Also, note line #66 — here, we add to the total <code>delay</code> value for each new transition in sequence, thus making each transition begin when the previous one has completed.</p>
<h3>Setting an object in motion</h3>
<p>Let&#8217;s start our circles in motion across the path! At the most basic level, the <code>setPath()</code> function may be called like this:</p><pre class="crayon-plain-tag">setPath( circle1, movePath, { tag=&quot;moveObject&quot; } )
setPath( circle2, movePath, { tag=&quot;moveObject&quot; } )</pre><p>However, this doesn&#8217;t include any options like <code>useDelta</code> or <code>constantTime</code>, so let&#8217;s expand on it:</p><pre class="crayon-plain-tag">setPath( circle1, movePath, { useDelta=true, constantTime=1200, easingMethod=easing.inOutQuad, delay=200, tag=&quot;moveObject&quot; } )
setPath( circle2, movePath, { useDelta=true, constantTime=1200, easingMethod=easing.inOutQuad, tag=&quot;moveObject&quot; } )</pre><p>And that&#8217;s it — the circles will both follow the same path, <code>movePath</code>, and the path will be offset by each object&#8217;s starting position because we used the delta setting. The rate of movement across each segment will be constant, and an in-out quadratic easing will be applied to all segments.</p>
<h4>Pausing, resuming, canceling</h4>
<p>Because we tagged every transition in the sequence with the <code>"moveObject"</code> tag, pausing, resuming, or canceling is simple — just pass the tag name to one of the transition control APIs:</p><pre class="crayon-plain-tag">--pause the sequence
transition.pause( &quot;moveObject&quot; )
--some time later, resume it
transition.resume( &quot;moveObject&quot; )
--all finished... cancel it!
transition.cancel( &quot;moveObject&quot; )</pre><p></p>
<h3>In summary</h3>
<p>Hopefully this tutorial gets you started on path-based movement in Corona. In closing, note the following:</p>
<ul>
<li>The functional format allows you to create and re-use several unique path &#8220;patterns&#8221; and apply them to various objects by simply passing the appropriate path table to the <code>setPath()</code> function, along with the object and the optional parameters. In this manner, you could, for example, create several different movement paths for pieces in a board game and re-use those paths as needed depending on the player&#8217;s move.</li>
<li>This tutorial outlines just <strong>linear</strong> path-based movement. If you need <strong>curved-based</strong> path methods, please refer to the <a href=/blog/2014/09/09/tutorial-working-with-curved-paths/ target="_blank">working with curved paths</a> tutorial.</li>
</ul>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2014/01/07/tutorial-moving-objects-along-a-path/feed/</wfw:commentRss>
		<slash:comments>28</slash:comments>
		</item>
	</channel>
</rss>
