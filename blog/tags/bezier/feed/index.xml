<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>bezier &#8211; Corona Labs</title>
	<atom:link href="/blog/tags/bezier/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description></description>
	<lastBuildDate>Mon, 19 Oct 2020 12:16:12 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.8</generator>

<image>
	<url>/wordpress/wp-content/uploads/2017/06/cropped-icon_32x32@2x-32x32.png</url>
	<title>bezier &#8211; Corona Labs</title>
	<link>/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Tutorial: Working with curved paths</title>
		<link>/blog/2014/09/09/tutorial-working-with-curved-paths/</link>
		<comments>/blog/2014/09/09/tutorial-working-with-curved-paths/#comments</comments>
		<pubDate>Tue, 09 Sep 2014 22:41:56 +0000</pubDate>
		<dc:creator><![CDATA[Brent Sorrentino]]></dc:creator>
				<category><![CDATA[Tutorials, Tips and Demos]]></category>
		<category><![CDATA[bezier]]></category>
		<category><![CDATA[curve]]></category>
		<category><![CDATA[path]]></category>
		<category><![CDATA[tutorial]]></category>

		<guid isPermaLink="false">/?p=59494</guid>
		<description><![CDATA[If you want to move an object from point A to point B, the simplest approach is to use a transition, but what if you need to move it along a curved path generated by a bezier algorithm or the user's "drawn" path on the screen? This tutorial outlines how to achieve both methods and set an object to follow the resulting path.]]></description>
				<content:encoded><![CDATA[<p>Since the previous tutorial on <a href=/blog/2014/01/07/tutorial-moving-objects-along-a-path/ target="_blank">moving objects along a path</a>, we&#8217;ve received many requests for a tutorial that deals with <strong>curved</strong> paths, either generated via a bezier curve algorithm or &#8220;drawn&#8221; by the user&#8217;s touch on the screen. Today&#8217;s tutorial will cover both methods, including sample projects for download. In addition, we&#8217;ll walk through a basic module that makes an object follow the curved path.</p>
<h3>Bezier method</h3>
<p><img class="alignright wp-image-59499 size-medium" style="margin: 2px 1px 20px 30px;" src="/wordpress/wp-content/uploads/2014/09/bezier-300x195.png" alt="bezier" width="300" height="195" /></p>
<p>The first sample project, available for <a href=https://www.dropbox.com/s/nbi4scf79on8kkd/CurveDrawing.zip?dl=0 target="_blank">download</a>, lets the user touch one point on the screen to set the <strong>starting</strong> point of the curve, then the user may drag outward to create a &#8220;handle&#8221; that will adjust the curve. Next, the user may touch a second point to indicate the <strong>ending</strong> point of the curve and likewise drag outward to adjust the handle. For anybody who has worked with paths in an image/vector editing program like Photoshop or Illustrator, this process will be very familiar.</p>
<p>Dissecting the entire sample project is beyond the scope of this tutorial, but a few elements near the top of the code are important to understand:</p><pre class="crayon-plain-tag">local curve</pre><p>This is simply an up-value reference to what will become, during manipulation of the anchors and handles, the display object (<a href=http://docs.coronalabs.com/api/library/display/newLine.html target="_blank">display.newLine()</a>) for the generated curve. Instead of creating a separate object for each segment in the curve, we&#8217;ll use the convenient <a href=http://docs.coronalabs.com/api/type/LineObject/append.html target="_blank">append()</a> function to add segments to a core line object.</p><pre class="crayon-plain-tag">local pathPoints = {}</pre><p>This table will contain an ordered series of sub-tables, each of which will contain the <code>x</code> and <code>y</code> position of a point along the curve. The structure of each sub-table is very simple, for example: <code>{ x=10, y=24 }</code>. These points will also be passed to the <code>follow.lua</code> module that places an object at the starting point and transitions it from point to point &#8212; this will be discussed further down.</p><pre class="crayon-plain-tag">local curveSegments = 100</pre><p>This variable is important to mention since it allows us to easily adjust the &#8220;smoothness&#8221; of the curve. More specifically, this value represents the total number of segments which will constitute the curve, and thus, higher values will yield a smoother curve. The default is <code>100</code> which should be sufficient for most scenarios.</p><pre class="crayon-plain-tag">local followParams = { segmentTime=50, constantRate=true, showPoints=true }</pre><p>This table is also passed to the <code>follow.lua</code> module and it allows us to adjust the behavior of the routine via the following key-value pairs:</p>
<ul>
<li><code>segmentTime</code> &#8212; The time of the transition between each point along the curve.</li>
<li><code>constantRate</code> &#8212; Because the distance between points will vary, this sets the rate of movement to be more constant by using the length of the first segment as a basis and then adjusting the transition time of subsequent segments accordingly.</li>
<li><code>showPoints</code> &#8212; If <code>true</code>, this will place a dot along each point in the curve.</li>
</ul>
<h3>Drawing method</h3>
<p><img class="alignright wp-image-59506 size-medium" style="margin: 2px 1px 20px 30px;" src="/wordpress/wp-content/uploads/2014/09/path-300x195.png" alt="path" width="300" height="195" />For generating a more &#8220;organic&#8221; path, we can use a path drawing module, also available for <a href=https://www.dropbox.com/s/z746t25j1e627q2/PathDrawing.zip?dl=0 target="_blank">download</a>. This method simply lets the user draw a path of any length by touching and dragging around the screen.</p>
<p>As above, dissecting the entire project is beyond the scope of this tutorial, but a few elements should be explained:</p><pre class="crayon-plain-tag">local path</pre><p>Similar to the bezier method, this is simply an up-value reference to what will become, as the user begins drawing, the display object for the path.</p><pre class="crayon-plain-tag">local pathPoints = {}</pre><p>This table serves the same purpose as in the bezier module. It will contain an ordered series of sub-tables, each of which will contain the <code>x</code> and <code>y</code> position of a point along the curve.</p><pre class="crayon-plain-tag">local pathPrecision = 20</pre><p>This value represents the <strong>minimum</strong> distance between any two points along the path. This is especially important because, in the <code>"moved"</code> phase of a touch event, the user&#8217;s touch will be registered at very small increments and, if we created a path point on each increment, the <code>pathPoints</code> table would potentially be populated by hundreds or even thousands of coordinate sub-tables. That would result in an extremely &#8220;smooth&#8221; curve, but it&#8217;s more detail than necessary in most cases. Thus, the drawing routine will only register a new coordinate point if the distance from the previous point is greater than or equal to <code>pathPrecision</code>.</p><pre class="crayon-plain-tag">local followParams = { segmentTime=50, constantRate=true, showPoints=true }</pre><p>This table is serves the same purpose as in the bezier example, where <code>segmentTime</code> sets the transition time between points on the path, <code>constantRate</code> makes the movement speed more even, and <code>showPoints</code> plots the points along the path.</p>
<h3>Object following the curve/path</h3>
<p>For this tutorial, our <code>follow.lua</code> module uses basic <a href=http://docs.coronalabs.com/api/library/transition/index.html target="_blank">transitions</a> to move an object from point to point along the path. In addition, it uses a basic <code>angleBetween()</code> function to make the object face toward the next point as it moves along the path:</p><pre class="crayon-plain-tag">local function angleBetween( srcX, srcY, dstX, dstY )
   local angle = ( math.deg( math.atan2( dstY-srcY, dstX-srcX ) )+90 )
   return angle % 360
end</pre><p></p>
<h4>init() function</h4>
<p>The <code>follow.lua</code> module is initially set up via the <code>init()</code> function which is called from either of the demo projects outlined above. First, this function creates a polygon display object, places it at the <code>x</code> and <code>y</code> location of the path starting point (passed in as the <code>startPoint</code> argument), and sets its rotation to face the second point:</p><pre class="crayon-plain-tag">function M.init( params, pathPoints, pathPrecision, startPoint )

   local follower = display.newPolygon( 0, 0, { 0,-28, 30,28, 0,20, -30,28 } )
   follower:setFillColor( 1 )
   follower.x = startPoint.x
   follower.y = startPoint.y

   follower.rotation = angleBetween( pathPoints[1].x, pathPoints[1].y, pathPoints[2].x, pathPoints[2].y )</pre><p>A few lines after, we set a local variable <code>precision</code> with a default value equal to the <code>pathPrecision</code> argument. This is intended for compatibility between both the bezier example and the drawing example. In the bezier example, this argument can simply be passed in as a value of <code>0</code> because, in that module, there is no explicit set value for the distance between path points &#8212; instead, the algorithm creates the bezier based on a total number of segments. As a result, we must calculate a <code>precision</code> value based on the distance between the starting point and the second point, as indicated on line 75.</p><pre class="crayon-plain-tag">local precision = pathPrecision
   if ( pathPrecision == 0 ) then
      precision = distBetween( pathPoints[1].x, pathPoints[1].y, pathPoints[2].x, pathPoints[2].y )
   end</pre><p>Next, we check if the <code>showPoints</code> parameter is true, we generate a dot along each point in the path by looping through the <code>pathPoints</code> table. Each point is added to a display group, <code>pathPointsGroup</code>, for easier cleanup when the curve is re-drawn.</p><pre class="crayon-plain-tag">if ( params.showPoints == true ) then
      local pathPointsGroup = display.newGroup() ; pathPointsGroup:toBack()
      for p = 1,#pathPoints do
         local dot = display.newCircle( pathPointsGroup, 0, 0, 8 )
         dot:setFillColor( 1, 1, 1, 0.4 )
         dot.x = pathPoints[p].x
         dot.y = pathPoints[p].y
      end
      M.ppg = pathPointsGroup
   end</pre><p>Finally, we call the <code>follow()</code> function and pass some core arguments to it:</p><pre class="crayon-plain-tag">follow( params, follower, pathPoints, precision )</pre><p></p>
<h4>Follow function</h4>
<p>The <code>follow()</code> function essentially performs some calculations and begins a series of <a href=http://docs.coronalabs.com/api/library/transition/index.html target="_blank">transitions</a> where each subsequent transition is queued by the completion of the previous transition. The calculations include an adjustment of the transition time if the <code>constantRate</code> boolean is <code>true</code>.</p><pre class="crayon-plain-tag">local transTime = params.segmentTime
         --if &quot;params.constantRate&quot; is true, adjust time according to segment distance
         if ( params.constantRate == true ) then
            local dist = distBetween( obj.x, obj.y, pathPoints[obj.nextPoint].x, pathPoints[obj.nextPoint].y )
            transTime = (dist/pathPrecision) * params.segmentTime
         end</pre><p>Additionally, we rotate the object to face the next point using the <code>angleBetween()</code> function:</p><pre class="crayon-plain-tag">--rotate object to face next point
         if ( obj.nextPoint &lt; #pathPoints ) then
            obj.rotation = angleBetween( obj.x, obj.y, pathPoints[obj.nextPoint].x, pathPoints[obj.nextPoint].y )
         end</pre><p>For the actual transition, we simply pass in some core parameters including the <code>transTime</code> calculated above and the <code>x</code> and <code>y</code> destination point. Additionally, we tag the transition with <code>"moveObject"</code> so it can easily be paused, resumed, or canceled, and we set the <code>onComplete</code> function to <code>nextTransition</code> so the process repeats until the object reaches the ending point. Finally, as each iteration occurs, we increment <code>obj.nextPoint</code> so the next transition moves to the next point along the path.</p><pre class="crayon-plain-tag">transition.to( obj, {
            tag = &quot;moveObject&quot;,
            time = transTime,
            x = pathPoints[obj.nextPoint].x,
            y = pathPoints[obj.nextPoint].y,
            onComplete = nextTransition
         })
         obj.nextPoint = obj.nextPoint+1</pre><p></p>
<h4>Pausing, resuming, canceling</h4>
<p>Because we tag each transition in the sequence with <code>"moveObject"</code>, pausing, resuming, or canceling is simple — just pass the tag name to one of the transition control APIs:</p><pre class="crayon-plain-tag">--pause the sequence
transition.pause( &quot;moveObject&quot; )
--some time later, resume it
transition.resume( &quot;moveObject&quot; )
--all finished... cancel it!
transition.cancel( &quot;moveObject&quot; )</pre><p></p>
<h3>In summary</h3>
<p>Hopefully this tutorial gets you started on curve-based path movement in Corona. Remember to download and carefully inspect the sample code used in this tutorial:</p>
<ul>
<li><a href=https://www.dropbox.com/s/nbi4scf79on8kkd/CurveDrawing.zip?dl=0 target="_blank">CurveDrawing.zip</a> — bezier module</li>
<li><a href=https://www.dropbox.com/s/z746t25j1e627q2/PathDrawing.zip?dl=0 target="_blank">PathDrawing.zip</a> — drawing module</li>
</ul>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2014/09/09/tutorial-working-with-curved-paths/feed/</wfw:commentRss>
		<slash:comments>7</slash:comments>
		</item>
	</channel>
</rss>
