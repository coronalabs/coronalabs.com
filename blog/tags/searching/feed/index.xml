<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>searching &#8211; Corona Labs</title>
	<atom:link href="/blog/tags/searching/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description></description>
	<lastBuildDate>Mon, 19 Oct 2020 12:16:12 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.8</generator>

<image>
	<url>/wordpress/wp-content/uploads/2017/06/cropped-icon_32x32@2x-32x32.png</url>
	<title>searching &#8211; Corona Labs</title>
	<link>/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Tutorial: Responsive Real-Time Searching</title>
		<link>/blog/2015/05/12/tutorial-responsive-real-time-searching/</link>
		<comments>/blog/2015/05/12/tutorial-responsive-real-time-searching/#comments</comments>
		<pubDate>Tue, 12 May 2015 20:46:09 +0000</pubDate>
		<dc:creator><![CDATA[Charles McKeever]]></dc:creator>
				<category><![CDATA[Guest Bloggers]]></category>
		<category><![CDATA[Tutorials, Tips and Demos]]></category>
		<category><![CDATA[searching]]></category>
		<category><![CDATA[tutorial]]></category>

		<guid isPermaLink="false">/?p=62743</guid>
		<description><![CDATA[In this tutorial, learn a simple technique which you can use to implement real-time data searches that produce responsive feedback and updates in your apps.]]></description>
				<content:encoded><![CDATA[<p><em>Today&#8217;s guest tutorial comes to you courtesy of Corona Ambassador and Portland, Oregon app developer Ed Maurina. Ed is a regular contributor to the weekly <a href=/community/corona-geek/ target="_blank">Corona Geek</a> hangouts and an active member of the Corona community. He has developed games for REEL FX Studios and maintains his Corona SSK game development library. Check out his work and blog at <a href=http://roaminggamer.com/>RoamingGamer.com</a>.</em></p>
<hr />
<p>In this tutorial, we will discuss a simple technique which you can use to implement real-time data searches that produce responsive feedback and updates in your apps.</p>
<h3>The Challenge</h3>
<p>If you have ever tried to implement a real-time search, you will be aware that it can be difficult to maintain application responsiveness for large data sets and/or dynamically changing search criteria.</p>
<p>For example, your application may have these requirements:</p>
<ul>
<li>The app has a massive data set.</li>
<li>The data set needs to be searchable.</li>
<li>Searches need to execute as soon as a user starts entering the search criteria.</li>
<li>When the search criteria change, the search should automatically adjust in real-time.</li>
<li>Matching entries are returned as they are found, updating the app interface.</li>
<li>The app should remain responsive.</li>
</ul>
<p>The last requirement is critical. If your app hangs or has temporary hiccups while a search executes, you may as well not distribute it.</p>
<p>So, how to do this?</p>
<h3>The Sample App</h3>
<p>To demonstrate a solution to the general problem above, let me specify an exact application and then provide code which solves the problem.</p>
<p>This application will have the following features:</p>
<ul>
<li><strong>Large Data Set</strong> &#8212; A simple word list containing over 100,000 words.</li>
<li><strong>FPS Counter</strong> &#8212; A simple FPS counter will be shown at all times to give concrete proof of responsiveness.</li>
<li><strong>Search Field</strong> &#8212; A single text entry field (works on devices and in both Simulators).</li>
<li><strong>Progress Counters</strong> &#8212; Meters to show total words, words found, and current search index.</li>
<li><strong>Results List</strong> &#8212; A basic (non-scrollable list) of words as they are found.</li>
</ul>
<h3>The App Modules</h3>
<p>The <a href=https://github.com/roaminggamer/RG_FreeStuff/raw/master/AskEd/2015/05/responsiveSearches/code.zip target="_blank">sample code</a> has several modules, found in Lua files of the same name:</p>
<ul>
<li><code>common.lua</code> &#8212; Calculates and discovers useful variables and flags (<code>left</code>, <code>right</code>, <code>centerX</code>, <code>onSimulator</code>, etc.).</li>
<li><code>wordList.lua</code> &#8212; Generates the data set.</li>
<li><code>meter.lua</code> &#8212; Creates a framerate meter.</li>
<li><code>searchField.lua</code> &#8212; Creates a &#8220;text input field&#8221; for our search that will work on devices and both Simulators (also creates count and index counters).</li>
<li><code>example.lua</code> &#8212; The solution to the problem posed at the start of this article.</li>
</ul>
<h3>Initialize Search Settings</h3>
<p>Before we start the <code>"enterFrame"</code> listener, we need to initialize the module:</p>
<ol>
<li>Create and position initial results display group.</li>
<li>Initialize flags and variables to starting values.</li>
<li>Set how many comparisons we&#8217;re allowed to do per frame.</li>
</ol>
<p></p><pre class="crayon-plain-tag">function example.init( maxTime )
    -- 1.
    foundGroup = display.newGroup()
    foundGroup.y = com.top + 60

    -- 2.
    searching = false -- Not currently searching
    lastTerm = &quot;&quot; -- No search term yet.
    curIndex = 1 -- On first word in word list.
    foundCount = 0 -- No words found yet.

    -- 3.
    searchTime = maxTime or (1000/display.fps/2)
end</pre><p>Notice that in step #3, when we initialize the search code, if we don&#8217;t specify a specific time, the code automatically detects the FPS (as set in <code>config.lua</code>) and then calculates a time equal to half of one frame.</p>
<h3>The &#8220;enterFrame&#8221; Listener</h3>
<p>Once the module is initialized, we can define the <code>"enterFrame"</code> listener and start it running. The definition has five parts.</p>
<h4>Part 1 &#8212; Get the current search term and see if it has changed</h4>
<p></p><pre class="crayon-plain-tag">local searchTerm = searchField.getSearchTerm()
if ( lastTerm ~= searchTerm ) then
    example.resetResults()
    lastTerm = searchTerm
    searching = ( string.len( searchTerm ) &gt; 0 )
end</pre><p>If the search results have changed, we reset the search results (similar to initialization of module), take note of the new search term, and set flags saying that we are &#8220;searching.&#8221; If they have not, we simply ignore this bit of code and continue on.</p>
<h4>Part 2 &#8212; Abort if not &#8220;searching&#8221;</h4>
<p></p><pre class="crayon-plain-tag">if ( not searching ) then return end</pre><p>If the <code>searching</code> flag is set to false, we abort early and wait for the next frame to start again.</p>
<h4>Part 3 &#8212; Search until we are out of time, or at the end of the word list</h4>
<p>While each of the above modules may be useful and interesting, we will focus only on <code>example.lua</code>.</p>
<h4>The Solution</h4>
<p>After this build up, you may be disappointed to see that this is basically a self-regulating <code>"enterFrame"</code> listener. In a nutshell, the listener starts a new search whenever the search criteria change and searches in a tight loop till a set amount of time passes. It then stops searching and exits. On the next frame, the entire sequence starts again.</p>
<p>The listener has this logical structure:</p>
<p><img class="wp-image-62745 size-full" style="margin: 0px 0px 20px 0px;" src="/wordpress/wp-content/uploads/2015/05/responsive-real-time-searching-diagram.png" alt="Responsive Real-time Searching Logic Flowchart" width="606" height="547" /></p>
<p>Now let&#8217;s look at the actual code.</p><pre class="crayon-plain-tag">local getTimer = system.getTimer -- localize for speedup
local strLower = string.lower -- localize for speedup
local startTime = getTimer()
local elapsedTime = 0

while ( elapsedTime &lt; searchTime and curIndex &lt;= #wordList ) do
    local curWord = wordList[curIndex]
    if ( string.match( strLower(curWord), strLower( searchTerm ) ) ~= nil ) then
        example.drawResult( curWord )
    end
    elapsedTime = getTimer() - startTime
    curIndex = curIndex + 1
end</pre><p>This code:</p>
<ul>
<li>Localizes some useful functions for an execution speedup.</li>
<li>Takes note of the <code>startTime</code>.</li>
<li>Sets <code>elapsedTime</code> to zero.</li>
<li>Enters a search loop and does not exit until it get to the end of the list or runs out of time.</li>
<li>Upon finding match, the code displays it, and continues.</li>
</ul>
<p>This is the meat of the solution and you should understand that by measuring &#8220;elapsed time&#8221; each time we search and (possibly) display results, we ensure that:</p>
<ol>
<li>The search can give us as soon as it needs to and not block the completion of this frame.</li>
<li>The code that stops and resumes searching is dynamic and takes into account the cost of the search and displaying the results.</li>
</ol>
<h4>Part 4 &mdash; Update the search index label</h4>
<p></p><pre class="crayon-plain-tag">searchField.setSearchIndex( curIndex )</pre><p>(<em>Note that this part is purely for feedback in the example</em>)</p>
<h4>Part 5 &mdash; Check to see if we reached the end of list, and quit if so</h4>
<p></p><pre class="crayon-plain-tag">searching = curIndex &lt; #wordList</pre><p>As a final step in the listener, we check to see if the end of the word list was reached. If it was, we set <code>searching</code> to false. In either case, we drop out of the function (it will execute again at the beginning of the next frame).</p>
<h3>In Conclusion</h3>
<p>As I mentioned above, this blog post <a href=https://github.com/roaminggamer/RG_FreeStuff/raw/master/AskEd/2015/05/responsiveSearches/code.zip target="_blank">comes with sample code</a>, so please experiment with it in your own apps. Hopefully this tutorial has shown you an interesting methodology to implement real-time, responsive searching in your project.</p>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2015/05/12/tutorial-responsive-real-time-searching/feed/</wfw:commentRss>
		<slash:comments>6</slash:comments>
		</item>
	</channel>
</rss>
