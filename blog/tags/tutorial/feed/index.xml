<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>tutorial &#8211; Corona Labs</title>
	<atom:link href="/blog/tags/tutorial/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description></description>
	<lastBuildDate>Mon, 19 Oct 2020 12:16:12 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.8</generator>

<image>
	<url>/wordpress/wp-content/uploads/2017/06/cropped-icon_32x32@2x-32x32.png</url>
	<title>tutorial &#8211; Corona Labs</title>
	<link>/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Tutorial: Using the mobile/remote accelerometer</title>
		<link>/blog/2015/11/24/tutorial-using-the-mobileremote-accelerometer/</link>
		<comments>/blog/2015/11/24/tutorial-using-the-mobileremote-accelerometer/#comments</comments>
		<pubDate>Tue, 24 Nov 2015 21:26:38 +0000</pubDate>
		<dc:creator><![CDATA[Rob Miracle]]></dc:creator>
				<category><![CDATA[Tutorials, Tips and Demos]]></category>
		<category><![CDATA[accelerometer]]></category>
		<category><![CDATA[remote]]></category>
		<category><![CDATA[tutorial]]></category>
		<category><![CDATA[tvOS]]></category>

		<guid isPermaLink="false">/?p=64766</guid>
		<description><![CDATA[In this tutorial, learn how to use accelerometer events to detect motions of a mobile device or the accelerometer-enabled Apple TV Remote.]]></description>
				<content:encoded><![CDATA[<p>One of the cool things about the new <a href=https://developer.apple.com/tvos/human-interface-guidelines/remote-and-interaction/ target="_blank">Apple TV Remote</a> is that it has a built-in accelerometer, and similar to mobile devices, this allows you to guage the device&#8217;s position/orientation in space. Essentially, on either a mobile device or the remote control, the accelerometer makes three discrete measurements based on the orientation and center point of the device.</p>
<h3>Accelerometer events</h3>
<p>The <a href=https://docs.coronalabs.com/api/event/accelerometer/index.html target="_blank">accelerometer event</a> returns several useful values, including:</p>
<ul>
<li><a href=https://docs.coronalabs.com/api/event/accelerometer/name.html target="_blank">event.name</a> &#8212; This property will always be <code>"accelerometer"</code>.</li>
<li><a href=https://docs.coronalabs.com/api/event/accelerometer/isShake.html target="_blank">event.isShake</a> &#8212; This property will be <code>true</code> if a rapid movement of the device is detected.</li>
<li><a href=https://docs.coronalabs.com/api/event/accelerometer/xGravity.html target="_blank">event.xGravity</a> / <a href=https://docs.coronalabs.com/api/event/accelerometer/yGravity.html target="_blank">event.yGravity</a> / <a href=https://docs.coronalabs.com/api/event/accelerometer/zGravity.html target="_blank">event.zGravity</a> &#8212; These events are probably the most useful. They are normalized, so you get a value between <code>-1.0</code> and <code>1.0</code>. These values are also smoothed out to adjust for micro-movements and prevent jerky actions.</li>
<li><a href=https://docs.coronalabs.com/api/event/accelerometer/xInstant.html target="_blank">event.xInstant</a>,<a href=https://docs.coronalabs.com/api/event/accelerometer/yInstant.html target="_blank"> event.yInstant</a>, <a href=https://docs.coronalabs.com/api/event/accelerometer/zInstant.html target="_blank">event.zInstant</a> &#8212; These values report the change since the last event, for instance the current <code>event.xGravity</code> minus the last <code>event.xGravity</code>.</li>
<li><a href=https://docs.coronalabs.com/api/event/accelerometer/xRaw.html target="_blank">event.xRaw</a>, <a href=https://docs.coronalabs.com/api/event/accelerometer/yRaw.html target="_blank">event.yRaw</a>, <a href=https://docs.coronalabs.com/api/event/accelerometer/zRaw.html target="_blank">event.zRaw</a> &#8212; These values are the actual values from the device (there is no filtering or smoothing applied).</li>
<li><a href=https://docs.coronalabs.com/api/event/accelerometer/deltaTime.html target="_blank">event.deltaTime</a> &#8212; Accelerometer events come at somewhat predictable intervals based on the value set by the <a href=https://docs.coronalabs.com/api/library/system/setAccelerometerInterval.html>system.setAccelerometerInterval()</a> function, but they are not guaranteed to arrive on time. This is where the <a href=https://docs.coronalabs.com/api/event/accelerometer/deltaTime.html target="_blank">event.deltaTime</a> comes in. It allows you to get the time between events so you can provide additional smoothing as needed.</li>
</ul>
<p>All of the &#8220;gravity,&#8221; &#8220;instant,&#8221; and &#8220;raw&#8221; values assume that the device is being held in &#8220;portrait&#8221; orientation. This is very common for people holding the Apple TV Remote (the remote being held like a traditional TV/audio remote control). However, if you&#8217;re designing a landscape-oriented app like a racing game, you might want the remote to be held in &#8220;landscape&#8221; orientation (like a traditional console game controller) in order to emulate a steering wheel. In this case, you should adjust your values by 90 degrees.</p>
<h3>Implementation</h3>
<p>Let&#8217;s look at a simple implementation of the accelerometer. This app will create a blue circle and allow you to move it around the screen by moving/orienting the device.</p><pre class="crayon-plain-tag">display.setDefault( &quot;anchorX&quot;, 0 )

local dot = display.newCircle( display.contentCenterX, display.contentCenterY, 20 )
dot:setFillColor( 0, 0, 1 )
dot.color = &quot;blue&quot;
dot.anchorX = 0.5

local xGravityLabel = display.newText( &quot;xGravity:&quot;, 10, 15, native.systemFontBold, 12 )
local yGravityLabel = display.newText( &quot;yGravity:&quot;, 10, 31, native.systemFontBold, 12 )
local zGravityLabel = display.newText( &quot;zGravity:&quot;, 10, 47, native.systemFontBold, 12 )

local xGravity = display.newText( &quot;&quot;, 80, 15, native.systemFont, 12 )
local yGravity = display.newText( &quot;&quot;, 80, 31, native.systemFont, 12 )
local zGravity = display.newText( &quot;&quot;, 80, 47, native.systemFont, 12 )

local xInstantLabel = display.newText( &quot;xInstant:&quot;, 250, 15, native.systemFontBold, 12 )
local yInstantLabel = display.newText( &quot;yInstant:&quot;, 250, 31, native.systemFontBold, 12 )
local zInstantLabel = display.newText( &quot;zInstant:&quot;, 250, 47, native.systemFontBold, 12 )

local xInstant = display.newText( &quot;&quot;, 330, 15, native.systemFont, 12 )
local yInstant = display.newText( &quot;&quot;, 330, 31, native.systemFont, 12 )
local zInstant = display.newText( &quot;&quot;, 330, 47, native.systemFont, 12 )

local function onTilt( event )
    xGravity.text = event.xGravity
    yGravity.text = event.yGravity
    zGravity.text = event.zGravity
    xInstant.text = event.xInstant
    yInstant.text = event.yInstant
    zInstant.text = event.zInstant

    dot.x = dot.x + event.xGravity
    dot.y = dot.y + event.yGravity

    if dot.x &gt; display.contentWidth then
        dot.x = display.contentWidth
    end
    if dot.x &lt; 0 then
        dot.x = 0
    end
    if dot.y &gt; display.contentHeight then
        dot.y = display.contentHeight
    end
    if dot.y &lt; 0 then 
        dot.y = 0
    end

    if event.isShake then
        if dot.color == &quot;blue&quot; then
            dot:setFillColor( 1, 0, 0 )
            dot.color = &quot;red&quot;
        else
            dot:setFillColor( 0, 0, 1 )
            dot.color = &quot;blue&quot;
        end
    end
    return true
end

Runtime:addEventListener( &quot;accelerometer&quot;, onTilt )</pre><p>For this simple example, we create a dot (circle), color it blue, and set up some text display objects to show the values received from the accelerometer event.</p>
<p>Accelerometer events require a listener function, served by our <code>onTilt()</code> function. Inside the function, we update the on-screen values based on the current accelerometer data.</p>
<p>Next, we add the values of <code>event.xGravity</code> and <code>event.yGravity</code> to the dot&#8217;s <strong>x</strong> and <strong>y</strong> position. This will move the dot around the screen. Following this, we write four conditional statements to constrain the dot to the screen bounds.</p>
<p>In the final block of the function, we test to see if the device was shaken and swap the color between red and blue each time a shake is detected.</p>
<p>Finally, on the last line of the example, we enable the <code>"accelerometer"</code> event handler.</p>
<h3>Conclusion</h3>
<p>Using the accelerometer is an important part of getting your apps to run properly on tvOS &#8212; after all, not every control scheme can be accomplished with simple up/down/left/right key events or axis inputs. For example, consider a classic game like &#8220;Fruit Ninja.&#8221; On a mobile device, you couldn&#8217;t use the accelerometer to slash the fruit, but now with an accelerometer-enabled remote, you could detect slashing motions by tracking the accelerometer&#8217;s values.</p>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2015/11/24/tutorial-using-the-mobileremote-accelerometer/feed/</wfw:commentRss>
		<slash:comments>3</slash:comments>
		</item>
		<item>
		<title>Tutorial Treasury: String formatting and manipulation</title>
		<link>/blog/2015/10/27/tutorial-treasury-string-formatting-and-manipulation/</link>
		<comments>/blog/2015/10/27/tutorial-treasury-string-formatting-and-manipulation/#comments</comments>
		<pubDate>Tue, 27 Oct 2015 21:53:44 +0000</pubDate>
		<dc:creator><![CDATA[Brent Sorrentino]]></dc:creator>
				<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[formatting]]></category>
		<category><![CDATA[string]]></category>
		<category><![CDATA[tutorial]]></category>

		<guid isPermaLink="false">/?p=64410</guid>
		<description><![CDATA[In this Tutorial Treasury, discover resources related to string formatting and manipulation.]]></description>
				<content:encoded><![CDATA[<p>As any Corona developer knows, Lua <strong>variables</strong> come in many forms &#8212; most commonly tables (arrays), numbers, strings, and booleans (true/false). Among these, <strong>strings</strong> present a nearly limitless range of possibilities, as they can be of considerable length, vary in content, and contain special characters that no other variable type can. This can present some challenge to Corona developers, especially when it comes time to &#8220;select or detect&#8221; a specific portion within a longer string or <strong>format</strong> the string in a very custom, specific manner.</p>
<p>This tutorial treasury contains some useful and often essential resources on how to work with strings in your Corona apps.</p>
<h3>Tutorials</h3>
<h4>Formatting values using “string.format()”</h4>
<p>Formatting a particular string is a common requirement in almost any app, whether it be limiting the number of decimal places in a long number, adding &#8220;placeholder&#8221; spaces, or padding a score with leading zeros. The <a href=http://docs.coronalabs.com/api/library/string/format.html target="_blank">string.format()</a> function is almost infinitely powerful for this task, but many developers are mystified by its parameters and usage. This tutorial aims to dispel some of the confusion surrounding string formatting.</p>
<h4>Lua string magic</h4>
<p>Sometimes, formatting strings becomes an even more specific process, and a little &#8220;magic&#8221; is required to achieve the end goal. In this tutorial, learn how to overcome special formatting challenges including splitting, trimming, line wrapping, and more.</p>
<h4>Utilizing time and dates</h4>
<p>Many apps rely on time and dates, and it can be tricky to properly format time/date-based data, particularly strings gathered from <a href=http://docs.coronalabs.com/api/library/os/time.html target="_blank">os.time()</a> and <a href=http://docs.coronalabs.com/api/library/os/date.html target="_blank">os.date()</a>. In this tutorial, learn how to use string functions to format time and dates exactly as required in your apps.</p>
<h3>Further reading</h3>
<ul>
<li><a href=https://docs.coronalabs.com/guide/data/luaString/index.html target="_blank">Lua String Manipulation</a> guide</li>
<li><a href=https://docs.coronalabs.com/api/library/string/format.html target="_blank">string.format()</a> documentation</li>
<li><a href=https://docs.coronalabs.com/api/library/string/match.html target="_blank">string.match()</a> documentation</li>
</ul>
<h3>Conclusion</h3>
<p>As illustrated, string formatting and manipulation is a common but often misunderstood process. Hopefully this collection of resources gets you started on the path toward understanding and mastery of string-related tasks.</p>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2015/10/27/tutorial-treasury-string-formatting-and-manipulation/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>Tutorial: Creating awesome water with LiquidFun, snapshots, and filters</title>
		<link>/blog/2015/09/24/tutorial-creating-awesome-water-with-liquidfun-snapshots-and-filters/</link>
		<comments>/blog/2015/09/24/tutorial-creating-awesome-water-with-liquidfun-snapshots-and-filters/#comments</comments>
		<pubDate>Thu, 24 Sep 2015 20:29:12 +0000</pubDate>
		<dc:creator><![CDATA[Brent Sorrentino]]></dc:creator>
				<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[liquid effects]]></category>
		<category><![CDATA[LiquidFun]]></category>
		<category><![CDATA[physics]]></category>
		<category><![CDATA[tutorial]]></category>

		<guid isPermaLink="false">/?p=64081</guid>
		<description><![CDATA[Following the worldwide success of “Freeze! - The Escape,” Frozen Gun Studios has just released the sequel, “Freeze! 2 - Brothers,” built entirely in Corona SDK. This tutorial illustrates how to create awesome water with LiquidFun, snapshots, and filters.]]></description>
				<content:encoded><![CDATA[<p><em>This tutorial comes to you courtesy of Andreas von Lepel of <a href=http://www.frozengun.com/ target="_blank">Frozen Gun Studios</a>. Following the worldwide success of “Freeze! &#8211; The Escape” (<a href=https://itunes.apple.com/us/app/freeze%21/id518123684?mt=8 target="_blank">iOS</a>/<a href=https://play.google.com/store/apps/details?id=com.frozengun.freeze target="_blank">Android</a>) with more than <strong>11 million</strong> freemium downloads, Frozen Gun Studios has just released the sequel, “Freeze! 2 &#8211; Brothers” (<a href=https://itunes.apple.com/app/freeze!-2-brothers/id904424939?mt=8 target="_blank">iOS</a>/<a href=https://play.google.com/store/apps/details?id=com.frozengun.freeze2.google target="_blank">Android</a>), built entirely in Corona SDK and featuring LiquidFun-based water effects.</em></p>
<hr />
<h3>Overview</h3>
<p>Very early in the development, I decided that it would be really interesting for the gameplay if I could have water and poisonous liquids like rocket fuel sloshing around in the rotating levels. Have a look at the trailer to see what we did:</p>
<p><iframe width="1060" height="596" src="https://www.youtube.com/embed/kbAwJtuRV0U?feature=oembed" frameborder="0" gesture="media" allowfullscreen></iframe></p>
<p>As you can see, both our heroes can swim in the water, but in later stages the task for the player is to first collect all the deadly rocket fuel into a barrel and then to pick it up to open the level exit.</p>
<h3>Project code</h3>
<p>Setting up a scene with basic water using LiquidFun is really easy and there are some nice examples included in the Corona <a href=https://github.com/coronalabs/samples-coronasdk/tree/master/Physics target="_blank">SampleCode repository</a>. However, creating really nice, transparent water with a visible &#8220;surface&#8221; is a little harder and you need to use snapshots and filters. Fortunately, as usual with Corona SDK, even complex stuff is mostly done for you by the engine.</p>
<p>As we step through this tutorial, I encourage you to download the <a href=https://github.com/coronalabs/samples-coronasdk/tree/master/Physics/LiquidFun-Transparency target="_blank">LiquidFun-Transparency</a> project in the GitHub repository, also bundled into recent builds of Corona SDK:</p>
<p><code>CoronaSDK-XXXX</code> → <code>SampleCode</code> → <code>Physics</code> → <code>LiquidFun-Transparency</code></p>
<p>Within the project folder, open the <code>main.lua</code> file. We&#8217;ll start with the basic world setup:</p>
<h4>Liquid &#8220;container&#8221;</h4>
<p></p><pre class="crayon-plain-tag">-- Add three physics objects as borders for the simulated liquid, located outside the visible screen
local leftSide = display.newRect( worldGroup, -54-letterboxWidth, display.contentHeight-180, 600, 70 )
physics.addBody( leftSide, &quot;static&quot; )
leftSide.rotation = 86

local centerPiece = display.newRect( worldGroup, display.contentCenterX, display.contentHeight+60+letterboxHeight, 440, 120 )
physics.addBody( centerPiece, &quot;static&quot; )

local rightSide = display.newRect( worldGroup, display.contentWidth+54+letterboxWidth, display.contentHeight-180, 600, 70 )
physics.addBody( rightSide, &quot;static&quot; )
rightSide.rotation = -86</pre><p>In this block, I use three static rectangles to build a container outside of the screen boundaries. The container is open at the top and it will later hold the water inside of the screen.</p>
<h4>Scrolling background</h4>
<p>I want even demos to look nice, so in the next block, I add an endless scrolling background by placing two identical background images adjacent to each other, one fully visible in the middle of the screen, the other to the right of it.</p><pre class="crayon-plain-tag">-- Create an endless scrolling background, using background image from &quot;Freeze!&quot;
local background1 = display.newImageRect( worldGroup, &quot;background.png&quot;, 320, 480 )
background1.x = 160
background1.y = 240
background1.xScale = 1.202
background1.yScale = 1.200
transition.to( background1, { time=12000, x=-224, iterations=0 } )

local background2 = display.newImageRect( worldGroup, &quot;background.png&quot;, 320, 480 )
background2.x = 544
background2.y = 240
background2.xScale = 1.202
background2.yScale = 1.200
transition.to( background2, { time=12000, x=160, iterations=0 } )</pre><p>Note that both images are moved slowly to the left and then, via endless iterations, are set back to their original positions and moved again, all using simple <a href=https://docs.coronalabs.com/api/library/transition/index.html target="_blank">transition.to()</a> calls.</p>
<h4>The hero</h4>
<p>Next, I add our eye hero into the scene as a dynamic physics object that will swim on the water. It can also be touched and dragged around by the user. I will not dive into the touch-drag code, about which a lot has been written and demonstrated previously.</p><pre class="crayon-plain-tag">-- Create our eye (the hero of &quot;Freeze!&quot;)
local hero = display.newImageRect( worldGroup, &quot;hero.png&quot;, 64, 64 )
hero.x = 160
hero.y = -400
physics.addBody( hero, { density=0.7, friction=0.3, bounce=0.2, radius=30 } )

-- Make hero draggable via a touch handler and physics touch joint
local function dragBody( event )
    local body = event.target
    local phase = event.phase

    if ( &quot;began&quot; == phase ) then
        display.getCurrentStage():setFocus( body, event.id )
        body.isFocus = true
        body.tempJoint = physics.newJoint( &quot;touch&quot;, body, event.x, event.y )
        body.isFixedRotation = true
    elseif ( body.isFocus ) then
        if ( &quot;moved&quot; == phase ) then
            body.tempJoint:setTarget( event.x, event.y )
        elseif ( &quot;ended&quot; == phase or &quot;cancelled&quot; == phase ) then
            display.getCurrentStage():setFocus( body, nil )
            body.isFocus = false
            event.target:setLinearVelocity( 0,0 )
            event.target.angularVelocity = 0
            body.tempJoint:removeSelf()
            body.isFixedRotation = false
        end
    end
    return true
end
hero:addEventListener( &quot;touch&quot;, dragBody )</pre><p></p>
<h4>LiquidFun particle system and water</h4>
<p>In the next block, the particle system for the water is created, and a big rectangle of water particles is placed into the scene. </p>
<p></p><pre class="crayon-plain-tag">-- Create the LiquidFun particle system for the water
local particleSystem = physics.newParticleSystem{
    filename = &quot;liquidParticle.png&quot;,
    radius = 3,
    imageRadius = 5,
    gravityScale = 1.0,
    strictContactCheck = true
}

-- Create a &quot;block&quot; of water (LiquidFun group)
particleSystem:createGroup(
    {
        flags = { &quot;tensile&quot; },
        x = 160,
        y = 0,
        color = { 0.1, 0.1, 0.1, 1 },
        halfWidth = 128,
        halfHeight = 256
    }
)</pre><p>And this is the result if you start the code now:</p>
<p><center><img class="wp-image-64126 alignnone" style="margin-bottom: 18px;" src="/wordpress/wp-content/uploads/2015/09/LiquidFunDemo01.png" alt="LiquidFunDemo01" width="300" height="615" /><br />
<em>The water is flowing, but it&#8217;s more like oil, because there is no transparency yet.</em></center></p>
<h4>Adding transparency (first attempt)</h4>
<p>Now things get a little more complex. I want to render the water semi-transparent, e.g. with an alpha value of <code>0.3</code> (30%) so that the background is visible through the water.</p>
<p>If I change the last value (alpha) of the the <code>color</code> property on line <code>111</code>, there will be some transparency, but not exactly what I&#8217;m looking for:</p>
<p><center><img class="alignnone wp-image-64127" style="margin-bottom: 18px;" src="/wordpress/wp-content/uploads/2015/09/LiquidFunDemo02.png" alt="LiquidFunDemo02" width="300" height="615" /><br />
<em>Each particle now has an alpha value of 30%.</em></center>If you look closely at the image, you can see that each round particle now has an alpha value of <code>0.3</code>, and this gives a chaotic rendering of the water because all of the particles overlap slightly. While this could be nice effect for certain cases, it&#8217;s definitely not what I am trying to achieve.</p>
<h4>Adding transparency using a snapshot</h4>
<p>The solution is to render all the particles into a <a href=https://docs.coronalabs.com/api/library/display/newSnapshot.html target="_blank">snapshot</a> texture on each frame and then apply transparency to the entire texture. Here are the relevant lines:</p><pre class="crayon-plain-tag">-- Initialize snapshot for full screen
local snapshot = display.newSnapshot( worldGroup, 320+letterboxWidth+letterboxWidth, 480+letterboxHeight+letterboxHeight )
local snapshotGroup = snapshot.group
snapshot.x = 160
snapshot.y = 240
snapshot.canvasMode = &quot;discard&quot;
snapshot.alpha = 0.3</pre><p></p><pre class="crayon-plain-tag">-- Insert the particle system into the snapshot
snapshotGroup:insert( particleSystem )
snapshotGroup.x = -160
snapshotGroup.y = -240</pre><p></p><pre class="crayon-plain-tag">-- Update (invalidate) the snapshot each frame
local function onEnterFrame( event )
    snapshot:invalidate()
end
Runtime:addEventListener( &quot;enterFrame&quot;, onEnterFrame )</pre><p>Essentially, a snapshot and its group are created, positioned in the center of the content area. Note that the width and height of the snapshot are adjusted by the <code>letterboxWidth</code> and <code>letterboxHeight</code> variables calculated earlier in <code>main.lua</code> &#8212; this ensures that, when running in <code>"letterbox"</code> scale mode, the snapshot occupies the entire screen on devices of various aspect ratios.</p>
<p>On line <code>123</code>, I set the alpha value of the entire snapshot to <code>0.3</code>, effectively setting the entire snapshot texture to 30% opacity. Following this, the particle system is inserted into the snapshot group and finally, with the help of an <code>"enterFrame"</code> listener, the snapshot is invalidated and rendered anew each frame.</p>
<p>With this addition, you can see that the water now has realistic transparency:</p>
<p><center><img class="alignnone wp-image-64128" style="margin-bottom: 18px;" src="/wordpress/wp-content/uploads/2015/09/LiquidFunDemo03.png" alt="LiquidFunDemo03" width="300" height="615" /><br />
<em>Transparency! At last!</em></center></p>
<h4>Go for pretty and add a filter</h4>
<p>After I got this far, I was quite happy. But the cool engineers at Corona Labs added <a href=https://docs.coronalabs.com/guide/graphics/effects.html target="_blank">filter</a> support, so I started to experiment a lot with all of the filters and filter options in my quest to add a nice visible surface to the water. It took some time to achieve the correct look, but in the end it was really easy:</p><pre class="crayon-plain-tag">-- Apply a &quot;sobel&quot; filter to portray the visible surface of the water
snapshot.fill.effect = &quot;filter.sobel&quot;</pre><p>And that&#8217;s it, we now have water with transparency and a nice water surface!</p>
<p><center><img class="alignnone wp-image-64129" style="margin-bottom: 18px;" src="/wordpress/wp-content/uploads/2015/09/LiquidFunDemo04.png" alt="LiquidFunDemo04" width="300" height="615" /><br />
<em>The water &#8220;surface&#8221; shows as a visible line on top of the water<br />
(the edge of the rendered water enhanced by the sobel filter).</em></center></p>
<h4>Where to go from here</h4>
<p>From here, there are a lot of experiments you can do, e.g. play around with the density of the hero eye (with this you can influence whether it should be very light and always float on top of the water, or whether it should be heavy and sink below).</p>
<p>Another option is to use different filters for the water and tune their respective filter settings:</p>
<ul>
<li><code>snapshot.fill.effect = "filter.emboss"</code></li>
<li><code>snapshot.fill.effect = "filter.frostedGlass"</code></li>
<li><code>snapshot.fill.effect = "filter.crystallize"</code></li>
<li><code>snapshot.fill.effect = "filter.scatter"</code></li>
</ul>
<p>Finally, don&#8217;t forget the many different &#8220;flags&#8221; you can use for the LiquidFun group &#8212; e.g. add <code>"staticPressure"</code> and the water particles at the bottom of the container will not be compressed.</p>
<h3>Performance issues</h3>
<p>Not all devices are powerful enough to display water with these added special effects while maintaining an acceptable frame rate. Because of this, I take the following precautions:</p>
<ul>
<li>On iOS, I use the snapshot on all supported devices (iPhone 4S and better; iPad 2 and better). However, the additional sobel filter is added only on more powerful devices like the iPad Air or iPad mini 2 (iPad4,*), iPhone 5S (iPhone6,1), or iPod Touch 5G (iPod5,1) and better.</li>
<li>For Android, I set the <code>minSdkVersion</code> to <code>"16"</code> (Android 4.1) to exclude many older devices. Also, I use the sobel filter only on devices that support high precision shaders, as determined by this:<br />
<code>system.getInfo( "gpuSupportsHighPrecisionFragmentShaders" )</code></li>
<li>Finally, I test the <code>system.getInfo( "androidDisplayDensityName" )</code> for <code>"xhdpi"</code>, <code>"xxhdpi"</code>, and <code>"xxxhdpi"</code> &#8212; only these devices will get the sobel filter, because they are quite modern and should hopefully be fast enough.</li>
</ul>
<h3>Conclusion</h3>
<p>As you can see, it is quite easy to create nice-looking water and other liquids, and at last the technology is good enough to make all of this useable on modern mobile devices. I&#8217;m looking forward to seeing more games which make use of this, as liquids are great fun for players and developers alike.</p>
<p>If you want to learn more about “Freeze! 2 – Brothers,” visit <a href=http://www.freeze2.com/ target="_blank">www.freeze2.com</a>, or download it for either <a href=https://itunes.apple.com/app/freeze!-2-brothers/id904424939?mt=8 target="_blank">iOS</a> or <a href=https://play.google.com/store/apps/details?id=com.frozengun.freeze2.google target="_blank">Android</a>. I hope you enjoy the game!</p>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2015/09/24/tutorial-creating-awesome-water-with-liquidfun-snapshots-and-filters/feed/</wfw:commentRss>
		<slash:comments>8</slash:comments>
		</item>
		<item>
		<title>Tutorial: Partially filling an object</title>
		<link>/blog/2015/09/08/tutorial-partially-filling-an-object/</link>
		<comments>/blog/2015/09/08/tutorial-partially-filling-an-object/#comments</comments>
		<pubDate>Tue, 08 Sep 2015 22:43:29 +0000</pubDate>
		<dc:creator><![CDATA[Rob Miracle]]></dc:creator>
				<category><![CDATA[Tutorials, Tips and Demos]]></category>
		<category><![CDATA[meter]]></category>
		<category><![CDATA[tutorial]]></category>

		<guid isPermaLink="false">/?p=63949</guid>
		<description><![CDATA[In this tutorial, learn how to partially fill an object with color for various user interface elements in your projects.]]></description>
				<content:encoded><![CDATA[<p>In designing your UI (User Interface), imagine that you want to include an element like a health bar or a thermometer that can be partially filled with a solid color (or any other image) which represents an &#8220;amount&#8221; that the element contains.</p>
<p>While Corona provides the pre-packaged <a href=https://docs.coronalabs.com/api/library/widget/newProgressView.html target="_blank">ProgressView()</a> widget which may meet this goal, taking it to a more elaborate visual appearance requires some creativity. In this tutorial, we will create a more customized health bar example where a <strong>symbol</strong> represents the player&#8217;s health &#8212; this will consist of a hollow outline that can be filled with a color as the player&#8217;s health increases or decreases.</p>
<h3>Prerequisites</h3>
<p>To make this work, you will need three separate images:</p>
<ol>
<li>An image that is the &#8220;empty&#8221; outline of the object &#8212; aside from the outline, all pixels should be <em>transparent</em>, as represented by the grey checkerboard grid in the example image below.</li>
<li>An image which represents the fully &#8220;filled&#8221; object (again, all pixels that are not part of the filled image should be transparent).</li>
<li>A basic white <a href=https://docs.coronalabs.com/guide/media/imageMask/index.html target="_blank">mask</a> (including the required black border).</li>
</ol>
<p><a href=/wordpress/wp-content/uploads/2015/09/characterimageexample.png><img class="size-full wp-image-63972 aligncenter" style="margin-top: 32px; margin-bottom: 32px;" src=/wordpress/wp-content/uploads/2015/09/characterimageexample.png alt="characterimageexample" width="324" height="208" /></a></p>
<p>Using these three elements, the general concept is to place the &#8220;filled&#8221; image on the screen, then overlay (draw at the exact same place on the screen) the &#8220;outline&#8221; image. This in itself won&#8217;t do anything &#8212; merely the outline will overlay the filled image. However, when you create and apply the <a href=https://docs.coronalabs.com/guide/media/imageMask/index.html target="_blank">mask</a> to the bottom layer, you will gain the ability to set the <em>position</em> of that mask and effectively indicate how &#8220;full&#8221; the object is.</p>
<h3>Basic setup</h3>
<p>Consider this code:</p><pre class="crayon-plain-tag">display.setDefault( &quot;background&quot;, 1, 1, 1 )

-- Place the &quot;filled&quot; object on the screen
local filledUI = display.newImageRect( &quot;filled.png&quot;, 100, 200 )
filledUI.x = display.contentCenterX
filledUI.y = display.contentCenterY

-- Create the mask object
local UIMask = graphics.newMask( &quot;mask.png&quot; )
-- Apply the mask to the bottom image ('filledUI')
filledUI:setMask( UIMask )
filledUI.maskY = 0

-- Overlay the &quot;outline&quot; object over the &quot;filled&quot; object
local outlineUI = display.newImageRect( &quot;outline.png&quot;, 100, 200 )
outlineUI.x = display.contentCenterX
outlineUI.y = display.contentCenterY</pre><p>The first block of code defines the underlying &#8220;filled&#8221; image (the image completely filled with color). For convenience, we position this object in the center of the content area.</p>
<p>Next, we create a mask (<code>UIMask</code>) using <a href=https://docs.coronalabs.com/api/library/graphics/newMask.html target="_blank">graphics.newMask()</a>. This mask image is solid white except for the required black border around the edges. In this case, since the UI image is 100×200 pixels, the mask consists of a 100×200 area of white plus a 4 pixel black border, resulting in an overall mask image of 108×208. Once created, the mask is applied to the underlying image (<code>filledUI</code>) and positioned at a <a href=https://docs.coronalabs.com/api/type/DisplayObject/maskY.html target="_blank">maskY</a> value of <code>0</code> (this position will be important in the next step).</p>
<p>Next, we overlay the &#8220;outline&#8221; image (<code>outlineUI</code>) on top. This element will simply be used as a frame for the UI object as we adjust the mask position on the underlying filled image.</p>
<h3>Controlling the fill</h3>
<p>The fill of the UI meter is completely controlled by adjusting the <strong>y</strong> position of the mask (<a href=https://docs.coronalabs.com/api/type/DisplayObject/maskY.html target="_blank">maskY</a>). In this example, since the object is 200 pixels tall, we can set this value to <code>100</code> to set the visual health level at 50%. As a convenience method to calculate the proper position, we can use the following code:</p><pre class="crayon-plain-tag">local meterLevel = 0.25  -- 25% = 25/100 = 0.25
local maskPosition = filledUI.height * ( 1 - meterLevel )

filledUI.maskY = maskPosition</pre><p>Alternatively, you can achieve an animated fill effect by <a href=https://docs.coronalabs.com/api/library/transition/to.html target="_blank">transitioning</a> the mask&#8217;s position. Using a transition on the mask position is very similar to a typical positional transition, except in this case, we transition the <code>maskY</code> property, <strong>not</strong> the <code>y</code> property of the actual image:</p><pre class="crayon-plain-tag">transition.to( filledUI, { time = 1000, maskY = maskPosition } )</pre><p></p>
<h3>Conclusion</h3>
<p>As demonstrated, creating a stylish UI meter is simple and only requires the use of three elements, a simple calculation, and a direct set (or transition) of the underlying object&#8217;s mask position. If you wish to experiment with this code, you may copy/save the following images to your system as a basis for testing:</p>
<p><a href=/wordpress/wp-content/uploads/2015/09/outline.png><img class="size-full wp-image-63985 alignleft" style="margin: 20px;" src=/wordpress/wp-content/uploads/2015/09/outline.png alt="outline" width="100" height="200" /></a> <a href=/wordpress/wp-content/uploads/2015/09/filled.png><img class="size-full wp-image-63983 alignleft" style="margin: 20px;" src=/wordpress/wp-content/uploads/2015/09/filled.png alt="filled" width="100" height="200" /></a> <a href=/wordpress/wp-content/uploads/2015/09/mask.png><img class="size-full wp-image-63984 alignnone" style="margin: 20px;" src=/wordpress/wp-content/uploads/2015/09/mask.png alt="mask" width="108" height="208" /></a></p>
<hr style="clear: both;" />
]]></content:encoded>
			<wfw:commentRss>/blog/2015/09/08/tutorial-partially-filling-an-object/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>Tutorial: Animation with &#8220;enterFrame&#8221; listeners</title>
		<link>/blog/2015/08/25/tutorial-animation-with-enterframe-listeners/</link>
		<comments>/blog/2015/08/25/tutorial-animation-with-enterframe-listeners/#comments</comments>
		<pubDate>Tue, 25 Aug 2015 21:33:08 +0000</pubDate>
		<dc:creator><![CDATA[Rob Miracle]]></dc:creator>
				<category><![CDATA[Tutorials, Tips and Demos]]></category>
		<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[animation]]></category>
		<category><![CDATA[enterFrame]]></category>
		<category><![CDATA[tutorial]]></category>

		<guid isPermaLink="false">/?p=63809</guid>
		<description><![CDATA[In this tutorial, learn how to animate objects programmatically using Corona's "enterFrame" listener.]]></description>
				<content:encoded><![CDATA[<p>In Corona there are two methods of animation: <strong>sprite animation</strong> and <strong>procedural animation</strong>. Sprite animation (<a href=https://docs.coronalabs.com/guide/media/spriteAnimation/index.html target="_blank">guide</a>) involves using multiple frames (images) displayed in a cycle which gives the illusion of movement within the object. In contrast, procedural animation involves using programming techniques to move, rotate, scale or otherwise change the state of the object.</p>
<p>The previous tutorial outlined procedural animation using <strong>transitions</strong>. This week, we&#8217;ll discuss how to manipulate objects using <code>"enterFrame"</code> events.</p>
<h3>Overview</h3>
<p>When an app is running, Corona updates the screen either 30 times per second or 60 times per second, a concept known as <strong>frames per second</strong> or <strong>fps</strong>. You can control this rate via the <code>fps</code> value inside the app&#8217;s <code>config.lua</code> file (<a href=https://docs.coronalabs.com/guide/basics/configSettings/index.html target="_blank">guide</a>):</p><pre class="crayon-plain-tag">application = {
    content = {
        scale = &quot;letterbox&quot;,
        width = 320,
        height = 480,
        fps = 60,  -- 30 or 60
    },
}</pre><p>As the app runs, every time (frame) when Corona prepares to update the screen, it generates an event called <code>"enterFrame"</code> (<a href=https://docs.coronalabs.com/api/event/enterFrame/index.html target="_blank">reference</a>). Using this event in tandem with an <a href=https://docs.coronalabs.com/api/type/EventListener/index.html target="_blank">event listener</a>, you can animate an object by changing some aspect of it each frame.</p>
<h3>Basic setup</h3>
<p>Consider a classic game like <a href=https://en.wikipedia.org/wiki/Space_Invaders target="_blank">Space Invaders</a><sup>®</sup>. In this game, the aliens moved back and forth in a set pattern, and occasionally a special UFO would zoom across the top of the screen. Let&#8217;s illustrate how to move that UFO using an <code>"enterFrame"</code> listener:</p><pre class="crayon-plain-tag">local ufo = display.newCircle( 340, 15, 10 )

local timeToMove = 5  -- animate over 5 seconds
local fps = 60
local numberOfTicks = fps * timeToMove  -- i.e. 300 ticks
local finalDestination = -20
local distanceToMove = ufo.x - finalDestination  -- i.e 360 points
local pointsPerTick = distanceToMove / numberOfTicks  -- 1.2 points per tick</pre><p>This setup is probably a bit more verbose than you would write, but it&#8217;s useful to explain the math involved. Timing is based on clock/frame &#8220;ticks,&#8221; so in a 60 fps game, there will be 60 events fired per second. If we want to move our UFO across a 320 point screen over the course of 5 seconds, we must calculate exactly how much to move it on each tick.</p>
<h4>Points versus pixels</h4>
<p>Corona uses a virtual &#8220;content area&#8221; size defined in <code>config.lua</code> by <code>width</code> and <code>height</code> (see above). However, this will usually not &#8220;map&#8221; exactly to the <strong>pixel</strong> width on a real device. For example, the iPhone 6 screen is 750 pixels wide and the iPad Air screen is 1536 pixels wide. Thus, for frame-based animation of the UFO across the screen, it&#8217;s useful to convert each position change to <strong>points</strong>.</p>
<p>In this example, we have 300 total &#8220;ticks&#8221; to move the UFO across the screen, because the fps is 60 and we&#8217;ll move it over the time span of 5 seconds (<code>60 × 5 = 300</code>). The UFO begins at an <strong>x</strong> position of 340, which is 20 points off the right side of the content area (<code>320+20</code>), and its destination is an <strong>x</strong> position of -20, which is 20 points off the <em>left</em> side of the content area. Thus, the actual distance of movement will be 360 points (<code>340 − -20 = 360</code>). Since we need to know how many points to move the object each tick, we simply divide the distance by the number of ticks <code>(360/300)</code> to get a result of <code>1.2</code>.</p>
<h3>Using the &#8220;enterFrame&#8221; event</h3>
<p>Now that we have the calculations for moving the UFO, let&#8217;s write a function that will execute on every tick:</p><pre class="crayon-plain-tag">function ufo:enterFrame()
    self:translate( -pointsPerTick, 0 )
    if self.x &lt;= finalDestination then
        Runtime:removeEventListener( &quot;enterFrame&quot;, self )
    end
end

Runtime:addEventListener( &quot;enterFrame&quot;, ufo )</pre><p>Outside the function &#8212; in the final line of this example &#8212; we add the <code>"enterFrame"</code> event listener to the Runtime and pass in the <code>ufo</code> display object as the target. This will start the frame-based animation process.</p>
<p>For the function declaration, we &#8220;attach&#8221; the function to the UFO object using the <code>:</code> operator so that the object gets passed in. This is known as the Lua <strong>object method</strong>, and by doing so, we can access the UFO object within the function as <code>self</code>.</p>
<p>Inside the function, on each frame, we want to move the UFO to the left. Knowing the <code>pointsPerTick</code> value of <code>1.2</code>, its simply a matter of subtracting that from the object&#8217;s <strong>x</strong> using the <a href=https://docs.coronalabs.com/api/type/DisplayObject/translate.html target="_blank">object:translate()</a> API. The additional code checks when the UFO is past its final destination point of -20, at which point we remove the <code>"enterFrame"</code> event listener, effectively stopping movement of the UFO.</p>
<p>Of course this performs very simple motion along the <strong>x</strong> axis only, which could easily be done via a transition, but frame-based animation can potentially be used for more complex scenarios like moving an object in a pattern, moving enemies back and forth repeatedly, scrolling game backgrounds, etc.</p>
<h3>Delta time</h3>
<p>Note that when working with frame-based animation, it might be necessary to account for &#8220;delta&#8221; time fluctuations. This is because, internally, frames are not guaranteed to fire <em>precisely</em> on time, and depending on how much other activity is occurring in your app, this imprecision can affect the overall animation. If greater precision is required, please refer to this tutorial which outlines how to utilize delta time.</p>
<h3>Conclusion</h3>
<p>As you can see, <code>"enterFrame"</code> events provide yet another option for animating objects in Corona, in particular when the required animation is beyond the abilities of a single transition.</p>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2015/08/25/tutorial-animation-with-enterframe-listeners/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>Tutorial: Initializing a writable SQLite database</title>
		<link>/blog/2015/05/19/tutorial-initializing-a-writable-sqlite-database-from-a-read-only-database/</link>
		<comments>/blog/2015/05/19/tutorial-initializing-a-writable-sqlite-database-from-a-read-only-database/#comments</comments>
		<pubDate>Tue, 19 May 2015 22:25:54 +0000</pubDate>
		<dc:creator><![CDATA[Rob Miracle]]></dc:creator>
				<category><![CDATA[Tutorials, Tips and Demos]]></category>
		<category><![CDATA[Database]]></category>
		<category><![CDATA[SQL]]></category>
		<category><![CDATA[SQLite3]]></category>
		<category><![CDATA[tutorial]]></category>

		<guid isPermaLink="false">/?p=62790</guid>
		<description><![CDATA[In this tutorial, learn how to initialize a writable database that is pre-populated from a read-only database within your application bundle.]]></description>
				<content:encoded><![CDATA[<p>Working with SQLlite can be challenging, but one specific issue that Corona developers encounter is getting a pre-existing database into a location where data can be both read <strong>and</strong> inserted/updated.</p>
<p>The issue originates in the fact that when you create an application bundle for iOS or a APK file for Android, it&#8217;s a self-contained &#8220;folder&#8221; of files which gets installed to the device. This happens to be read-only, so you cannot update a database contained within it. This application bundle is effectively referenced in code as <a href=https://docs.coronalabs.com/api/library/system/ResourceDirectory.html target="_blank" rel="noopener">system.ResourceDirectory</a>.</p>
<p>In addition to <a href=https://docs.coronalabs.com/api/library/system/ResourceDirectory.html target="_blank" rel="noopener">system.ResourceDirectory</a>, your application has three folders which you <strong>can</strong> write files to, including updating a database within these folders. They are <a href=https://docs.coronalabs.com/api/library/system/DocumentsDirectory.html target="_blank" rel="noopener">system.DocumentsDirectory</a>, <a href=https://docs.coronalabs.com/api/library/system/CachesDirectory.html target="_blank" rel="noopener">system.CachesDirectory</a> and <a href=https://docs.coronalabs.com/api/library/system/TemporaryDirectory.html target="_blank" rel="noopener">system.TemporaryDirectory</a>. In the case of a database that you plan to update, the logical place for these is <a href=https://docs.coronalabs.com/api/library/system/DocumentsDirectory.html target="_blank" rel="noopener">system.DocumentsDirectory</a>. Why? Because unlike the &#8220;caches&#8221; and &#8220;temporary&#8221; folders, this folder is a persistent folder which will exist as long as the app remains installed on the device.</p>
<h3>Initializing the database</h3>
<p>When a user first installs your app, the <a href=https://docs.coronalabs.com/api/library/system/DocumentsDirectory.html target="_blank" rel="noopener">system.DocumentsDirectory</a> folder is essentially empty. If your app needs to access a database of initial information, you first need to move that database from the read-only space (<a href=https://docs.coronalabs.com/api/library/system/ResourceDirectory.html target="_blank" rel="noopener">system.ResourceDirectory</a>) into the &#8220;documents&#8221; folder where records can be inserted/updated. If it&#8217;s a very simple database, you could actually use Corona&#8217;s <a href=https://docs.coronalabs.com/api/library/sqlite3/index.html target="_blank" rel="noopener">sqlite3.*</a> calls to create an entirely <strong>new</strong> database within <a href=https://docs.coronalabs.com/api/library/system/DocumentsDirectory.html target="_blank" rel="noopener">system.DocumentsDirectory</a> and then insert your records. However, for a more complex database with multiple tables and a considerable number of records, this concept becomes more difficult and far less practical. As such, an easier approach is to copy the entire pre-existing database in one action.</p>
<p>Consider the following module named <code>copyDBto.lua</code>:</p><pre class="crayon-plain-tag">local M = {}

function M.copyDatabaseTo( filename, destination )
    assert( type(filename) == &quot;string&quot;, &quot;string expected for the first parameter but got &quot; .. type(filename) .. &quot; instead.&quot; )
    assert( type(destination) == &quot;table&quot;, &quot;table expected for the second paramter but bot &quot; .. type(destination) .. &quot; instead.&quot; )
    local sourceDBpath = system.pathForFile( filename, system.ResourceDirectory )
    -- io.open opens a file at path; returns nil if no file found
    local readHandle, errorString = io.open( sourceDBpath, &quot;rb&quot; )
    assert( readHandle, &quot;Database at &quot; .. filename .. &quot; could not be read from system.ResourceDirectory&quot; )
    assert( type(destination.filename) == &quot;string&quot;, &quot;filename should be a string, its a &quot; .. type(destination.filename) )
    print( type(destination.baseDir) )
    assert( type(destination.baseDir) == &quot;userdata&quot;, &quot;baseName should be a valid system directory&quot; )

    local destinationDBpath = system.pathForFile( destination.filename, destination.baseDir )
    local writeHandle, writeErrorString = io.open( destinationDBpath, &quot;wb&quot; )
    assert( writeHandle, &quot;Could not open &quot; .. destination.filename .. &quot; for writing.&quot; )

    local contents = readHandle:read( &quot;*a&quot; )
    writeHandle:write( contents )

    io.close( writeHandle )
    io.close( readHandle )
    return true
end

return M</pre><p>In the module&#8217;s primary function (<code>copyDatabaseTo()</code>), you pass in the name of the database which is assumed to be an existing database file within your app&#8217;s bundle (<a href=https://docs.coronalabs.com/api/library/system/ResourceDirectory.html target="_blank" rel="noopener">system.ResourceDirectory</a>). In addition, you pass a table which contains the <code>filename</code> and <code>baseDir</code> that you wish to move the database to, in this case <a href=https://docs.coronalabs.com/api/library/system/DocumentsDirectory.html target="_blank" rel="noopener">system.DocumentsDirectory</a> as discussed above:</p><pre class="crayon-plain-tag">local dbfunc = require( &quot;copyDBto&quot; )
local result = dbfunc.copyDatabaseTo( &quot;data.db&quot;, { filename=&quot;data.db&quot;, baseDir=system.DocumentsDirectory } )</pre><p>Assuming there are no errors, this will copy the entire database from your resources bundle to the writable folder you specified as the <code>filename</code> you defined. Of course, this action should only occur on the <strong>first</strong> run of the app so the database does not get replaced/overwritten every time.</p>
<p>Consider this more thorough implementation of the above 2 lines within <code>main.lua</code>:</p><pre class="crayon-plain-tag">local sqlite3 = require( &quot;sqlite3&quot; )
local dbfunc = require( &quot;copyDBto&quot; )
 
local filename = &quot;data.db&quot;
local baseDir = system.DocumentsDirectory
 
-- Open &quot;data.db&quot;. If the file doesn't exist, it will be created
local path = system.pathForFile( filename, baseDir )

local doesExist = io.open( path, &quot;r&quot; )
if not doesExist then
    local result = dbfunc.copyDatabaseTo( &quot;data.db&quot;, { filename=&quot;data.db&quot;, baseDir=system.DocumentsDirectory } )
    assert( result, &quot;Database failed to copy. Check the logs.&quot;)
else
    io.close( doesExist )
end

local db = sqlite3.open( path )   

-- Handle the &quot;applicationExit&quot; event to close the database
local function onSystemEvent( event )
    if ( event.type == &quot;applicationExit&quot; ) then              
        db:close()
    end
end

-- Print the table contents
for row in db:nrows( &quot;SELECT * FROM highscores&quot; ) do
    local text = row.name .. &quot; : &quot; .. row.score
    local t = display.newText( text, 120, 30*row.id, nil, 16 )
    t:setFillColor( 1, 0, 1 )
end
 
-- Setup the event listener to catch &quot;applicationExit&quot;
Runtime:addEventListener( &quot;system&quot;, onSystemEvent )</pre><p>On line 2, we <code>require()</code> the <code>copyDBto.lua</code> module. On lines 4 and 5, we set the name and target location of the database file and, on line 8, we create the internal path reference for it.</p>
<p>Lines 10-16 check to see if the database already exists where you expect it. If it doesn&#8217;t (first run), we call the function to copy the database on line 12. After that, we open the database and process it as usual &#8212; in this example, this includes a function to close the database if the user exits the app, and a test <code>for</code> loop to display some of the data from the database.</p>
<h3>Conclusion</h3>
<p>As you can see, it&#8217;s very easy to create a pre-existing and pre-populated database, bundle it within your app resources, and quickly copy it to a writable folder. Note that this functionality works equally well with text files and JSON files, both of which may also be used to track/store persistent data within an app like high scores, settings, and more.</p>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2015/05/19/tutorial-initializing-a-writable-sqlite-database-from-a-read-only-database/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>Tutorial: Responsive Real-Time Searching</title>
		<link>/blog/2015/05/12/tutorial-responsive-real-time-searching/</link>
		<comments>/blog/2015/05/12/tutorial-responsive-real-time-searching/#comments</comments>
		<pubDate>Tue, 12 May 2015 20:46:09 +0000</pubDate>
		<dc:creator><![CDATA[Charles McKeever]]></dc:creator>
				<category><![CDATA[Guest Bloggers]]></category>
		<category><![CDATA[Tutorials, Tips and Demos]]></category>
		<category><![CDATA[searching]]></category>
		<category><![CDATA[tutorial]]></category>

		<guid isPermaLink="false">/?p=62743</guid>
		<description><![CDATA[In this tutorial, learn a simple technique which you can use to implement real-time data searches that produce responsive feedback and updates in your apps.]]></description>
				<content:encoded><![CDATA[<p><em>Today&#8217;s guest tutorial comes to you courtesy of Corona Ambassador and Portland, Oregon app developer Ed Maurina. Ed is a regular contributor to the weekly <a href=/community/corona-geek/ target="_blank">Corona Geek</a> hangouts and an active member of the Corona community. He has developed games for REEL FX Studios and maintains his Corona SSK game development library. Check out his work and blog at <a href=http://roaminggamer.com/>RoamingGamer.com</a>.</em></p>
<hr />
<p>In this tutorial, we will discuss a simple technique which you can use to implement real-time data searches that produce responsive feedback and updates in your apps.</p>
<h3>The Challenge</h3>
<p>If you have ever tried to implement a real-time search, you will be aware that it can be difficult to maintain application responsiveness for large data sets and/or dynamically changing search criteria.</p>
<p>For example, your application may have these requirements:</p>
<ul>
<li>The app has a massive data set.</li>
<li>The data set needs to be searchable.</li>
<li>Searches need to execute as soon as a user starts entering the search criteria.</li>
<li>When the search criteria change, the search should automatically adjust in real-time.</li>
<li>Matching entries are returned as they are found, updating the app interface.</li>
<li>The app should remain responsive.</li>
</ul>
<p>The last requirement is critical. If your app hangs or has temporary hiccups while a search executes, you may as well not distribute it.</p>
<p>So, how to do this?</p>
<h3>The Sample App</h3>
<p>To demonstrate a solution to the general problem above, let me specify an exact application and then provide code which solves the problem.</p>
<p>This application will have the following features:</p>
<ul>
<li><strong>Large Data Set</strong> &#8212; A simple word list containing over 100,000 words.</li>
<li><strong>FPS Counter</strong> &#8212; A simple FPS counter will be shown at all times to give concrete proof of responsiveness.</li>
<li><strong>Search Field</strong> &#8212; A single text entry field (works on devices and in both Simulators).</li>
<li><strong>Progress Counters</strong> &#8212; Meters to show total words, words found, and current search index.</li>
<li><strong>Results List</strong> &#8212; A basic (non-scrollable list) of words as they are found.</li>
</ul>
<h3>The App Modules</h3>
<p>The <a href=https://github.com/roaminggamer/RG_FreeStuff/raw/master/AskEd/2015/05/responsiveSearches/code.zip target="_blank">sample code</a> has several modules, found in Lua files of the same name:</p>
<ul>
<li><code>common.lua</code> &#8212; Calculates and discovers useful variables and flags (<code>left</code>, <code>right</code>, <code>centerX</code>, <code>onSimulator</code>, etc.).</li>
<li><code>wordList.lua</code> &#8212; Generates the data set.</li>
<li><code>meter.lua</code> &#8212; Creates a framerate meter.</li>
<li><code>searchField.lua</code> &#8212; Creates a &#8220;text input field&#8221; for our search that will work on devices and both Simulators (also creates count and index counters).</li>
<li><code>example.lua</code> &#8212; The solution to the problem posed at the start of this article.</li>
</ul>
<h3>Initialize Search Settings</h3>
<p>Before we start the <code>"enterFrame"</code> listener, we need to initialize the module:</p>
<ol>
<li>Create and position initial results display group.</li>
<li>Initialize flags and variables to starting values.</li>
<li>Set how many comparisons we&#8217;re allowed to do per frame.</li>
</ol>
<p></p><pre class="crayon-plain-tag">function example.init( maxTime )
    -- 1.
    foundGroup = display.newGroup()
    foundGroup.y = com.top + 60

    -- 2.
    searching = false -- Not currently searching
    lastTerm = &quot;&quot; -- No search term yet.
    curIndex = 1 -- On first word in word list.
    foundCount = 0 -- No words found yet.

    -- 3.
    searchTime = maxTime or (1000/display.fps/2)
end</pre><p>Notice that in step #3, when we initialize the search code, if we don&#8217;t specify a specific time, the code automatically detects the FPS (as set in <code>config.lua</code>) and then calculates a time equal to half of one frame.</p>
<h3>The &#8220;enterFrame&#8221; Listener</h3>
<p>Once the module is initialized, we can define the <code>"enterFrame"</code> listener and start it running. The definition has five parts.</p>
<h4>Part 1 &#8212; Get the current search term and see if it has changed</h4>
<p></p><pre class="crayon-plain-tag">local searchTerm = searchField.getSearchTerm()
if ( lastTerm ~= searchTerm ) then
    example.resetResults()
    lastTerm = searchTerm
    searching = ( string.len( searchTerm ) &gt; 0 )
end</pre><p>If the search results have changed, we reset the search results (similar to initialization of module), take note of the new search term, and set flags saying that we are &#8220;searching.&#8221; If they have not, we simply ignore this bit of code and continue on.</p>
<h4>Part 2 &#8212; Abort if not &#8220;searching&#8221;</h4>
<p></p><pre class="crayon-plain-tag">if ( not searching ) then return end</pre><p>If the <code>searching</code> flag is set to false, we abort early and wait for the next frame to start again.</p>
<h4>Part 3 &#8212; Search until we are out of time, or at the end of the word list</h4>
<p>While each of the above modules may be useful and interesting, we will focus only on <code>example.lua</code>.</p>
<h4>The Solution</h4>
<p>After this build up, you may be disappointed to see that this is basically a self-regulating <code>"enterFrame"</code> listener. In a nutshell, the listener starts a new search whenever the search criteria change and searches in a tight loop till a set amount of time passes. It then stops searching and exits. On the next frame, the entire sequence starts again.</p>
<p>The listener has this logical structure:</p>
<p><img class="wp-image-62745 size-full" style="margin: 0px 0px 20px 0px;" src="/wordpress/wp-content/uploads/2015/05/responsive-real-time-searching-diagram.png" alt="Responsive Real-time Searching Logic Flowchart" width="606" height="547" /></p>
<p>Now let&#8217;s look at the actual code.</p><pre class="crayon-plain-tag">local getTimer = system.getTimer -- localize for speedup
local strLower = string.lower -- localize for speedup
local startTime = getTimer()
local elapsedTime = 0

while ( elapsedTime &lt; searchTime and curIndex &lt;= #wordList ) do
    local curWord = wordList[curIndex]
    if ( string.match( strLower(curWord), strLower( searchTerm ) ) ~= nil ) then
        example.drawResult( curWord )
    end
    elapsedTime = getTimer() - startTime
    curIndex = curIndex + 1
end</pre><p>This code:</p>
<ul>
<li>Localizes some useful functions for an execution speedup.</li>
<li>Takes note of the <code>startTime</code>.</li>
<li>Sets <code>elapsedTime</code> to zero.</li>
<li>Enters a search loop and does not exit until it get to the end of the list or runs out of time.</li>
<li>Upon finding match, the code displays it, and continues.</li>
</ul>
<p>This is the meat of the solution and you should understand that by measuring &#8220;elapsed time&#8221; each time we search and (possibly) display results, we ensure that:</p>
<ol>
<li>The search can give us as soon as it needs to and not block the completion of this frame.</li>
<li>The code that stops and resumes searching is dynamic and takes into account the cost of the search and displaying the results.</li>
</ol>
<h4>Part 4 &mdash; Update the search index label</h4>
<p></p><pre class="crayon-plain-tag">searchField.setSearchIndex( curIndex )</pre><p>(<em>Note that this part is purely for feedback in the example</em>)</p>
<h4>Part 5 &mdash; Check to see if we reached the end of list, and quit if so</h4>
<p></p><pre class="crayon-plain-tag">searching = curIndex &lt; #wordList</pre><p>As a final step in the listener, we check to see if the end of the word list was reached. If it was, we set <code>searching</code> to false. In either case, we drop out of the function (it will execute again at the beginning of the next frame).</p>
<h3>In Conclusion</h3>
<p>As I mentioned above, this blog post <a href=https://github.com/roaminggamer/RG_FreeStuff/raw/master/AskEd/2015/05/responsiveSearches/code.zip target="_blank">comes with sample code</a>, so please experiment with it in your own apps. Hopefully this tutorial has shown you an interesting methodology to implement real-time, responsive searching in your project.</p>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2015/05/12/tutorial-responsive-real-time-searching/feed/</wfw:commentRss>
		<slash:comments>6</slash:comments>
		</item>
		<item>
		<title>Tutorial: The Finalize API (an Unsung Hero)</title>
		<link>/blog/2015/05/05/tutorial-the-finalize-api-an-unsung-hero/</link>
		<comments>/blog/2015/05/05/tutorial-the-finalize-api-an-unsung-hero/#comments</comments>
		<pubDate>Tue, 05 May 2015 22:43:20 +0000</pubDate>
		<dc:creator><![CDATA[Brent Sorrentino]]></dc:creator>
				<category><![CDATA[Guest Bloggers]]></category>
		<category><![CDATA[Tutorials, Tips and Demos]]></category>
		<category><![CDATA[event listeners]]></category>
		<category><![CDATA[finalize]]></category>
		<category><![CDATA[tutorial]]></category>

		<guid isPermaLink="false">/?p=62646</guid>
		<description><![CDATA[In this tutorial, learn about the under-utilized but powerful "finalize" event and how it can be used to keep your app running smoothly.]]></description>
				<content:encoded><![CDATA[<p><em>Jason Schroeder is a New York City-based app developer and Corona Ambassador who has released seven Corona-made apps since he began using Corona SDK in 2011. He is currently working on an independent reboot of the 21-year-old Abrosia Software game “Chiral,” which he expects to release later this year. You can follow Jason on Twitter <strong>@schroederapps</strong> and learn more about Chiral at <a href=http://www.chiralgame.com/ target="_blank">www.chiralgame.com</a>.</em></p>
<hr />
<p>There are over 1,000 Lua APIs for Corona SDK, according to the API Reference. While certain APIs, such as those found in the <a href=https://docs.coronalabs.com/api/library/display/index.html target="_blank">display</a>, <a href=https://docs.coronalabs.com/api/library/audio/index.html target="_blank">audio</a>, and <a href=https://docs.coronalabs.com/api/library/composer/index.html target="_blank">composer</a> libraries are so essential that even the most &#8220;newbie&#8221; developers become instantly familiar with them, there&#8217;s a huge advantage to be gained by regularly browsing the online documentation and discovering hidden gems that you may not have noticed when teaching yourself the basics. One great example of this is the <a href=https://docs.coronalabs.com/api/event/finalize/index.html target="_blank">finalize</a> event API, which gets scandalously little recognition given how useful it is.</p>
<h3>About Events</h3>
<p>Every Corona display object can (and does) dispatch “events” (which take the form of Lua tables) on a regular basis, even if you aren&#8217;t aware of these events or aren&#8217;t responding to them in your code. For example, if a user touches a display object, that object always dispatches an event table containing key/value pairs such as a reference to the dispatching object (<code>event.target</code>) and the coordinates where the user&#8217;s finger is touching the screen (<code>event.x</code> and <code>event.y</code>), among others. By adding a listener function to handle these dispatched events using the <a href=https://docs.coronalabs.com/api/type/EventListener/addEventListener.html target="_blank">object:addEventListener()</a> API, you can make your app respond to this user input. But even if you don&#8217;t add a listener for them, every display object in your app is dispatching &#8220;touch&#8221; events anytime the user&#8217;s finger happens to touch them.</p>
<p>Not unlike touch events, any time a display object is removed from the stage &#8212; usually by calling <a href=http://docs.coronalabs.com/api/library/display/remove.html target="_blank">display.remove()</a> or <a href=http://docs.coronalabs.com/api/type/DisplayObject/removeSelf.html target="_blank">object:removeSelf()</a> &#8212; that object dispatches a <a href=https://docs.coronalabs.com/api/event/finalize/index.html target="_blank">finalize</a> event. I&#8217;d imagine that many Corona developers don&#8217;t bother handling these events, but being able to perform specific actions just as a display object is being destroyed has all sorts of useful applications. I&#8217;ll explore one specific example later on in this post, but first let&#8217;s go over how to listen for finalize events and handle the data that gets passed into our listener function.</p>
<h3>Listening for Finalize Events</h3>
<p>Just like touch listeners, a finalize listener can take the form of a “table listener” or a “function listener.” For the purposes of this tutorial, I&#8217;m going to focus on using a table listener because it&#8217;s my preferred method &#8212; but either type of listener will work, and you should use whatever method works best for you. If you don’t know the difference between these types of listeners, you can read more about it <a href=http://docs.coronalabs.com/daily/guide/events/detectEvents/index.html?#functionvstable target="_blank">here</a>.</p>
<p>Listening for finalize events requires 3 basic steps. First, we create our listener function:</p><pre class="crayon-plain-tag">local function finalizeListener( self, event )
   -- do something when &quot;self&quot; is removed from the stage
   print( &quot;Object removed from stage: &quot;..tostring(self) )
end</pre><p>Next, we add a <code>.finalize</code> property to a display object, pointing to our listener function:</p><pre class="crayon-plain-tag">object.finalize = finalizeListener</pre><p>And finally, we add an event listener to that same object, listening for <code>"finalize"</code> events:</p><pre class="crayon-plain-tag">object:addEventListener( &quot;finalize&quot; )</pre><p>Now, whenever that display object is removed from the stage, our listener function will be triggered, and the console will print out the string <code>"Object removed from stage:"</code> followed by the object&#8217;s table ID.</p>
<h3>Why You Should Use Finalize Listeners</h3>
<p>The code above shows <i>how</i> to listen for finalize events and respond to them, but it doesn&#8217;t really showcase why this is so useful. Honestly, the potential applications of finalize listeners are only limited by your imagination, and the usefulness will depend on the needs of your app &#8212; but let’s look at one specific scenario where a finalize listener can help keep your app running smoothly.</p>
<p>In some cases, you may need to have a display object update itself on every single frame of your app. For example, you could have a text object that displays the user&#8217;s score that needs to be constantly updated, or you might have a character sprite that needs to be repositioned on every frame to keep it centered on the screen. The best way to accomplish these continual updates is through a Runtime <a href=http://docs.coronalabs.com/api/event/enterFrame/index.html target="_blank">enterFrame</a> listener, which is a function that is called every time your app draws a new &#8220;frame.&#8221;</p>
<p>While <a href=http://docs.coronalabs.com/api/event/enterFrame/index.html target="_blank">enterFrame</a> listeners are great tools because they can be run as often as 60 times per second, they can also wreak havoc if you have any errors in your code. And if you attempt to manipulate a display object that has been destroyed in an <a href=http://docs.coronalabs.com/api/event/enterFrame/index.html target="_blank">enterFrame</a> listener (or any <code>nil</code> object), you&#8217;re going to get hit with a show-stopping Runtime error. This is avoided by removing your <a href=http://docs.coronalabs.com/api/event/enterFrame/index.html target="_blank">enterFrame</a> listener before it can attempt to manipulate your soon-to-be-removed display object. While it’s possible to manage this manually, removing <a href=http://docs.coronalabs.com/api/event/enterFrame/index.html target="_blank">enterFrame</a> listeners in the same block of code that destroys your display object, you can save yourself time and headaches by utilizing finalize listeners to automate this process for you, especially in circumstances where you will be removing lots of objects with regularity.</p>
<p>Below is a simple <code>main.lua</code> that creates an app that does the following:</p>
<p>It creates a circle that can be dragged around the screen.</p>
<p>It uses an <a href=http://docs.coronalabs.com/api/event/enterFrame/index.html target="_blank">enterFrame</a> listener to resize the circle as it is dragged, depending on how close it is to the center of the screen</p>
<p>Releasing your finger from the circle will remove the circle from the stage, using <a href=https://docs.coronalabs.com/api/library/display/remove.html target="_blank">display.remove()</a> and re-draw a new circle 500 milliseconds later.</p><pre class="crayon-plain-tag">-- forward declare functions
local onEnterFrame, finalizeListener, touchListener, createCircle

-- function to calculate distance between two points
local function getDistance ( x1, y1, x2, y2 )
   local dx = x1 - x2
   local dy = y1 - y2
   return math.sqrt ( dx * dx + dy * dy )
end

-- enterFrame listener
function onEnterFrame( self, event )
   local distance = getDistance( self.x, self.y, display.contentCenterX, display.contentCenterY )
   local scale = 1 - distance*.005
   self.xScale, self.yScale = scale, scale
end

-- finalize listener
function finalizeListener( self, event )
   Runtime:removeEventListener( &quot;enterFrame&quot;, self )
   print( &quot;Removed enterFrame Listener for &quot;..tostring(self) )
   timer.performWithDelay( 500, createCircle )
end

-- touch listener
function touchListener( self, event )
   if event.phase == &quot;began&quot; then
      display.getCurrentStage():setFocus( self, event.id )
      self.hasFocus = true
   elseif self.hasFocus then
      self.x, self.y = event.x, event.y
      if event.phase == &quot;ended&quot; or event.phase == &quot;cancelled&quot; then
         self.hasFocus = false
         display.getCurrentStage():setFocus( nil, event.id )
         display.remove( self )
      end
   end
end

-- function to create a new circle and add listeners to it
function createCircle()
   local circle = display.newCircle( display.contentCenterX, display.contentCenterY, display.contentHeight*.075 )
   circle.finalize = finalizeListener
   circle:addEventListener( &quot;finalize&quot; )
   circle.enterFrame = onEnterFrame
   Runtime:addEventListener( &quot;enterFrame&quot;, circle )
   circle.touch = touchListener
   circle:addEventListener( &quot;touch&quot; )
end

-- create the first circle
createCircle()</pre><p>Since there is an <a href=http://docs.coronalabs.com/api/event/enterFrame/index.html target="_blank">enterFrame</a> listener used to manipulate the circle, the app will crash if that function is run after removing the circle from the stage. To see this in action, simply comment out line 43 from the code above and run it in the Corona Simulator. As soon as you release your finger from the circle and the circle is removed, you’ll get the following Runtime error:</p>
<p><a href=/wordpress/wp-content/uploads/2015/05/finalize-error1.png><img class="alignnone wp-image-62653" src=/wordpress/wp-content/uploads/2015/05/finalize-error1.png alt="finalize-error" width="800" height="338" /></a></p>
<p>This crash occurs because line 43 is necessary to add our finalize listener to the circle, ensuring that the <a href=http://docs.coronalabs.com/api/event/enterFrame/index.html target="_blank">enterFrame</a> listener is removed when the circle is destroyed. That little listener function is mighty helpful! Keep in mind, also, that the finalize listener in the above code is re-usable: you can add it to any display objects (not just the circle) by setting an object’s <code>.finalize</code> property to &#8220;<code>finalizeListener"</code> and adding a &#8220;<code>finalize"</code> event listener to that object. If your app creates a lot of objects that need to be updated in an <a href=http://docs.coronalabs.com/api/event/enterFrame/index.html target="_blank">enterFrame</a> listener, having just one finalize listener to handle cleanup of those <a href=http://docs.coronalabs.com/api/event/enterFrame/index.html target="_blank">enterFrame</a> listeners can be a real sanity-saver.</p>
<h3>In Conclusion</h3>
<p>This just shows one possible application of finalize listeners, but I hope it gets you thinking about ways you can use Corona’s 1,000+ APIs to streamline your code and help make your development work faster and easier to manage. If you have come up with any especially creative uses of the finalize event API, please share in the comments &#8212; happy coding!</p>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2015/05/05/tutorial-the-finalize-api-an-unsung-hero/feed/</wfw:commentRss>
		<slash:comments>4</slash:comments>
		</item>
		<item>
		<title>Tutorial: Working With a Grid Layout</title>
		<link>/blog/2015/04/07/tutorial-working-with-a-grid-layout/</link>
		<comments>/blog/2015/04/07/tutorial-working-with-a-grid-layout/#comments</comments>
		<pubDate>Tue, 07 Apr 2015 22:09:54 +0000</pubDate>
		<dc:creator><![CDATA[Rob Miracle]]></dc:creator>
				<category><![CDATA[Tutorials, Tips and Demos]]></category>
		<category><![CDATA[grid]]></category>
		<category><![CDATA[tutorial]]></category>

		<guid isPermaLink="false">/?p=62021</guid>
		<description><![CDATA[In this tutorial, learn how to position and move objects on a board for games like chess, checkers, and other grid-based games.]]></description>
				<content:encoded><![CDATA[<p>Many games use a grid where pieces or items are positioned in rows and columns. Classic examples would be chess or checkers, but even more modern games like <em>Candy Crush</em>™ position the pieces in a grid as well.</p>
<p>Mechanically, a grid is nothing more than a two-dimensional array, and each element in the array represents a single spot on the grid. In Lua, two-dimensional arrays are basically a table in which each child table represents a row for the grid, and each entry in that row table represents a column index within the row.</p>
<p>Let&#8217;s look at the core Lua code used in a <a href=https://www.dropbox.com/s/zg4ep4zhnbh1h3w/GridProject.zip?dl=0 target="_blank" rel="noopener">demo project</a> which you should download and experiment with alongside this tutorial.</p>
<p>View the code on <a href=https://gist.github.com/8387deec14650adf03a4>Gist</a>.</p>
<p>First, we define some constants: the number of rows and columns as <code>GRID_WIDTH</code> and <code>GRID_HEIGHT</code> respectively. We also define the width and height of each cell on the grid as <code>CELL_WIDTH</code> and <code>CELL_HEIGHT</code>. Following this, we create an empty table for the overall grid, then we execute a loop for the total number of rows in the grid (<code>GRID_HEIGHT</code>) and, in that index position, we create another empty table which will represent the overall row.</p>
<p>Next, we place the grid&#8217;s image on the screen and position it in the center of the content area. Then we create two more constants for offsetting pieces relative to the image. Here, we calculate <code>gbOffsetX</code> and <code>gbOffsetY</code> based on the grid image&#8217;s location and size.</p>
<h3>Referencing Cells</h3>
<p>Because we have effectively created a &#8220;stack of rows,&#8221; a specific cell must be referenced in a <code>[row][column]</code> manner as follows:</p>
<p><code>local somePiece = grid[4][5]</code></p>
<p>This code will reference the cell 5 positions from the left (5th column) and 4 positions from the top (4th row). Thus, the row value comes first and the column value second.</p>
<p>Now conceptually, it may be more logical to reference cell positions as an <code>x,y</code> coordinate position, or in other words, a &#8220;column, row&#8221; format. For example, the top-left space on a checkers board would be <code>1,1</code> and the top-right space would be <code>8,1</code> (remember that checkers uses an 8×8 board). Thus, when calling the <code>spawnPiece()</code> function, two parameters, <code>xPos</code> and <code>yPos</code>, are expected to represent the position in the grid.</p>
<h3>Spawning Pieces</h3>
<p>Within the actual <code>spawnPiece()</code> function, we first validate the parameters passed in. This includes checking the piece type and ensuring that the cell position is not outside the range (size) of the grid. If the validation succeeds, we generate the piece&#8217;s display object and store the piece&#8217;s position on the board as attributes of that object. Finally, we place the piece in the actual screen position (pixel coordinates) based on the constants we defined earlier.</p>
<h3>Moving Pieces</h3>
<p>The next function is used to move a piece. In this example, we test this function by calling it after a timer of 2 seconds, but this would likely be done via a touch, swipe, selecting the piece and tapping its destination, or any number of other methods.</p>
<p>In any case, within the <code>movePiece()</code> function, we first validate that the requested position is within range of the grid and confirm that the position is not occupied by another piece. If the validation passes, we move the piece&#8217;s position within the <code>grid</code> table and then visually slide (transition) the piece to the new position.</p>
<h3>Conclusion</h3>
<p>As shown in this tutorial, it&#8217;s simple to use a two-dimensional array to create a grid, store the position of pieces within the array, and use basic math to position and move the visual pieces based on logical coordinates. Remember to download the <a href=https://github.com/coronalabs/GridLayout target="_blank" rel="noopener">demo project</a> to experiment with and edit for use in your own grid-based app project.</p>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2015/04/07/tutorial-working-with-a-grid-layout/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>Tutorial: Using Coroutines in Corona</title>
		<link>/blog/2015/02/10/tutorial-using-coroutines-in-corona/</link>
		<comments>/blog/2015/02/10/tutorial-using-coroutines-in-corona/#comments</comments>
		<pubDate>Tue, 10 Feb 2015 22:23:48 +0000</pubDate>
		<dc:creator><![CDATA[Brent Sorrentino]]></dc:creator>
				<category><![CDATA[Guest Bloggers]]></category>
		<category><![CDATA[Tutorials, Tips and Demos]]></category>
		<category><![CDATA[coroutine]]></category>
		<category><![CDATA[tutorial]]></category>

		<guid isPermaLink="false">/?p=61368</guid>
		<description><![CDATA[Coroutines, one of Lua's key features, are quite powerful and give you the ability to start and stop blocks of code as needed. From advanced timer manipulation to creating state machines, coroutines give you greater control over when parts of your code execute. This tutorial touches on just a few of their many uses, in particular those which play to Corona's own strengths.]]></description>
				<content:encoded><![CDATA[<p><em>Today&#8217;s guest tutorial comes to you courtesy of Steven Johnson, the Technical Director and head of R&amp;D at Xibalba Studios. Steven has been using Lua since 2003 and he has worked with custom engines, Vision SDK, LÖVE, HTML5 emulation, and projects with SDL bindings in C++ and LuaJIT. When he&#8217;s not working on his own hobby projects, he likes to research math and graphics concepts.</em></p>
<hr />
<p>Coroutines, <a href=http://www.jucs.org/jucs_10_7/coroutines_in_lua/de_Moura_A_L.html target="_blank">introduced in Lua 5.0</a>, are one of the language&#8217;s key features, but despite having been available in Corona from the beginning, they seem to receive very little attention. This is unfortunate, as coroutines are quite powerful, giving you the ability to start and stop blocks of code as needed. Whether you want to do advanced timer manipulation or create state machines, coroutines give you greater control over when the parts of your code execute. This tutorial will touch on just a few of their many uses, in particular those which play to Corona&#8217;s own strengths.</p>
<h3><a name="basics"></a>The Basics</h3>
<p>Let&#8217;s begin with a quick primer on the API. All functions are found in the <b>coroutine</b> table. As of this writing, these have not been included in Corona&#8217;s SDK API reference, but may be found in the <a href=http://www.lua.org/manual/5.1/manual.html?#5.2 target="_blank">Lua manual</a>.</p>
<p>Creating a coroutine is simple enough:</p><pre class="crayon-plain-tag">-- This is the &quot;routine&quot; part of the coroutine, the code that gets run...
local function Body()
    print( &quot;In the coroutine!&quot; )
end

-- ...and this is the object we need to run it.
local co = coroutine.create( Body )</pre><p>This gives us a reference, <code>co</code>, to the coroutine.</p>
<p>We can inspect its type:</p><pre class="crayon-plain-tag">print( type( co ) )  -- prints &quot;thread&quot;</pre><p>What we find is that <code>co</code> is a distinct kind of object, rather than a table or userdata as we might expect. Don&#8217;t worry too much about the term &#8220;thread&#8221;; in Lua, it and &#8220;coroutine&#8221; are mostly interchangeable<a name="from_note1"></a><a href="#note1">[1]</a>. Also, these are <b>not </b>operating system threads, which preempt running code to switch tasks. Rather, coroutines are collaborative; the coroutine itself decides when to give up control.</p>
<p>We can also ask about the coroutine&#8217;s status:</p><pre class="crayon-plain-tag">print( coroutine.status( co ) )  -- prints &quot;suspended&quot;</pre><p>As we can see, simply creating the coroutine doesn&#8217;t run it. This shouldn&#8217;t be too surprising. Creating a function, for instance, is distinct from calling it. To run the coroutine, we must do this:</p><pre class="crayon-plain-tag">coroutine.resume( co )  -- prints &quot;In the coroutine!&quot;</pre><p>The body executes, and the message inside gets printed, as expected.</p>
<p>What is the coroutine&#8217;s status now? Let&#8217;s check:</p><pre class="crayon-plain-tag">print( coroutine.status( co ) )  -- prints &quot;dead&quot;</pre><p>The body has run its course, so nothing remains for the coroutine to do, and it goes dead.</p>
<p>Once a coroutine is dead, all we can do with it is ask its status, which will always be <code>"dead"</code>. If we try to resume it once more, nothing happens. Or rather, as we&#8217;ll see shortly, it fails silently.</p>
<p>At this point, coroutines seem like nothing more than a complicated way to call a function once, and only once!</p>
<p>The missing piece of the puzzle is the ability to yield:</p><pre class="crayon-plain-tag">local function Body()
    print( &quot;First resume&quot; )

    coroutine.yield()

    print( &quot;Second resume&quot; )

    coroutine.yield()

    print( &quot;Final resume&quot; )
end

local co = coroutine.create( Body )

coroutine.resume( co )  -- prints &quot;First resume&quot;

print( &quot;After first yield&quot; )

coroutine.resume( co )  -- prints &quot;Second resume&quot;

print( &quot;After second yield&quot; )

coroutine.resume( co )  -- prints &quot;Final resume&quot;</pre><p>The first <code>coroutine.resume</code> kicks off the coroutine. The code at the beginning of the body executes, and a message is printed. So far, nothing new.</p>
<p>When the <code>coroutine.yield</code> fires, we suddenly hop outside of the coroutine&#8217;s body and back among the code that created it. Instead of getting the message <b>&#8220;Second resume&#8221;</b>, we see <b>&#8220;After first yield&#8221;</b>.</p>
<p>The coroutine is once again in a suspended state, just as it was after being created. It is <b>not</b> dead; there is still code left to execute. However, the coroutine won&#8217;t run again until we explicitly resume it.</p>
<p>When we do so, execution picks up where it left off, immediately after the yield, and we get the expected <b>&#8220;Second resume&#8221;</b>. Another yield and a final resume round out the snippet, giving us <b>&#8220;After second yield&#8221;</b> followed by <b>&#8220;Final resume&#8221;</b>.</p>
<p>After each of the yields, the status will be <code>"suspended"</code>. After the final resume, our coroutine is once again <code>"dead"</code>.</p>
<h3><a name="data"></a>Working With Data</h3>
<p>It&#8217;s possible to pass data to and from a coroutine. We can send values to the coroutine by passing them as arguments to <code>coroutine.resume</code>:</p><pre class="crayon-plain-tag">local function Body( a, b, c )
    DoSomething()

    local d, e = coroutine.yield()

    DoSomethingElse()

    local f, g, h = coroutine.yield()

    DoOneLastThing()
end

local co = coroutine.create( Body )

coroutine.resume( co, &quot;one&quot;, 2 )  -- a = &quot;one&quot;, b = 2, c = nil
coroutine.resume( co, 8, {} )  -- d = 8, e = the table
coroutine.resume( co, 42, 9 )  -- f = 42, g = 9, h = nil</pre><p>As we see, on the very first resume (the one which kicks the coroutine off, after creation), the data winds up in the parameters. On each subsequent resume, they instead show up as return values of the most recent <code>coroutine.yield</code>.</p>
<p>Receiving isn&#8217;t too different, but we go through <code>coroutine.yield</code> instead:</p><pre class="crayon-plain-tag">local function Body()
    DoSomething()

    coroutine.yield( 1, &quot;3&quot; )

    DoSomethingElse()

    coroutine.yield( { n = 6 }, 7, 4 )

    DoOneLastThing()

    return &quot;Data&quot;, 1
end

local co = coroutine.create( Body )

print( coroutine.resume( co ) )  -- prints true, 1, &quot;3&quot;
print( coroutine.resume( co ) )  -- prints true, something about the table, 7, 4
print( coroutine.resume( co ) )  -- prints true, &quot;Data&quot;, 1</pre><p>Here we see that any arguments passed to <code>coroutine.yield</code> end up as return values of the most recent <code>coroutine.resume</code>, as do any values returned from the coroutine body.</p>
<p>(<b>Programming in Lua</b> contains an <a href=http://www.lua.org/pil/9.2.html target="_blank">excellent example</a> of data-passing in action.)</p>
<p>Now, there&#8217;s something peculiar about the yield snippet. In the printed results, what does that <code>true</code> mean? It indicates that the resume was successful. Had an error occurred along the way, that <code>true</code> would be a <code>false</code> instead, the only other return value being an error message. When I mentioned before how resuming a dead coroutine fails silently, this is what is happening.</p>
<p>And speaking of dead coroutines, that&#8217;s what we&#8217;re stuck with, following an error.</p>
<h3><a name="wrap"></a>Wrapping Up</h3>
<p>We&#8217;ll often only need to create, resume, and yield a coroutine. This is common enough that a convenience function, <code>coroutine.wrap</code>, is provided in order to make coroutines more friendly to use:</p><pre class="crayon-plain-tag">local function Body()
    print( &quot;First resume&quot; )

    coroutine.yield()

    print( &quot;Second resume&quot; )

    coroutine.yield()

    print( &quot;Final resume&quot; )
end

local wrapped = coroutine.wrap( Body )

wrapped()  -- prints &quot;First resume&quot;
wrapped()  -- prints &quot;Second resume&quot;
wrapped()  -- prints &quot;Final resume&quot;</pre><p>This resembles our earlier examples, except resuming the coroutine seems to behave like a regular function call. In fact, the wrapper <b>is </b>just a function; <code>coroutine.resume</code> is taken care of behind the scenes, together with the coroutine reference itself.</p>
<p>Passing data around works much as before, except unlike <code>coroutine.resume</code>, the wrapper doesn&#8217;t return a success boolean. So what if it fails? For instance, in the last example, if we were to call the wrapper once more, now that the coroutine has finished?</p>
<p><a href=/wordpress/wp-content/uploads/2015/02/crash.jpg><img class=" size-full wp-image-61372 aligncenter" src=/wordpress/wp-content/uploads/2015/02/crash.jpg alt="crash" width="320" height="242" /></a></p>
<p><strong>&#8220;KERBLOOEY!&#8221;</strong></p>
<p>Of course, when developing in Corona, this is generally what we&#8217;ll want. It&#8217;s an error like any other. With all of this under our belt, we&#8217;re ready to advance.</p>
<h3><a name="tagteam"></a>The Coroutine-Timer Tag Team</h3>
<p><code>coroutine.wrap</code> offers some interesting possibilities. In particular, the wrapper being just a function opens some doors for us. Many Corona APIs, the various event listeners for instance, take function arguments, and will happily accept our coroutine-in-disguise.</p>
<p>Now, presumably we would favor coroutines over regular functions because we want the yield capability. Once we yield, however, the rest of the coroutine won&#8217;t happen, unless the wrapper gets called again (remember, doing this just performs a resume, under the hood). Therefore, we&#8217;ll typically want to use coroutines in logic that we expect to trigger multiple times.<a name="from_note2"></a><a href="#note2">[2]</a></p>
<p>As it happens, we have many such mechanisms in Corona. Timers, for instance:</p><pre class="crayon-plain-tag">local function Body()
    print( &quot;First resume&quot; )

    coroutine.yield()

    print( &quot;Second resume&quot; )

    coroutine.yield()

    print( &quot;Final resume&quot; )
end

timer.performWithDelay( 1000, coroutine.wrap( Body ), 3 )</pre><p>As you might imagine, this will fire every second or so, printing one of the now-familiar messages each time. This is all well and good, but notice the iteration count: <strong>three</strong> iterations. Two for the yields and one more to run the final leg. If we overestimate this count, say by specifying four iterations, we&#8217;ll end up trying to resume a dead coroutine. The code above is quite simple, so this isn&#8217;t a huge worry.</p>
<p>As our coroutine body grows larger, it becomes increasingly difficult to maintain a correct count, especially when the yields are in loops or behind function calls. Once we bring <code>if</code> statements into the mix, we can&#8217;t even depend on a fixed number, and then we&#8217;re completely out of luck.</p>
<p>We really want something that &#8220;just works&#8221;. Fortunately, <code>"timer"</code> events come packaged with a reference, <a href=http://docs.coronalabs.com/api/event/timer/source.html target="_blank">source</a>, which can be used to cancel the corresponding timer. Rather than hard-coding some number of iterations, we can simply let the timer run indefinitely, only canceling it once we&#8217;ve finished our task.</p>
<p>A first attempt might go something like this:</p><pre class="crayon-plain-tag">local function Body( event )
    DoSomething()

    coroutine.yield()

    DoSomethingElse()

    timer.cancel( event.source )
end

timer.performWithDelay( 50, coroutine.wrap( Body ), 0 )</pre><p>And this will work&#8230; until it doesn&#8217;t. Unfortunately, coroutines flush out a <a href=http://en.wikipedia.org/wiki/Leaky_abstraction target="_blank">leaky abstraction</a>: Corona is recycling the event tables. Presumably this is to avoid garbage collector spikes, and is a great idea. With normal functions, we would never know the difference. But we&#8217;re being naughty. By yielding, we end up holding on to that event table across multiple frames. Meanwhile, Corona has been passing the table around, swapping timer references in and out. When it comes time to deal with &#8220;our&#8221; timer, we might cancel a different one altogether!</p>
<p>We can play nice by saving the reference up front:</p><pre class="crayon-plain-tag">local function Body( event )
    local source = event.source

    DoSomething()

    coroutine.yield()

    DoSomethingElse()

    timer.cancel( source )
end

timer.performWithDelay( 50, coroutine.wrap( Body ), 0 )</pre><p>This does work. However, the <code>"timer"</code> event also contains <b>count</b> and <b>time</b> fields, and similar issues crop up.</p>
<p>We can account for these too. Our code probably won&#8217;t care where the event table came from (and as we just saw, it shouldn&#8217;t), and will be none the wiser if we give it a &#8220;shadow&#8221; table.<a name="from_note3"></a><a href="#note3">[3]</a> We update this shadow table instead, and all is well again.</p>
<h3><a name="timerutil"></a>A Timer Utility</h3>
<p>Figuring these things out each time is going to get old. For that matter, most coroutine-based timers are going to have the same &#8220;look&#8221; to them, once we do get these details in order. We ought to roll this all up for reuse:</p><pre class="crayon-plain-tag">function CoroPerformWithDelay( delay, func, n )
    local wrapped = coroutine.wrap( function( event )
        func( event )  -- Do the action...

        return &quot;cancel&quot;  -- ...then tell the timer to die when we're done.
    end )

    local event2  -- Our &quot;shadow&quot; event.

    return timer.performWithDelay( delay, function( event )
        event2 = event2 or { source = event.source }  -- On first run, save source...

        event2.count = event.count  -- ...update these every time.
        event2.time = event.time

        local result = wrapped( event2 )  -- Update the coroutine. It will pick up the event on the first run.

        if result == &quot;cancel&quot; then
            timer.cancel( event2.source )  -- After func completes, or on a cancel request, kill the timer.
        end
    end, n or 0 )
end</pre><p>Now, we&#8217;ve been looking at timers, but the same ideas extend to <code>"enterFrame"</code> listeners, and even to repeating transitions. I tend to favor timers because of the customizable delay, and find them a bit more natural to cancel. If the coroutine is going to run forever anyway, however, it&#8217;s rather arbitrary.</p>
<p>Since we&#8217;ve brought up canceling, note that it&#8217;s perfectly fine to cancel the timer early. That said, it&#8217;s important to recognize that the timer and coroutine are two distinct things, so we would still need to yield the coroutine. Our helper function lets us do both at once (from inside the coroutine, of course) by calling <code>coroutine.yield("cancel")</code>.</p>
<h3><a name="waitutils"></a>Waiting Around</h3>
<p>So we have coroutines running on top of timers. Where do we go from here? Just using a timer encourages us to think of individual steps in the coroutine as taking place in time. If we apply this perspective to an earlier example, first we <code>DoSomething()</code>, then <i>later</i> we <code>DoSomethingElse()</code>. It&#8217;s a short leap from there to wanting something more explicitly chronological, like &#8220;<code>DoSomethingElse()</code> five seconds from now&#8221;. Can we achieve this?</p>
<p>Well, we do know when &#8220;now&#8221; is: we just ask <code>system.getTimer</code>. &#8220;The future,&#8221; then, is just &#8220;now&#8221; plus 5000 milliseconds. Once &#8220;the future&#8221; arrives, we know our five seconds are up. The most straightforward approach is to loop until then, yielding on each iteration. <a name="from_note4"></a><a href="#note1">[4]</a></p>
<p>Consider the following:</p><pre class="crayon-plain-tag">function WaitMS ( duration, update )
    local now = system.getTimer()
    local ends_at = now + duration

    while now &lt; ends_at do
        if update then -- Call any per-frame behavior. Yielding is discouraged, as it throws off our bookkeeping.
            update()
        end

        coroutine.yield()

        now = system.getTimer()
    end
end</pre><p>Then, lo and behold, we can do this:</p><pre class="crayon-plain-tag">DoSomething()
WaitMS( 5000 )
DoSomethingElse()</pre><p>Five seconds may be a long time, relatively speaking, just to wait around. The optional <code>update</code> parameter lets us sneak in little batches of work, as necessary.</p>
<p>We can wait for something other than time, obviously. Perhaps some condition must be satisfied:</p><pre class="crayon-plain-tag">function WaitUntilTrue( func, update )
    while not func() do
        if update then
            update()
        end

        coroutine.yield()
    end
end</pre><p>Let&#8217;s try it out! Here, we fire off a transition, then wait for it to finish:</p><pre class="crayon-plain-tag">local pos = { x = 20 }
local done = false  -- We haven't even started. Of course we're not done!

transition.to( pos, {
    x = 50,

    onComplete = function()
        done = true  -- NOW we're done.
    end
})

WaitUntilTrue( function()
    return done  -- Are we done yet?
end )
DoSomethingElse()</pre><p>Similarly, we can wait for some property to be true:</p><pre class="crayon-plain-tag">function WaitUntilPropertyTrue( object, name, update )
    while not object[name] do
        if update then
            update()
        end

        coroutine.yield()
    end
end</pre><p>Let&#8217;s use this to wait until an object becomes visible:</p><pre class="crayon-plain-tag">local rect = display.newRect( 100, 100, 50, 50 )

rect.isVisible = false

timer.performWithDelay( 5000, function()
    rect.isVisible = true
end )

WaitUntilPropertyTrue( rect, &quot;isVisible&quot; )
DoSomethingElse()</pre><p>Many more ideas could be explored. Obviously the &#8220;Wait until X is false&#8221; variants have their place. We can even watch multiple states, for which we&#8217;d have &#8220;Wait until all states in X are true&#8221;, &#8220;Wait until any state in X is true&#8221;, and so forth.</p>
<p>Each of these helper functions was fairly general, but nothing prevents us from making more specific ones. Compound operations, such as &#8220;Wait until object is visible, then wait ten seconds&#8221;, may also come in handy.</p>
<p>As the last examples show, coroutines play well with timers and transitions. Just one more tool in our kit.</p>
<h3><a name="statemachine"></a>State Machines</h3>
<p>Sometimes we&#8217;ll run across code like the following:</p><pre class="crayon-plain-tag">if state == 1 then
    DoState1()
elseif state == 2 then
    DoState2()
-- etc...</pre><p>Or, using strings:</p><pre class="crayon-plain-tag">if state == &quot;starting&quot; then
    Start()
elseif state == &quot;walking&quot; then
    Walk()
elseif state == &quot;waiting&quot; then
    Wait()
-- etc...</pre><p>This works well enough, but it&#8217;s often overkill, especially when we&#8217;re merely performing a sequence of actions. Beyond that, the pattern itself has some inherent dangers. When using integer states, we must remember which state belongs to what action. It doesn&#8217;t take long to lose our place. If we switch to the <span style="line-height: 1.5;">wrong state, say by mistyping the integer, we could easily have a debugging nightmare on our hands.</span></p>
<p>This isn&#8217;t such a problem with strings, of course, but we do have the hassle of thinking up good names. This is less trivial than it may seem. Things start out easy enough. We have <code>"starting"</code>, <code>"walking"</code>, and <code style="line-height: 1.5;">"waiting"</code><span style="line-height: 1.5;"> states&#8230; so far so good! </span>Then we&#8217;re walking again. Hmm. <code>"walking2"</code>? Sure, why not. Next it&#8217;s back to waiting. (<em>sigh</em>) <code>"waiting2"</code> it is.</p>
<p>Finally we come to the really awkward stuff. What do we call &#8220;updating x, choosing a fill color, and emptying an array&#8221;? We may end up making little functions, such as <code>Start</code>, <code>Walk</code>, and <code>Wait</code> in the last example, rather than inline <span style="line-height: 1.5;">code, just to reduce some of this visual congestion. The naming problem strikes again! This also reduces code locality: we need to go hunting to find </span><span style="line-height: 1.5;">those functions and see what&#8217;s in them. Furthermore, if we have several such functions, we&#8217;ve really only shifted the clutter around.</span></p>
<p>It would be better if the last snippet could instead be written:</p><pre class="crayon-plain-tag">Start()
Walk()
Wait()</pre><p>It should be obvious where this is headed. That style falls out quite naturally from moving our logic into a coroutine.</p>
<p>As a broader example, we might write the high-level game loop for some sort of sports title:</p><pre class="crayon-plain-tag">CoroPerformWithDelay( 30, function()
    OpeningSequence()

    for period = 1, NumberOfPeriods do
        WaitMS( 15000, PanCamera )  -- Show audience, stadium, etc.

        StartTheClock()

        repeat
            Play()  -- Basically, whatever happens between &quot;serving the ball&quot; and blowing the whistle.
        until OutOfTime()

        if period &lt; NumberOfPeriods then
            BetweenPeriodsSequence()  -- National anthem, hear from coaches, etc.
        else
            EndingSequence()  -- Fireworks!
        end
    end
end)</pre><p></p>
<h3><a name="sm2"></a>State Machines, Take Two</h3>
<p>Now, we may <b>want</b> &#8220;conventional&#8221; state machines. Character AI, for instance, typically consists of several independent behaviors, each of them fairly significant, which the character cycles through. Thankfully, we can accommodate this as well.</p>
<p>Consider a very simple AI, for one of the players in our sports title:</p><pre class="crayon-plain-tag">local States = {}

function States.Defensive()
    repeat
        GetCloserTo( Ball )

        if CloseTo( Ball ) then
            TryToGrabIt()
        end
    until GainedPossession()

    return States.Offensive()
end

function States.Offensive()
    repeat
        GetCloserTo( Goal )

        if CloseTo(Goal) then
            TryToScore()
        end
    until LostPossession()

    return States.Defensive()
end

local player = CoroPerformWithDelay( 30, States.Defensive )</pre><p>The player begins as the defender. The defensive strategy consists entirely of getting the ball away from the opponent (it isn&#8217;t a very sophisticated sport). With that objective in mind, the player tries to get in range of, and steal, the ball. If this succeeds, or the opponent lost the ball in some other way, the player has command of the ball and goes on the offensive.</p>
<p>Offense is a similar affair. The player tries to draw near the goal and score a point. If the opponent regains possession (ball was grabbed, the player scored, etc.), it&#8217;s back to defense.</p>
<p>Switching states is a simple matter of calling the appropriate function. I tend to lump all my states into a table, when doing this sort of thing. There usually isn&#8217;t any obviously correct order for the states, so forward declarations end up being too much hassle, especially as the switches become ever more tangled.</p>
<p>The <code>return state()</code> syntax is key. This is what is known as a <a href=http://www.lua.org/manual/5.1/manual.html?#2.5.8 target="_blank">tail call</a>. Whenever we call a function normally, Lua must leave behind some information so that, once the function finishes, execution can pick up where it left off. The trouble is, when we switch states, we have no intention of coming back! While we <b>can</b> hop around using the standard <code>state()</code> form, eventually so much of this bookkeeping piles up that it overflows the stack, and we crash. A tail call, on the other hand, in effect declares &#8220;I&#8217;m done here&#8221;. Lua honors this (by doing nothing) and the problem goes away.</p>
<p>Between the game loop and the player AI, we have two coroutines running. Nothing stops us from going further, say by making two full teams&#8217; worth of player AI. In the end, it comes down to what works.</p>
<h3><a name="long"></a>Long-Running Processes</h3>
<p>Timer-backed coroutines are great when it comes to events that span time. As it turns out, they&#8217;re perfect for tackling another class of problems, too: actions that just plain take a while!</p>
<p>&#8220;A while&#8221; could mean on the order of a minute or two, yet even a 50-millisecond operation will make our frame rate hiccup, if it doesn&#8217;t allow the rest of the program a chance to act.</p>
<p>A good example of this is loading a game level. We might find ourselves performing some quite time-consuming steps, such as unzipping large files or downloading images. The number of resources may also be significant. Each one takes time, and it adds up.</p>
<p>There&#8217;s not always much we can do about the predicament itself. What we probably <b>can</b> do is take some action between, or during, these many operations. If the long-running process is embedded in a coroutine, we can call <code>coroutine.yield</code> to temporarily cede control.</p>
<p>Yielding between might look like so:</p><pre class="crayon-plain-tag">DoHeavywork()

coroutine.yield()

DoMoreHeavyWork()</pre><p>And during:</p><pre class="crayon-plain-tag">local function DoHeavyWork()
    for i = 1, NumberOfThingsToProcess do
        DoSomeWork(i)

        coroutine.yield()
    end
end</pre><p>The yields put the action to sleep now and then, giving time back to Corona.</p>
<p>As with any long-running activity in Corona, it&#8217;s good practice to have something visual going on, be it the activity indicator, or a progress view, or even a simple animation. For particularly lengthy loads, we might even add a little mini-game as an overlay, to pass the time.</p>
<h3><a name="yieldutil"></a>Some Yield Helpers</h3>
<p>A shortcoming of using <code>coroutine.yield</code> directly is that, when we do yield, we&#8217;re done for that frame, even though there might still be time left for work. We can mitigate this somewhat by parametrizing the yield operation. That way, we can experiment with different strategies of staggering the yields, until we settle on a winner. The last snippet then becomes:</p><pre class="crayon-plain-tag">local function DoHeavyWork( yfunc )
    for i = 1, NumberOfThingsToProcess do
        DoSomeWork(i)

        yfunc()
    end
end</pre><p>As an example, we might use the following routine. When called, it tries to yield, but only actually does so if a certain amount of time has elapsed:</p><pre class="crayon-plain-tag">do
    local since

    function YieldOnTimeout()
        local now = system.getTimer()

        if not since then
            since = now  -- On first try, just sync.
        elseif now - since &gt;= 15 then  -- 15 milliseconds, but could be customized or an argument.
            since = now

            coroutine.yield()
        end
    end
end</pre><p>(The <code>do</code>&#8211;<code>end</code> construction limits the scope of <code>since</code>, keeping it private to <code>YieldOnTimeout</code>.)</p>
<p>In use, it might look like:</p><pre class="crayon-plain-tag">DoHeavyWork( YieldOnTimeout )</pre><p>This is no panacea, however. Sometimes we&#8217;ll get unlucky, say when there are only a couple milliseconds to spare and we run one more operation, which ends up taking five. To account for this, it may be best to underestimate the timeout.</p>
<p>Another possibility is to yield every few calls:</p><pre class="crayon-plain-tag">do
    local calls = 0

    function YieldEveryFewCalls()
        calls = calls + 1

        if calls == 4 then  -- Again, customizable and could be an argument.
            calls = 0

            coroutine.yield()
        end
    end
end</pre><p>Yet another idea is to yield randomly, say 25% of the time:</p><pre class="crayon-plain-tag">function YieldOccasionally()
    if math.random( 100 ) &lt;= 25 then  -- Ditto.
        coroutine.yield()
    end
end</pre><p></p>
<h3><a name="debug"></a>Coroutines as a Debugging Tool</h3>
<p>The <code>print()</code> statement is a hallmark of debugging, across a broad spectrum of programming languages. Sometimes this comes down to convenience, such as when it would take too much effort to configure a debugger, then place and watch breakpoints. On rare occasions, integrating a debugger may even <b>seem</b> to make the problem go away: an attack of the dreaded <a href=http://en.wikipedia.org/wiki/Heisenbug target="_blank">Heisenbug</a>!. A common strategy is to sprinkle <code>print()</code> statements around suspect points in the code, then compare the output with our expectations. If a message doesn&#8217;t appear, either the code in question was never visited or the program crashed along the way. As we narrow down the scope of the problem, we can remove instances of <code>print()</code> that are no longer necessary.</p>
<p>One concern in normal code is that most (or all) of these <code>print()</code> statements will execute, so we wind up with one long burst of messages. We might also need some sense of <b>when</b> a piece of code was executed, and what our program looked like at the time. It&#8217;s hard to guess where the process broke down.</p>
<p>Enter coroutines. If we can roughly isolate the troublesome code, it can be temporarily embedded in a coroutine. Then, by following each <code>print()</code> with a yield, we&#8217;re able to inspect the state of the world at that moment. Consider the following:</p><pre class="crayon-plain-tag">DoSomething()

-- We're curious about the snippet starting here...

local red = display.newRect( 100, 100, 30, 70 )

red:setFillColor( 1, 0, 0 )

print( &quot;Added red rect&quot; )

local blue = display.newCircle( 150, 30, 10 )

blue:setFillColor( 0, 0, 1 )

print( &quot;Added blue circle&quot; )

local green = display.newRect( 200, 100, 60, 20 )

green:setFillColor( 0, 1, 0 )

print( &quot;Added green rect&quot; )

-- ...and ending here.

DoSomethingElse()</pre><p>All of our messages and display objects show up at once.</p>
<p>With coroutines:</p><pre class="crayon-plain-tag">DoSomething()

-- Start of temporary debugging code...
local function print2( ... )
    print( ... )
    coroutine.yield()
end

CoroPerformWithDelay( 2000, function()  -- Wait 2 seconds after each print statement.
-- ...end of temporary debugging code

local red = display.newRect( 100, 100, 30, 70 )

red:setFillColor( 1, 0, 0 )

print2( &quot;Added red rect&quot; )

local blue = display.newCircle( 150, 30, 10 )

blue:setFillColor( 0, 0, 1 )

print2( &quot;Added blue circle&quot; )

local green = display.newRect( 200, 100, 60, 20 )

green:setFillColor( 0, 1, 0 )

print2( &quot;Added green rect&quot; )

-- Start of temporary debugging code...
end )
-- ...end of temporary debugging code

DoSomethingElse()</pre><p>By using coroutines, we get to watch the action unfold. In the example above, we now have a couple seconds to review the state of affairs after each <code>print2</code>, without significantly changing the code shape. If we only need to do some visual inspection, we can even just use <code>coroutine.yield</code> directly.</p>
<p>I employed this technique quite recently, in order to test some <a href=http://code.coronalabs.com/code/layout-helpers target="_blank">layout routines</a>. Since these primarily involve display objects, <code>print()</code> only got me so far. Many of the operations consist of one object being positioned relative to another, so if something went wrong in the middle, the whole layout fell apart. By viewing the steps one at a time, I was able to pinpoint when and where things went awry.</p>
<p>Bear in mind that this method does slightly alter the program flow, on account of the yields. Therefore, we must include this in our notion of isolation. In the previous example, for instance, <code>DoSomethingElse</code> shouldn&#8217;t depend on what happens inside the wrapped-up code.</p>
<h3><a name="touch"></a>The Magic Touch</h3>
<p>A timer won&#8217;t always be the best fit for debugging. With a short delay, the steps may go by too soon. Much longer, and we might instead grow weary waiting, especially if the problem tends to show up quite late.</p>
<p>Fortunately, time isn&#8217;t the only way to drive a coroutine. We hinted earlier at using wrapped coroutines as event listeners. <code>"touch"</code> listeners are one such choice, and in fact give us direct control: on each touch, we resume the wrapped-up code.</p>
<p>With Corona, it&#8217;s easy to create a dummy display object and assign it such a listener. Then, instead of waiting around for the timer, we just click rapidly through any steps we want to ignore. Once we find something suspicious, we can take our time.</p>
<p>The previous example then becomes:</p><pre class="crayon-plain-tag">DoSomething()

-- Start of temporary debugging code...
local function print2( ... )
    print( ... )
    coroutine.yield()
end

local co = coroutine.create( function()  -- Wait for next touch event.
-- ...end of temporary debugging code

local red = display.newRect( 100, 100, 30, 70 )

red:setFillColor( 1, 0, 0 )

print2( &quot;Added red rect&quot; )

local blue = display.newCircle( 150, 30, 10 )

blue:setFillColor( 0, 0, 1 )

print2( &quot;Added blue circle&quot; )

local green = display.newRect( 200, 100, 60, 20 )

green:setFillColor( 0, 1, 0 )

print2( &quot;Added green rect&quot; )

-- Start of temporary debugging code...
end )

local button = display.newCircle( 20, 20, 10 )

button:setFillColor( .7 )
button:addEventListener( &quot;touch&quot;, function( event )
    if event.phase == &quot;began&quot; then
        local ok, err = coroutine.resume( co )

        if not ok then
            print( err )  -- What went wrong?
        end
    end

    return true
end)
-- ...end of temporary debugging code --

DoSomethingElse()</pre><p>After one click, we see:</p>
<p><a href=/wordpress/wp-content/uploads/2015/02/debug1.jpg><img class=" size-full wp-image-61378 aligncenter" src=/wordpress/wp-content/uploads/2015/02/debug1.jpg alt="debug1" width="320" height="300" /></a></p>
<p><span style="line-height: 1.5;">(The gray circle is our &#8220;button&#8221;, the dummy display object.)</span></p>
<p>After another:</p>
<p><a href=/wordpress/wp-content/uploads/2015/02/debug2.jpg><img class=" size-full wp-image-61379 aligncenter" src=/wordpress/wp-content/uploads/2015/02/debug2.jpg alt="debug2" width="320" height="300" /></a></p>
<p>Finally:</p>
<p><a href=/wordpress/wp-content/uploads/2015/02/debug3.jpg><img class=" size-full wp-image-61380 aligncenter" src=/wordpress/wp-content/uploads/2015/02/debug3.jpg alt="debug3" width="320" height="300" /></a></p>
<p>This is actually a situation where <code>coroutine.create</code> and <code>coroutine.resume</code> are more appropriate. We don&#8217;t want <span style="line-height: 1.5;">to crash our program just because we clicked too many times and ran a dead coroutine. We also end up with a basic sandbox, where an error </span><span style="line-height: 1.5;">can occur without bringing down our whole program (the coroutine will then be dead, of course). If our code snippet was properly isolated, </span><span style="line-height: 1.5;">this should work just fine.</span></p>
<p>Once everything is good to go, we can remove all the &#8220;temporary debugging code&#8221; and move on.</p>
<h3><a name="gotchas"></a>Gotchas</h3>
<p>There are a few specific cases where coroutines break, owing mainly to some quirks in the interaction between Lua and C. Thanks to some redesign in the codebase, these have been fixed in Lua 5.2+. Corona is based on 5.1, though, so for the time being these issues are a fact of life.</p>
<p>Two such problem areas involve <a href=http://www.lua.org/manual/5.1/manual.html?#pdf-pcall target="_blank">protected calls</a> and <a href=http://www.lua.org/manual/5.1/manual.html?#2.8 target="_blank">metamethods</a>, as Peter &#8220;Corsix&#8221; Cawley <a href=http://www.corsix.org/content/look-lua-52-work3 target="_blank">points out on his blog</a> (see point #2). Note that the article itself mainly concerns 5.2, whereas we only care about the 5.1-related misbehavior. There have been some attempts to deal with protected calls, such as <a href=https://github.com/keplerproject/coxpcall target="_blank">Coxpcall</a>, created expressly to allow them in <a href=https://github.com/keplerproject/copas target="_blank">Copas</a> (a library for building TCP/IP servers atop coroutines).</p>
<p><a href=http://www.lua.org/manual/5.1/manual.html?#2.4.5 target="_blank">Iterators</a> are the other problem spot:</p><pre class="crayon-plain-tag">local wrapped = coroutine.wrap( function()
    for _ in function()  -- An (obviously not useful!) iterator body.
        print( &quot;Before&quot; )

        coroutine.yield()  -- In 5.1, gives error: attempt to yield across metamethod / C-call boundary.

        print( &quot;After&quot; )
    end do
        print( &quot;Loop!&quot; )
    end
end )

wrapped()</pre><p>This is a rather lame iterator (it doesn&#8217;t even attempt to iterate!), but it demonstrates the issue. Attempting to yield directly from the so-called iterator function results in an error, in Lua 5.1. We see the message <b>&#8220;Before&#8221;</b>, and then our program goes down in flames. Note that this is <b>not</b> the same as <a href=http://www.lua.org/pil/9.3.html target="_blank">using coroutines as iterators</a> (an incredibly useful feature but, alas, an entire topic of its own!).</p>
<p>Thankfully these all tend to be rare situations, but it&#8217;s good to be aware of them.</p>
<h3><a name="saving"></a>Saving</h3>
<p>The final gotcha comes from a design perspective. Being able to yield offers us great flexibility, but the flip side is that we do actually need to traverse the coroutine body to arrive at a given point in our code, with all of our local variables and program state in order. We can&#8217;t just jump to somewhere in the middle, in general. This presents a problem if the application must be able to save and later restore itself exactly where it left off. This isn&#8217;t insurmountable, but does need to be accounted for early on. It will almost certainly be difficult, and probably not worth the hassle.</p>
<p>If the application only needs to be saved every now and then (say between levels or at checkpoints, in a game), or has some leeway regarding what gets restored, this is a much smaller issue.</p>
<h3><a name="examples"></a>Examples</h3>
<p>Most of the code in this article has been adapted from the samples repository <a href=https://github.com/ggcrunchy/samples/tree/master/coroutines target="_blank">found here</a>. It can be downloaded from <a href=https://github.com/ggcrunchy/samples/archive/master.zip target="_blank">here</a>. These samples were made to be shown during a <a href=/blog/coronageek/corona-geek-122/ target="_blank">Corona Geek hangout</a>, so I wrote in a <span style="line-height: 1.5;">style which allows entire segments of the program to be turned on and off quickly. In particular, code gets blocked in </span><a style="line-height: 1.5;" href=http://www.lua.org/pil/1.3.html target="_blank">long comments</a><span style="line-height: 1.5;">. Doing so lets us start with a commented-out section:</span></p><pre class="crayon-plain-tag">--[[
DoSomething() -- Commented out, does not run.
--]]</pre><p>We can then enable all its code at once, simply by adding another hyphen at the beginning of the comment:</p><pre class="crayon-plain-tag">---[[
DoSomething() -- No longer commented, will run.
--]]</pre><p>To disable it once more, just remove the hyphen. I used this blocking method in <code>main.lua</code>, to <code>require()</code> each example, as well as within the modules themselves.</p>
<p>Also, in order to reduce switches between the simulator and console while recording, I overrode <code>print()</code> in <code>main.lua</code>, such that messages show up on the screen (as text objects) rather than the console. To disable this, simply remove or comment out the assignment to <code>print()</code>.</p>
<h3><a name="summary"></a>In Summary</h3>
<p>Coroutines are a truly powerful feature of Lua which, when combined with such mechanisms as Corona&#8217;s timers and event listeners, offer us a novel and useful approach to a whole host of difficult problems. We&#8217;ve only scratched the surface. <a href=http://www.lua.org/pil/9.html target="_blank">Chapter 9</a> of <b>Programming in Lua</b> covers several topics only <span style="line-height: 1.5;">touched on here. Explore, and have fun!</span></p>
<hr />
<p><a name="note1"></a><a href="#from_note1">[1]</a> A coroutine <b>is</b> a thread. The reverse is also true, with one very important exception: the main thread. This is the &#8220;normal&#8221; part of the program, where our code runs when it&#8217;s not inside a coroutine.</p>
<p><a name="note2"></a><a href="#from_note2">[2]</a> Typically, but not always. We could, for instance, assign the same wrapper to several listeners. Then, as these fire off piecemeal, the coroutine is gradually driven forward.</p>
<p>Another use case is to abort complex code. We might find ourselves in the middle of some heavy operation, ten function calls deep, when we realize we just can&#8217;t deal with it. It&#8217;s easy enough to <code>return</code> out of one function. Getting out of nine more is a different story! On the other hand, if this is all inside a coroutine, we can just yield. Suddenly we&#8217;re back in the <a href="#note1">main thread</a>, and can just throw the coroutine away. Another way to achieve this is to <code>error()</code> out, although this seems a bit impolite if we don&#8217;t actually have an error.</p>
<p>As the saying goes, &#8220;It&#8217;s better to ask forgiveness than permission.&#8221; Essentially, if it&#8217;s too much trouble to figure out up front whether an operation has even a chance of success, the best idea might be to just go for it. When we combine this approach with a set of choices, we arrive at a technique called backtracking, which can be summed up in another expression, &#8220;If at first you don&#8217;t succeed, try again.&#8221;</p>
<p>We might want to do normal yields in the coroutine. The ability to send data through <code>coroutine.yield</code> comes to our rescue here. At the outset, we reserve a couple values, <b>&#8220;success&#8221;</b> and <b>&#8220;failure&#8221;</b> perhaps, then resume until we run across one or the other.</p>
<p><a name="note3"></a><a href="#from_note3">[3]</a> Creating shadow tables reintroduces garbage, of course. However, coroutine-based timers will by and large be created far less frequently than garden variety timers, and be longer-running besides, so this is unlikely to be a problem in practice.</p>
<p><a name="note4"></a><a href="#from_note4">[4]</a> Another possibility, when yielding, is to pass control of the coroutine to a scheduler, which will later resume the coroutine once it&#8217;s ready to go. This has its pros and cons. Since we&#8217;re no longer spinning in a loop, it may prove more efficient, especially when we have several coroutines going. At the <span style="line-height: 1.5;">same time, if we still need to do updates, these costs just reappear in a different form, say as </span><code style="line-height: 1.5;">"enterFrame"</code><span style="line-height: 1.5;"> listener overhead.</span></p>
<p>Scheduler implementations abound. Some examples in pure Lua are <a href=https://github.com/xopxe/Lumen target="_blank">Lumen</a> and <a href=https://gist.github.com/Deco/1818054 target="_blank">this Gist</a>. Others, coded partially in C and C++, include <a href=https://github.com/lefcha/concurrentlua target="_blank">ConcurrentLua</a>, <a href=https://github.com/SierraWireless/luasched target="_blank">luasched</a>, and <a href=https://github.com/dmattp/nylon target="_blank">Nylon</a>. Unfortunately, we can&#8217;t simply drop these last few into a Corona codebase. That said, enough of their code <b>is</b> written in Lua to reward some study.</p>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2015/02/10/tutorial-using-coroutines-in-corona/feed/</wfw:commentRss>
		<slash:comments>14</slash:comments>
		</item>
	</channel>
</rss>
