<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>transition &#8211; Corona Labs</title>
	<atom:link href="/blog/tags/transition/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description></description>
	<lastBuildDate>Mon, 19 Oct 2020 12:16:12 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.8</generator>

<image>
	<url>/wordpress/wp-content/uploads/2017/06/cropped-icon_32x32@2x-32x32.png</url>
	<title>transition &#8211; Corona Labs</title>
	<link>/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Tutorial: Moving objects along a path</title>
		<link>/blog/2014/01/07/tutorial-moving-objects-along-a-path/</link>
		<comments>/blog/2014/01/07/tutorial-moving-objects-along-a-path/#comments</comments>
		<pubDate>Tue, 07 Jan 2014 21:31:50 +0000</pubDate>
		<dc:creator><![CDATA[Brent Sorrentino]]></dc:creator>
				<category><![CDATA[Tutorials, Tips and Demos]]></category>
		<category><![CDATA[path]]></category>
		<category><![CDATA[transition]]></category>
		<category><![CDATA[tutorial]]></category>

		<guid isPermaLink="false">/?p=55020</guid>
		<description><![CDATA[There are many ways to move objects in Corona SDK. If you want to move an object from point A to point B, the simplest approach is to use a transition. But what if you need to move it along a path with multiple segments, like moving a knight on a chess board in its unique "L" pattern? This tutorial outlines how to achieve sequential movement via a series of queued transitions.]]></description>
				<content:encoded><![CDATA[<p>There are many ways to move objects in Corona SDK. If you want to move an object from point A to B, the simplest approach is to use <a href=http://docs.coronalabs.com/api/library/transition/to.html target="_blank">transition.to()</a>. But what if you need to move it along a path with multiple segments, like moving a knight on a chess board in its unique &#8220;<strong>L</strong>&#8221; pattern? This tutorial outlines how to achieve sequential movement via a series of <strong>queued</strong> transitions.</p>
<h3>Initial setup</h3>
<p>The basis of this process is a table of <code>x</code> and <code>y</code> coordinate pairs to move the object along, in sequence. In its most simple format, the table may look like this:</p><pre class="crayon-plain-tag">local movePath = {}
movePath[1] = { x=200, y=0 }
movePath[2] = { x=200, y=200 }
movePath[3] = { x=0, y=200 }
movePath[4] = { x=200, y=300 }
movePath[5] = { x=150, y=200 }
movePath[6] = { x=200, y=100 }
movePath[7] = { x=100, y=200 }
movePath[8] = { x=0, y=0 }</pre><p>This just declares a series of movement points, starting at index 1 and progressing across as many points as you wish. By default, these points equate to specific coordinates on the screen, <strong>not</strong> points relative to the object&#8217;s starting position, but we&#8217;ll include a setting to let you choose which option is most suitable to your application.</p>
<h4>Customizing the path parameters</h4>
<p>In addition to the basic <code>x</code> and <code>y</code> coordinate setup, we&#8217;ll allow two additional parameters for each &#8220;segment&#8221; in the path: <code>time</code> and <code>easingMethod</code>. For example, we may expand our table like this:</p><pre class="crayon-plain-tag">local movePath = {}
movePath[1] = { x=200, y=0 }
movePath[2] = { x=200, y=200 }
movePath[3] = { x=0, y=200, time=500 }
movePath[4] = { x=200, y=300, time=500 }
movePath[5] = { x=150, y=200, time=250, easingMethod=easing.inOutExpo }
movePath[6] = { x=200, y=100, time=2000 }
movePath[7] = { x=100, y=200, time=500 }
movePath[8] = { x=0, y=0, time=500, easingMethod=easing.outQuad }</pre><p>If a custom <code>time</code> parameter is specified, it will override any other time settings, and the object will move to that point over that exact duration. Similarly, if <code>easingMethod</code> is defined and set to one of Corona&#8217;s <a href=http://docs.coronalabs.com/api/library/easing/index.html target="_blank">easing</a> methods, the object will move to that point using that easing method, not the default linear interpolation.</p>
<h4>Distance function</h4>
<p>For calculating the distance between two points, we&#8217;ll need to include a quick function. The purpose of this will be explained later, but let&#8217;s add it now:</p><pre class="crayon-plain-tag">local function distBetween( x1, y1, x2, y2 )
   local xFactor = x2 - x1
   local yFactor = y2 - y1
   local dist = math.sqrt( (xFactor*xFactor) + (yFactor*yFactor) )
   return dist
end</pre><p></p>
<h4>Create the object(s)</h4>
<p>Obviously, we&#8217;ll need one or more objects to move along the path we created. Let&#8217;s create two basic circles now:</p><pre class="crayon-plain-tag">local circle1 = display.newCircle( 60, 100, 15 )
circle1:setFillColor( 1, 0, 0.4 )
local circle2 = display.newCircle( 120, 100, 15 )
circle2:setFillColor( 1, 0.8, 0.4 )</pre><p></p>
<h3>The setPath() function</h3>
<p>Now that we&#8217;ve done the basic setup, let&#8217;s explore the function which will queue up all of the transitions for an object. Let&#8217;s call the function <code>setPath()</code> and provide it with three arguments: the <code>object</code> to move, the <code>path</code> to move along, and a table of <code>params</code> which we can use to customize the movement.</p><pre class="crayon-plain-tag">local function setPath( object, path, params )

   local delta = params.useDelta or nil
   local deltaX = 0
   local deltaY = 0
   local constant = params.constantTime or nil
   local ease = params.easingMethod or easing.linear
   local tag = params.tag or nil
   local delay = params.delay or 0
   local speedFactor = 1</pre><p>In the first several lines of the function, we set some local variables, most of which are used to check if various parameters are passed in via the <code>params</code> table. Each of these parameters will be explained as we step through the tutorial.</p>
<h4>Delta</h4>
<p>This gives us the option to use <strong>delta</strong> position via a boolean value — <code>useDelta</code> — passed in via the <code>params</code> table. If set to <code>true</code>, the object&#8217;s path will be relative to its starting position. If set to <code>false</code>, or omitted, the path points will equate to explicit screen coordinates instead.</p>
<p>Whether to use <code>params.useDelta = true</code> depends on the scenario. For moving a knight on a chess board, delta would be the logical choice, since the knight may reside on any square of the board and we&#8217;d need to move it in its &#8220;<strong>L</strong>&#8221; pattern from the current square to another valid square.</p>
<p>If <code>useDelta</code> is passed in the <code>params</code> table, let&#8217;s set <code>deltaX</code> and <code>deltaY</code> to the object&#8217;s starting position, instead of their default of <code>0</code>. When the transitions are set up, this will be used to offset each point along the path by the object&#8217;s starting position. It will also be used to refactor the constant rate of movement, discussed in a moment.</p><pre class="crayon-plain-tag">if ( delta ) then
      deltaX = object.x
      deltaY = object.y
   end</pre><p></p>
<h4>Constant rate of movement</h4>
<p>Another option we&#8217;ll add is the ability to set a &#8220;constant rate of movement.&#8221; For example, we may wish to move the object at a steady, constant rate across the entire path, even if the distance between the starting point and the 2nd point is 100 pixels but the distance between the 2nd and 3rd point is 280 pixels. To accomplish this, we just need to calculate a speed factor based on a &#8220;time&#8221; value passed in via <code>params.constantTime</code>.</p><pre class="crayon-plain-tag">if ( constant ) then
      local dist = distBetween( object.x, object.y, deltaX+path[1].x, deltaY+path[1].y )
      speedFactor = constant/dist
   end</pre><p>The value that should be passed to <code>params.constantTime</code> is simply an integer &#8220;time&#8221; value, and <code>speedFactor</code> is calculated by the <strong>distance between the starting point and the 2nd point</strong>. In other words, if we use a value of 1200, the object will move from the starting point to the 2nd point in 1200 milliseconds, and the speed established along that segment will be applied to all other segments in the path, no matter their distance apart.</p>
<h4>Default easing method</h4>
<p>If we wish to use a non-linear easing method for all segments in the path, we can tell the module to use any of the <a href=http://docs.coronalabs.com/api/library/easing/index.html target="_blank">easing</a> methods. For example, to use a <strong>quadratic-in-out</strong> method, we can pass <code>easingMethod = easing.inOutQuad</code> in the <code>params</code> table. This easing method will be applied to all transitions along the path <strong>except</strong> those with a specific <code>easingMethod</code> setting in the path table.</p>
<h4>Transition tagging</h4>
<p>One of the features in the <a href=http://docs.coronalabs.com/api/library/transition/index.html target="_blank">transition</a> library is the ability to tag (name) any number of transitions and then <a href=http://docs.coronalabs.com/api/library/transition/cancel.html target="_blank">cancel</a>, <a href=http://docs.coronalabs.com/api/library/transition/pause.html target="_blank">pause</a>, or <a href=http://docs.coronalabs.com/api/library/transition/resume.html target="_blank">resume</a> all transitions sharing the same tag. Since we&#8217;ll be building paths that consist of multiple related transitions, tagging is essential if you want to pause or resume the path movement as it progresses from point to point. To tag all of the transitions that will collectively make up the path, just pass the <code>tag</code> parameter (string value) in the <code>params</code> table.</p>
<h4>Looping through the points</h4>
<p>Now, let&#8217;s loop through our points and set up the queue of transitions. For simplicity, we&#8217;ll declare all of them initially and apply a <code>delay</code> parameter on each, so each transition starts when the previous one is finished.</p>
<p>First, we&#8217;ll start our loop and immediately set a default <code>segmentTime</code> of 500 milliseconds. Then, we&#8217;ll check if <code>params.constantTime</code> has been supplied and, if so, we&#8217;ll overwrite <code>segmentTime</code> with a refactored time — specifically, the distance between the points multiplied by the <code>speedFactor</code> that we calculated above:</p><pre class="crayon-plain-tag">for i = 1,#path do

      local segmentTime = 500

      --if &quot;constant&quot; is defined, refactor transition time based on distance between points
      if ( constant ) then
         local dist
         if ( i == 1 ) then
            dist = distBetween( object.x, object.y, deltaX+path[i].x, deltaY+path[i].y )
         else
            dist = distBetween( path[i-1].x, path[i-1].y, path[i].x, path[i].y )
         end
         segmentTime = dist*speedFactor</pre><p>As mentioned above, we can optionally set a custom <strong>time</strong> on any specific segment in the path. If supplied, this value will override both the default of 500 milliseconds <strong>and</strong> the &#8220;constant rate&#8221; value, if it&#8217;s being used. Let&#8217;s check if a custom time has been specified for this segment:</p><pre class="crayon-plain-tag">else
         --if this path segment has a custom time, use it
         if ( path[i].time ) then segmentTime = path[i].time end
      end</pre><p>In addition, let&#8217;s check if a custom <code>easingMethod</code> parameter has been set on this specific path segment. If declared, this will override the optional <strong>default</strong> easing method applied to the path as a whole.</p><pre class="crayon-plain-tag">--if this segment has custom easing, override the default method (if any)
      if ( path[i].easingMethod ) then ease = path[i].easingMethod end</pre><p>And finally, the heart of the entire process — creating each transition for the path:</p><pre class="crayon-plain-tag">transition.to( object, { tag=tag, time=segmentTime, x=deltaX+path[i].x, y=deltaY+path[i].y, delay=delay, transition=ease } )
      delay = delay + segmentTime
   end
end</pre><p>Notice that the parameters table for each actual transition is populated based on the values we gathered or calculated in the lines above. Also, note line #66 — here, we add to the total <code>delay</code> value for each new transition in sequence, thus making each transition begin when the previous one has completed.</p>
<h3>Setting an object in motion</h3>
<p>Let&#8217;s start our circles in motion across the path! At the most basic level, the <code>setPath()</code> function may be called like this:</p><pre class="crayon-plain-tag">setPath( circle1, movePath, { tag=&quot;moveObject&quot; } )
setPath( circle2, movePath, { tag=&quot;moveObject&quot; } )</pre><p>However, this doesn&#8217;t include any options like <code>useDelta</code> or <code>constantTime</code>, so let&#8217;s expand on it:</p><pre class="crayon-plain-tag">setPath( circle1, movePath, { useDelta=true, constantTime=1200, easingMethod=easing.inOutQuad, delay=200, tag=&quot;moveObject&quot; } )
setPath( circle2, movePath, { useDelta=true, constantTime=1200, easingMethod=easing.inOutQuad, tag=&quot;moveObject&quot; } )</pre><p>And that&#8217;s it — the circles will both follow the same path, <code>movePath</code>, and the path will be offset by each object&#8217;s starting position because we used the delta setting. The rate of movement across each segment will be constant, and an in-out quadratic easing will be applied to all segments.</p>
<h4>Pausing, resuming, canceling</h4>
<p>Because we tagged every transition in the sequence with the <code>"moveObject"</code> tag, pausing, resuming, or canceling is simple — just pass the tag name to one of the transition control APIs:</p><pre class="crayon-plain-tag">--pause the sequence
transition.pause( &quot;moveObject&quot; )
--some time later, resume it
transition.resume( &quot;moveObject&quot; )
--all finished... cancel it!
transition.cancel( &quot;moveObject&quot; )</pre><p></p>
<h3>In summary</h3>
<p>Hopefully this tutorial gets you started on path-based movement in Corona. In closing, note the following:</p>
<ul>
<li>The functional format allows you to create and re-use several unique path &#8220;patterns&#8221; and apply them to various objects by simply passing the appropriate path table to the <code>setPath()</code> function, along with the object and the optional parameters. In this manner, you could, for example, create several different movement paths for pieces in a board game and re-use those paths as needed depending on the player&#8217;s move.</li>
<li>This tutorial outlines just <strong>linear</strong> path-based movement. If you need <strong>curved-based</strong> path methods, please refer to the <a href=/blog/2014/09/09/tutorial-working-with-curved-paths/ target="_blank">working with curved paths</a> tutorial.</li>
</ul>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2014/01/07/tutorial-moving-objects-along-a-path/feed/</wfw:commentRss>
		<slash:comments>28</slash:comments>
		</item>
	</channel>
</rss>
