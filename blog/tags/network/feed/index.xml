<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>network &#8211; Corona Labs</title>
	<atom:link href="/blog/tags/network/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description></description>
	<lastBuildDate>Mon, 19 Oct 2020 12:16:12 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.8</generator>

<image>
	<url>/wordpress/wp-content/uploads/2017/06/cropped-icon_32x32@2x-32x32.png</url>
	<title>network &#8211; Corona Labs</title>
	<link>/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Tutorial: Local multiplayer with UDP/TCP</title>
		<link>/blog/2014/09/23/tutorial-local-multiplayer-with-udptcp/</link>
		<comments>/blog/2014/09/23/tutorial-local-multiplayer-with-udptcp/#comments</comments>
		<pubDate>Tue, 23 Sep 2014 21:56:05 +0000</pubDate>
		<dc:creator><![CDATA[Rob Miracle]]></dc:creator>
				<category><![CDATA[Guest Bloggers]]></category>
		<category><![CDATA[Tutorials, Tips and Demos]]></category>
		<category><![CDATA[LAN]]></category>
		<category><![CDATA[network]]></category>
		<category><![CDATA[peer-to-peer]]></category>
		<category><![CDATA[tutorial]]></category>

		<guid isPermaLink="false">/?p=59630</guid>
		<description><![CDATA[In this guest tutorial, Corona developer Mark Steelman discusses the implementation of local area networking between two devices using LuaSocket and UDP/TCP. Read further to learn how.]]></description>
				<content:encoded><![CDATA[<p><em>Today&#8217;s guest tutorial comes to you courtesy of Mark Steelman, founder of Steelman Games LLC. Mark is currently working on a turn-based RPG incorporating local multiplayer called <a href=http://www.legendofus.net/ target="_blank">Legend of Us Roleplaying Game</a>. Before becoming an indie developer, Mark worked for four years at Electronic Arts as a game designer. You can follow the progress of his projects on <a href=http://www.facebook.com/legendofusrpg target="_blank">Facebook</a>, <a title="Legend of Us RPG Google+" href=http://plus.google.com/+LegendofusNet target="_blank">Google+</a>, or by subscribing to his <a title="Legend of Us RPG main page" href=http://www.legendofus.net/ target="_blank">newsletter</a>.</em></p>
<hr />
<h3>Make devices find each other with UDP</h3>
<p>As noted in the introduction, I&#8217;m building a <a href=http://www.legendofus.net/ target="_blank">turn-based role-playing game</a> using Corona SDK. As part of the design, I wanted <strong>local multiplayer</strong> and I also wanted it to be <strong>cross-platform</strong>. After a lot of research, I figured out how to accomplish this and, in this tutorial, I will share some of what I learned. Even better: this architecture will work for both turn-based and action games, so stick around if you&#8217;re making an action game!</p>
<p>This tutorial assumes that you have a basic understanding of Corona SDK, Lua, and peer-to-peer networking. We are going to use <a title="link to LUA Socket documentation" href=http://w3.impa.br/~diego/software/luasocket/ target="_blank">LuaSocket</a> which is included in Corona SDK under the <a href=http://docs.coronalabs.com/api/library/socket/index.html target="_blank">socket</a> library. Because this design is intended for cross-platform multiplayer, it&#8217;s not going to use any native systems. While it does assume that the player has a Local Area Network (LAN), that network doesn’t need to be connected to the internet.</p>
<h3>Including LuaSocket</h3>
<p>In order to use LuaSocket, you must first include it:</p><pre class="crayon-plain-tag">local socket = require( &quot;socket&quot; )</pre><p>That&#8217;s the easy part &#8212; let&#8217;s continue&#8230;</p>
<h3>UDP and TCP</h3>
<p>First, let me give a brief explanation of <strong>UDP</strong> and <strong>TCP</strong>. Both of these are protocols which allow computers to talk to each other and each one has certain advantages and disadvantages. However, I’m only going to cover features that are relevant to the tutorial.</p>
<p><strong>UDP</strong> has the ability to send messages to an address without knowing if anything is there. It doesn’t check to see if the message made it anywhere &#8212; it simply transmits the message. UDP also allows you to listen to an address without being connected to a computer at that address.</p>
<p><strong>TCP</strong> is a reliable protocol. It sends messages to another computer that it&#8217;s connected to via a TCP socket. If the other computer responds that there was a problem with the message, it sends the message again.</p>
<p>Knowing this, you might ask &#8220;Why would anyone use UDP when TCP is so reliable?&#8221; Well, there are several reasons, but the reason most relevant to this tutorial is the fact that you must know the IP address of the server in order to use TCP. Any network which you can join without visiting the LAN administrator is assigning you a random IP address using DHCP. This means that we&#8217;ll need to discover the IP address of the server on our own. Fortunately, UDP can help with that.</p>
<h3>Advertise the server</h3>
<p>For local multiplayer to work, one of the devices must act as the server/host. The host doesn&#8217;t need to have special privileges in your game, but the primary record of the game in progress will be stored on this device. In the language of role-playing games, let&#8217;s call this player the <strong>game master</strong>. This game master is going to announce his/her presence to the local network via some method. I utilize an &#8220;Invite&#8221; button which calls the following function upon being pressed.</p><pre class="crayon-plain-tag">local advertiseServer = function( button )

&nbsp;&nbsp; &nbsp;local send = socket.udp()
&nbsp;&nbsp; &nbsp;send:settimeout( 0 )  --this is important (see notes below)

&nbsp;&nbsp; &nbsp;local stop

&nbsp;&nbsp; &nbsp;local counter = 0  --using this, we can advertise our IP address for a limited time

&nbsp;&nbsp; &nbsp;local function broadcast()
&nbsp; &nbsp; &nbsp; &nbsp; local msg = &quot;AwesomeGameServer&quot;
&nbsp; &nbsp; &nbsp; &nbsp; --multicast IP range from 224.0.0.0 to 239.255.255.255
&nbsp; &nbsp; &nbsp; &nbsp; send:sendto( msg, &quot;228.192.1.1&quot;, 11111 )
&nbsp; &nbsp; &nbsp; &nbsp; --not all devices can multicast so it's a good idea to broadcast too
&nbsp; &nbsp; &nbsp; &nbsp; --however, for broadcast to work, the network has to allow it
&nbsp; &nbsp; &nbsp; &nbsp; send:setoption( &quot;broadcast&quot;, true )  --turn on broadcast
&nbsp; &nbsp; &nbsp; &nbsp; send:sendto( msg, &quot;255.255.255.255&quot;, 11111 )
&nbsp; &nbsp; &nbsp; &nbsp; send:setoption( &quot;broadcast&quot;, false )  --turn off broadcast

&nbsp; &nbsp; &nbsp; &nbsp; counter = counter + 1
&nbsp; &nbsp; &nbsp; &nbsp; if ( counter == 80 ) then  --stop after 8 seconds
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;    stop()
&nbsp; &nbsp; &nbsp; &nbsp; end
&nbsp;&nbsp; &nbsp;end

&nbsp;&nbsp; &nbsp;--pulse 10 times per second
&nbsp;&nbsp; &nbsp;local serverBroadcast = timer.performWithDelay( 100, broadcast, 0 )

&nbsp;&nbsp; &nbsp;button.stopLooking = function()
&nbsp; &nbsp;     timer.cancel( serverBroadcast )  --cancel timer
&nbsp; &nbsp; &nbsp; &nbsp; button.stopLooking = nil
&nbsp;&nbsp; &nbsp;end
&nbsp;&nbsp; &nbsp;stop = button.stopLooking
end</pre><p>Here are some notes about this code:</p>
<ul>
<li><strong>Multicast</strong> is a device feature which allows one device to communicate with several. iPhones and iPads have it, but I&#8217;ve been told that iPods do not. I haven&#8217;t tried it on any Android devices, so maybe somebody can test it and report their results in the comments section. As a result of this inconsistency, we also use <strong>broadcast</strong>. &#8220;Why don&#8217;t we just use broadcast?&#8221; you might ask. Well, the catch with broadcast is that the LAN has to allow broadcasts. By using both, we are maximizing the chance of finding each other.</li>
<li>The &#8220;pulse&#8221; of the timer is ten times per second. I don&#8217;t recommend setting your timer pulse faster than that unless you have a good reason &#8212; after all, your game needs time to do other things. This is a standard pulse speed for most action games including MMOs.</li>
<li>The port you choose can be anything between <code>1</code> and <code>65535</code>, however, applications almost always block the port that they use and you&#8217;ll get an error if you try to bind to a port that is currently in use. Likewise, if you bind to a port, you need to unbind/close the port when you end the game so you don&#8217;t block it indefinitely on the players device. Lower number ports are used by commonly run applications, so it&#8217;s best to use a port between <code>1024</code> and <code>65535</code>.</li>
<li>The <code>settimeout()</code> function allows you to tell the socket how long to wait for a message before moving on. Default is to wait indefinitely, meaning that your game freezes until it gets a message. Setting it to <code>0</code> tells it to just check and if there&#8217;s nothing to receive and move on to the next task.</li>
</ul>
<h3>Finding the server</h3>
<p>The client will need to know its own IP address for the next step. Fortunately, UDP in LuaSocket can help with that:</p><pre class="crayon-plain-tag">local getIP = function()
&nbsp;&nbsp; &nbsp;local s = socket.udp()  --creates a UDP object
&nbsp;&nbsp; &nbsp;s:setpeername( &quot;74.125.115.104&quot;, 80 )  --Google website
&nbsp;&nbsp; &nbsp;local ip, sock = s:getsockname()
&nbsp;&nbsp; &nbsp;print( &quot;myIP:&quot;, ip, sock )
&nbsp;&nbsp; &nbsp;return ip
end</pre><p>The IP address in the above function is arbitrary &#8212; I used the Google address because I know it. You don&#8217;t even need to be connected to the internet for this function to return your IP address, but you must at least be on a local network.</p>
<h3>Listening for the server</h3>
<p>Now we are prepared to listen for the server. We will recognize the server because of the message <code>AwesomeGameServer</code>. Obviously, this could be any string; we are just going to match strings.</p><pre class="crayon-plain-tag">local function findServer( button )

&nbsp;&nbsp; &nbsp;local newServers = {}
&nbsp;&nbsp; &nbsp;local msg = &quot;AwesomeGameServer&quot;

&nbsp;&nbsp; &nbsp;local listen = socket.udp()
&nbsp;&nbsp; &nbsp;listen:setsockname( &quot;226.192.1.1&quot;, 11111 )  --this only works if the device supports multicast

&nbsp;&nbsp; &nbsp;local name = listen:getsockname()
&nbsp;&nbsp; &nbsp;if ( name ) then  --test to see if device supports multicast
&nbsp; &nbsp; &nbsp; &nbsp; listen:setoption( &quot;ip-add-membership&quot;, { multiaddr=&quot;226.192.1.1&quot;, interface = getIP() } )
&nbsp;&nbsp; &nbsp;else  --the device doesn't support multicast so we'll listen for broadcast
&nbsp; &nbsp; &nbsp; &nbsp; listen:close()  --first we close the old socket; this is important
&nbsp; &nbsp; &nbsp; &nbsp; listen = socket.udp()  --make a new socket
&nbsp; &nbsp; &nbsp; &nbsp; listen:setsockname( getIP(), 11111 )  --set the socket name to the real IP address
&nbsp;&nbsp; &nbsp;end

&nbsp;&nbsp; &nbsp;listen:settimeout( 0 )  --move along if there is nothing to hear

&nbsp;&nbsp; &nbsp;local stop

&nbsp;&nbsp; &nbsp;local counter = 0  --pulse counter

&nbsp;&nbsp; &nbsp;local function look()
&nbsp; &nbsp; &nbsp; &nbsp; repeat
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;local data, ip, port = listen:receivefrom()
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--print( &quot;data: &quot;, data, &quot;IP: &quot;, ip, &quot;port: &quot;, port )
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if data and data == msg then
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if not newServers[ip] then
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;    print( &quot;I hear a server:&quot;, ip, port )
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;local params = { [&quot;ip&quot;]=ip, [&quot;port&quot;]=22222 }
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;newServers[ip] = params
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end
&nbsp; &nbsp; &nbsp; &nbsp; until not data

&nbsp; &nbsp; &nbsp; &nbsp; counter = counter + 1
&nbsp; &nbsp; &nbsp; &nbsp; if counter == 20 then  --stop after 2 seconds
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;    stop()
&nbsp; &nbsp; &nbsp; &nbsp; end
&nbsp;&nbsp; &nbsp; end

     --pulse 10 times per second
&nbsp;&nbsp; &nbsp; local beginLooking = timer.performWithDelay( 100, look, 0 )

&nbsp;&nbsp; &nbsp; function stop()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;timer.cancel( beginLooking )
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;button.stopLooking = nil
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;evaluateServerList( newServers ) --do something with your found servers
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;listen:close()&nbsp; --never forget to close the socket!
&nbsp;&nbsp; &nbsp; end
&nbsp;&nbsp; &nbsp; button.stopLooking = stopLooking
end</pre><p>I put a lot of inline comments above, but I&#8217;ll elaborate on a few things:</p>
<ul>
<li>Notice that we account for the fact that not all devices have Multicast.</li>
<li>The <code>receivefrom()</code> function is going to just pull in anything that&#8217;s at that address, so we need to filter it. This is why we have the string message to compare with.</li>
<li>When two devices find each other, it can get painful if they both have a short duration. I like to make the server wait much longer than the clients. If the server is advertising, the client finds them pretty quick. Basically, I just want to avoid &#8220;Can you try that again? I missed it.&#8221;</li>
<li>In this example, I&#8217;m passing in a reference to the button that the player pressed to activate the function. I do this because so the player can push it again and stop broadcasting. If you don&#8217;t want to do that, you don&#8217;t need the button reference.</li>
</ul>
<p>So, at this point, we know how to let the game master be discovered by the players. The essential IP address required to use TCP is attached to the UDP message. Now that we have the game master&#8217;s IP address, we can connect to their device using TCP.</p>
<h3>Swapping strings</h3>
<p>Now we&#8217;ll discuss how to create a TCP server, connect to it, and send messages back and forth.</p>
<p>First, let&#8217;s discuss what TCP will provide and what it won&#8217;t. Like I said above, once we have a connection between devices, they&#8217;ll be able to send messages back and forth. These messages will just be strings. Imagine it like a text message app &#8212; in this case, the app on one device sends texts to the app on another device. These messages are then interpreted by the apps on each device and some action occurs.</p>
<h3>Security</h3>
<p>This tutorial will not go in depth about security, but a couple points should be covered:</p>
<ul>
<li>The server and client can only control each other as far as you allow it. As I&#8217;ve iterated several times now, TCP just sends and receives text strings. For a Pac-Man clone that could be controlled by a second device, about the only information the server would need is &#8220;BEGIN&#8221;, &#8220;UP&#8221;, &#8220;DOWN&#8221;, &#8220;LEFT&#8221;, and &#8220;RIGHT&#8221; &#8212; all else could simply be ignored.</li>
<li>You should <strong>never</strong> try to make your app accept functions that have been turned into a string. Let the client and the server have their own functions and just use the transmitted text to call the functions. If your app accepts functions, you open up a very serious security vulnerability, so don&#8217;t do it! Instead, just pass commands with parameters.</li>
</ul>
<p>In any case, don&#8217;t lie awake at night worrying about this. Neither iOS nor Android will let you damage someone&#8217;s device with such foolishness, but it may ruin the install of your game!</p>
<h3>Starting the server</h3>
<p>The server runs in a periodic loop. On each iteration of the loop, it checks to see if any clients want to join and whether connected clients sent a message. If the buffer has any messages to send out, it sends them. Here&#8217;s a basic TCP server module with further explanation following:</p><pre class="crayon-plain-tag">local S = {}

local socket = require( &quot;socket&quot; )

local clientList = {}
local clientBuffer = {}

S.getIP = function()
&nbsp;&nbsp; &nbsp;local s = socket.udp()
&nbsp;&nbsp; &nbsp;s:setpeername( &quot;74.125.115.104&quot;, 80 )
&nbsp;&nbsp; &nbsp;local ip, sock = s:getsockname()
&nbsp;&nbsp; &nbsp;print( &quot;myIP:&quot;, ip, sock )
&nbsp;&nbsp; &nbsp;return ip
end

S.createServer = function()

&nbsp;&nbsp; &nbsp;local tcp, err = socket.bind( S.getIP(), 22222 )  --create a server object
&nbsp;&nbsp; &nbsp;tcp:settimeout( 0 )

&nbsp;&nbsp; &nbsp;local function sPulse()
&nbsp; &nbsp; &nbsp; &nbsp; repeat
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;local client = tcp:accept()  --allow a new client to connect
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if client then
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     print( &quot;found client&quot; )
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; client:settimeout( 0 )  --just check the socket and keep going
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --TO DO: implement a way to check to see if the client has connected previously
                --consider assigning the client a session ID and use it on reconnect.
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clientList[#clientList+1] = client
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clientBuffer[client] = { &quot;hello_client\n&quot; }  --just including something to send below
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end
&nbsp; &nbsp; &nbsp; &nbsp; until not client
&nbsp; &nbsp; &nbsp; &nbsp; 
        local ready, writeReady, err = socket.select( clientList, clientList, 0 )
&nbsp; &nbsp; &nbsp; &nbsp; if err == nil then
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;    for i = 1, #ready do&nbsp; --list of clients who are available
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     local client = ready[i]
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local allData = {}  --this holds all lines from a given client

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; repeat
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;local data, err = client:receive()  --get a line of data from the client, if any
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if data then
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allData[#allData+1] = data
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; until not data

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ( #allData &gt; 0 ) then  --figure out what the client said to the server
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for i, thisData in ipairs( allData ) do
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print( &quot;thisData: &quot;, thisData )
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --do stuff with data
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end

&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for sock, buffer in pairs( clientBuffer ) do
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     for _, msg in pairs( buffer ) do  --might be empty
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;    local data, err = sock:send( msg )  --send the message to the client
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end
&nbsp; &nbsp; &nbsp; &nbsp; end
&nbsp;&nbsp; &nbsp;end

    --pulse 10 times per second
&nbsp;&nbsp; &nbsp;local serverPulse = timer.performWithDelay( 100, sPulse, 0 )

&nbsp;&nbsp; &nbsp;local function stopServer()
&nbsp; &nbsp; &nbsp; &nbsp; timer.cancel( serverPulse )  --cancel timer
&nbsp; &nbsp; &nbsp; &nbsp; tcp:close()
&nbsp; &nbsp; &nbsp; &nbsp; for i, v in pairs( clientList ) do
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;    v:close()
&nbsp; &nbsp; &nbsp; &nbsp; end
&nbsp;&nbsp; &nbsp;end
&nbsp;&nbsp; &nbsp;return stopServer
end

return S</pre><p>And that is a basic server. Let&#8217;s start at the top with some explanation:</p>
<ul>
<li><code>socket.bind()</code> creates a server object which you bind to the port of your choice. I used <code>11111</code>, but you can use any that we listed in the earlier section. Remember to close the TCP object when you shut down the server via the <code>stopServer()</code> function!</li>
<li><code>settimeout( 0 )</code> tells LuaSocket to move on if there&#8217;s no information waiting at the socket.</li>
<li><code>accept()</code> returns a client object which represents the connection to the other device. Each client will get their own object and each one will need to be closed when the game is done. We do this in the function at the bottom called <code>stopServer()</code>.</li>
<li><code>socket.select()</code> goes through our list of client connections to see which are available. Any that are not available are ignored but not closed.</li>
<li><code>receive()</code> receives one line of data. You can designate a line of data in a string by putting <code>\n</code> at the end. It&#8217;s simple and you&#8217;ll be able to create bite-sized pieces of data. This function is structured so that you end up with a numbered table of string lines. They are numbered in the order that they were received, but you can&#8217;t rely on the lines you send being received in the order you sent them. If this is important, and it often is, you&#8217;ll need to create a way for the server to know if a line is in the right order.</li>
<li>Next we go through the list of lines and interpret them. This is usually just a series of <code>if</code>&#8211;<code>then</code> statements with a liberal use of the <a href=http://docs.coronalabs.com/api/library/string/index.html target="_blank">string</a> library.</li>
<li>Finally, we send whatever is in the buffer. The buffer is another list of strings. Again, you can&#8217;t absolutely control the order in which they are received. You don&#8217;t have to use a buffer, but when you are using a multi-use device like a phone as a server, it&#8217;s a good idea. You may just <code>:send()</code> to a client socket at any time but the only way the device knows that the message didn&#8217;t go through is if the other device responds. If the other device is taking a call, it will ignore your message and the message will be lost. If you implement a buffer, it sends the message every pulse until something happens that removes the message from the buffer, however you&#8217;ll need to implement a way of knowing when to remove items from the buffer.</li>
</ul>
<h3>Connecting to the server</h3>
<p>Connecting to the server is much simpler:</p><pre class="crayon-plain-tag">local function connectToServer( ip, port )
&nbsp;&nbsp; &nbsp;local sock, err = socket.connect( ip, port )
&nbsp;&nbsp; &nbsp;if sock == nil then
&nbsp; &nbsp; &nbsp; &nbsp; return false
&nbsp;&nbsp; &nbsp;end
&nbsp;&nbsp; &nbsp;sock:settimeout( 0 )
&nbsp;&nbsp; &nbsp;sock:setoption( &quot;tcp-nodelay&quot;, true )  --disable Nagle's algorithm
&nbsp;&nbsp; &nbsp;sock:send( &quot;we are connected\n&quot; )
&nbsp;&nbsp; &nbsp;return sock
end</pre><p>To elaborate on this slightly:</p>
<ul>
<li><code>socket.connect</code> is pretty self explanatory: attempt to connect to the server at that address.</li>
<li><code>settimeout( 0 )</code> again lets the socket know that you want it to just check the socket and move on if there&#8217;s no incoming message.</li>
<li>Nagle&#8217;s algorithm is a standard function that causes the socket to aggregate data until the data is of a certain size, then send it. If you are just going to send &#8220;UP&#8221; and you want it sent right away, you&#8217;ll want this off.</li>
</ul>
<p>What&#8217;s not included in this example is a method to determine if the client is connecting for the first time or reconnecting (return session). This is outside the scope of this tutorial, but one option is to use a session ID which the client gets the first time it connects to the server. In this case, both the client and the server save the ID. Then, if the client loses the connection, this ID is sent upon reconnection and the server can update the client&#8217;s data with the new client socket.</p>
<h3>Client loop</h3>
<p>The final piece of the puzzle is the client loop. This will look very much like the server loop, but it never tries to accept connections.</p><pre class="crayon-plain-tag">local function createClientLoop( sock, ip, port )

&nbsp;&nbsp; &nbsp;local buffer = {}
&nbsp;&nbsp; &nbsp;local clientPulse

&nbsp;&nbsp; &nbsp;local function cPulse()
&nbsp; &nbsp; &nbsp; &nbsp; local allData = {}
&nbsp; &nbsp; &nbsp; &nbsp; local data, err

&nbsp; &nbsp; &nbsp; &nbsp; repeat
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;data, err = sock:receive()
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if data then
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allData[#allData+1] = data
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if ( err == &quot;closed&quot; and clientPulse ) then  --try again if connection closed
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     connectToServer( ip, port )
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data, err = sock:receive()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if data then
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;    allData[#allData+1] = data
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end
&nbsp; &nbsp; &nbsp; &nbsp; until not data

&nbsp; &nbsp; &nbsp; &nbsp; if ( #allData &gt; 0 ) then
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;    for i, thisData in ipairs( allData ) do
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     print( &quot;thisData: &quot;, thisData )
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --react to incoming data&nbsp;
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end
&nbsp; &nbsp; &nbsp; &nbsp; end

&nbsp; &nbsp; &nbsp; &nbsp; for i, msg in pairs( buffer ) do
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;    local data, err = sock:send(msg)
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if ( err == &quot;closed&quot; and clientPulse ) then  --try to reconnect and resend
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     connectToServer( ip, port )
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data, err = sock:send( msg )
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end
&nbsp; &nbsp; &nbsp; &nbsp; end
&nbsp;&nbsp; &nbsp;end

    --pulse 10 times per second
&nbsp;&nbsp; &nbsp;clientPulse = timer.performWithDelay( 100, cPulse, 0 )

&nbsp;&nbsp; &nbsp;local function stopClient()
&nbsp; &nbsp;     timer.cancel( clientPulse )  --cancel timer
&nbsp; &nbsp; &nbsp; &nbsp; clientPulse = nil
&nbsp; &nbsp; &nbsp; &nbsp; sock:close()
&nbsp;&nbsp; &nbsp;end
&nbsp;&nbsp; &nbsp;return stopClient
end</pre><p>Note that the client is always responsible for making the connection to the server. The server never tries to reach the client — it has enough to handle already. Beyond that, there isn&#8217;t anything clarify that wasn&#8217;t already covered in the server loop section.</p>
<h3>Conclusion</h3>
<p>I hope this tutorial helps you achieve your multiplayer dreams! While it&#8217;s not intended to be a comprehensive tutorial on networking, what I accomplished should help you get two devices talking with each other using TCP.</p>
<p>Thank you for reading and remember to check out <a href=http://www.legendofus.net/ target="_blank">Legend of Us Roleplaying Game</a> which inspired me to figure all of this out.</p>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2014/09/23/tutorial-local-multiplayer-with-udptcp/feed/</wfw:commentRss>
		<slash:comments>25</slash:comments>
		</item>
		<item>
		<title>Tutorial: Uploading files demystified</title>
		<link>/blog/2014/02/25/tutorial-uploading-files-demystified/</link>
		<comments>/blog/2014/02/25/tutorial-uploading-files-demystified/#comments</comments>
		<pubDate>Tue, 25 Feb 2014 20:10:05 +0000</pubDate>
		<dc:creator><![CDATA[Rob Miracle]]></dc:creator>
				<category><![CDATA[Tutorials, Tips and Demos]]></category>
		<category><![CDATA[network]]></category>
		<category><![CDATA[tutorial]]></category>
		<category><![CDATA[upload]]></category>

		<guid isPermaLink="false">/?p=56479</guid>
		<description><![CDATA[Uploading files to a web server can be a tricky process because a lot depends on the web server's features, abilities, and limits. This week's tutorial aims to demystify some of the complexity behind this process and includes a sample project for download and testing.]]></description>
				<content:encoded><![CDATA[<p>Uploading files to a web server can be a tricky process because a lot depends on the web server&#8217;s features, abilities, and limits. One might think that there&#8217;s a &#8220;standard&#8221; upload method, but unfortunately there&#8217;s not. How an Apache server running PHP handles things could be drastically different than a .NET server running Visual Basic or C#. Even within a family of servers sharing a common language, the rules vary from server to server and from upload script to upload script.</p>
<p>You must also be very careful about which files should be allowed to upload to your web server. Since you&#8217;re creating a script that anybody with the URL can run — and effectively send data to your server — you may open your server to being hacked unless you utilize caution and care. It&#8217;s quite easy with server-side scripts to allow the ability to write over critical files with malicious code, so if you don&#8217;t know what you&#8217;re doing on the server side, you may want to consider other options. In addition, your server may enforce limits on your upload abilities that are beyond your control. For example, many servers limit uploads to small files (under 2 MB), or they may limit the number of files that can be uploaded. All of these limitations must be considered before you begin implementing a file upload process.</p>
<h3>Before you begin</h3>
<p>Before you proceed with this tutorial, you should read <a href=http://www.php.net/manual/en/features.file-upload.php target="_blank" rel="noopener">this manual</a> to gain a clearer understanding of the entire process. This tutorial presents a &#8220;quick and dirty&#8221; method to upload files, but before you use this in production, you must make some adjustments and secure the script as necessary. You should anticipate that it&#8217;ll take some effort to get this right!</p>
<h3>Using &#8220;network.upload()&#8221;</h3>
<p>Corona&#8217;s <code>network.*</code> library contains an API called <a href=http://docs.coronalabs.com/daily/api/library/network/upload.html target="_blank" rel="noopener">network.upload()</a> which is a simple method for uploading files to a server, assuming that your server handles the simple method of uploading files using <code>HTTP PUT</code>. Most existing scripts that accept file upload probably won&#8217;t work with <a href=http://docs.coronalabs.com/daily/api/library/network/upload.html target="_blank" rel="noopener">network.upload()</a> because they&#8217;re looking for an <code>HTTP POST</code> form-based MIME multi-part upload format. Corona&#8217;s <a href=http://docs.coronalabs.com/daily/api/library/network/upload.html target="_blank" rel="noopener">network.upload()</a> API does not talk to these kinds of scripts, but we&#8217;ll discuss this further in a bit. First, let&#8217;s look at the Corona side&#8230;</p>
<h3>The Corona script</h3>
<p></p><pre class="crayon-plain-tag">-- Callback function to handle the upload events that are generated.
-- There will be several events: one to indicate the start and end of the
-- process and several to indicate the progress (depends on the file size).
-- Always test for your error conditions!

local function uploadListener( event )
   if ( event.isError ) then
      print( &quot;Network Error.&quot; )

      -- This is likely a time out or server being down. In other words,
      -- It was unable to communicate with the web server. Now if the
      -- connection to the web server worked, but the request is bad, this
      -- will be false and you need to look at event.status and event.response
      -- to see why the web server failed to do what you want.
   else
      if ( event.phase == &quot;began&quot; ) then
         print( &quot;Upload started&quot; )
      elseif ( event.phase == &quot;progress&quot; ) then
         print( &quot;Uploading... bytes transferred &quot;, event.bytesTransferred )
      elseif ( event.phase == &quot;ended&quot; ) then
         print( &quot;Upload ended...&quot; )
         print( &quot;Status:&quot;, event.status )
         print( &quot;Response:&quot;, event.response )
      end
   end
end

-- Sepcify the URL of the PHP script to upload to. Do this on your own server.
-- Also define the method as &quot;PUT&quot;.
local url = &quot;http://yourwebserver.com/somepath/upload.php&quot;
local method = &quot;PUT&quot;

-- Set some reasonable parameters for the upload process:
local params = {
   timeout = 60,
   progress = true,
   bodyType = &quot;binary&quot;
}

-- Specify what file to upload and where to upload it from.
-- Also, set the MIME type of the file so that the server knows what to expect.
local filename = &quot;image.jpg&quot;
local baseDirectory = system.ResourceDirectory
local contentType = &quot;image/jpeg&quot;  --another option is &quot;text/plain&quot;

-- There is no standard way of using HTTP PUT to tell the remote host what
-- to name the file. We'll make up our own header here so that our PHP script
-- expects to look for that and provides the name of the file. Your PHP script
-- needs to be &quot;hardened&quot; because this is a security risk. For example, someone
-- could pass in a path name that might try to write arbitrary files to your
-- server and overwrite critical system files with malicious code.
-- Don't assume &quot;This won't happen to me!&quot; because it very well could.
local headers = {}
headers.filename = filename
params.headers = headers

network.upload( url , method, uploadListener, params, filename, baseDirectory, contentType )</pre><p></p>
<h3>The script demystified&#8230;</h3>
<p>As with all <code>network.*</code> API calls, this operates asynchronously, meaning that it will return to your program immediately and process the upload in the background. However, you need to know the status of the upload, in particular when it completes, which is handled by the event listener function:</p><pre class="crayon-plain-tag">local function uploadListener( event )
   if ( event.isError ) then
      print( &quot;Network Error.&quot; )
      -- This is likely a result of a timeout or the server being down.
      -- In other words, it was unable to communicate with the web server.
      -- If the connection to the web server worked, but the request is bad, this
      -- will be 'false' and you need to look at 'event.status' and 'event.response'
      -- to see why the web server failed to process your request.
   else
      if ( event.phase == &quot;began&quot; ) then
         print( &quot;Upload started&quot; )
      elseif ( event.phase == &quot;progress&quot; ) then
         print( &quot;Uploading... bytes transfered &quot;, event.bytesTransfered )
      elseif ( event.phase == &quot;ended&quot; ) then
         print( &quot;Upload ended...&quot; )
         print( &quot;Status:&quot;, event.status )
         print( &quot;Response:&quot;, event.response )
      end
   end
end</pre><p>Let&#8217;s inspect this function in more detail. The first thing you must check is whether a network error occurred. This is returned in the <code>event.isError</code> attribute. In network programming, it&#8217;s important to understand that this error may indicate that the server is down, it&#8217;s unreachable, or it&#8217;s timing out. Effectively, it means that you never successfully communicated with the server.</p>
<p>You can successfully connect to and interact with the web server, asking it to do something that it can&#8217;t, but it will report a &#8220;success&#8221; in regards to the <code>isError</code> attribute. In other words, regardless of whether the server sends you a &#8220;right&#8221; or &#8220;wrong&#8221; response, you technically had a successful transaction with it. Thus, the <code>else</code> condition block is where you can inspect and handle the various phases of the upload. For instance, in the <code>"began"</code> phase, you may choose to display a <a href=http://docs.coronalabs.com/api/library/widget/newProgressView.html target="_blank" rel="noopener">widget.newProgressView()</a>. Then in the <code>"progress"</code> phase, increment that widget&#8217;s status based on the amount of bytes transmitted. Finally, the <code>"ended"</code> phase lets you know that the web server has completed the upload process.</p>
<p>All finished, correct? Not so fast! The file may still have failed to upload for various reasons, for example, the file was too large, it was not a valid file name, or some permission issue on the server prevented it from uploading. Thus, you should check the <code>event.status</code> attribute which will hold the HTTP &#8220;result&#8221; code, such as <strong>201</strong> (success) or <strong>403</strong> (permission denied). Depending on the server, there may be additional information in the <code>event.response</code> attribute that can indicate where the problem resided.</p>
<p>Now, let&#8217;s re-inspect the various variables and tables required for the <a href=http://docs.coronalabs.com/daily/api/library/network/upload.html target="_blank" rel="noopener">network.upload()</a> API call. These include:</p>
<ul>
<li>The URL of the server script to execute.</li>
<li>The HTTP method (in this case we&#8217;re going to use &#8220;PUT&#8221;).</li>
<li>Some parameters to configure the API Call, including the timeout, body type, and whether you want progress updates.</li>
<li>The filename to upload.</li>
<li>The source directory where the file can be found.</li>
<li>A MIME type string indicating the file type for the server&#8217;s use.</li>
<li>A custom header for the PHP script (we&#8217;ll discuss this further down).</li>
</ul>
<p></p><pre class="crayon-plain-tag">-- Sepcify the URL of the PHP script to upload to. Do this on your own server.
-- Also define the method as &quot;PUT&quot;.
local url = &quot;http://yourwebserver.com/somepath/upload.php&quot;
local method = &quot;PUT&quot;

-- Set some reasonable parameters for the upload process:
local params = {
   timeout = 60,
   progress = true,
   bodyType = &quot;binary&quot;
}

-- Specify what file to upload and where to upload it from.
-- Also, set the MIME type of the file so that the server knows what to expect.
local filename = &quot;image.jpg&quot;
local baseDirectory = system.ResourceDirectory
local contentType = &quot;image/jpeg&quot;  --another option is &quot;text/plain&quot;

local headers = {}
headers.filename = filename
params.headers = headers</pre><p>Because this method has no way of telling the server the name of the file to save, we must create a special header named <code>filename</code> that will contain that name (the file we want to use on the remote server). With this step done, add the <code>headers</code> table to the <code>params</code> table and then call <a href=http://docs.coronalabs.com/daily/api/library/network/upload.html target="_blank" rel="noopener">network.upload()</a>:</p><pre class="crayon-plain-tag">network.upload( url , method, uploadListener, params, filename, baseDirectory, contentType )</pre><p></p>
<h3>The PHP script</h3>
<p>For usage with this tutorial, we&#8217;re providing a sample <a href=https://gist.github.com/coronarob/221e23618615ae2ff0b9?#file-upload-php target="_blank" rel="noopener">PHP script for download</a>. This script is fairly simple and straightforward, but unless you know PHP, it will look intimidating. Before you attempt to modify it for your own project, there are a few important things to understand:</p>
<h4>1. Security</h4>
<p>When you write a script online, it&#8217;s 100% your responsibility to ensure that it cannot be easily hacked. Scripts that write files to the server are the most vulnerable. You may think that only your app will use it, but once it&#8217;s on a website, anybody can execute it, figure out the parameters and the methods, and find holes to exploit. We&#8217;ve taken some basic steps to prevent this, but you need to take it the rest of the way. This script lets the caller set the filename which is inherently dangerous since people can put in tricks to create false paths that may let them write files to arbitrary locations. Your script should <strong>never</strong> run at elevated permissions, and your file system should be <strong>read-only</strong> wherever there are executable script files or system binary executables. Finally, you should do your best to scrub any provided file name before putting this code into production. The safest thing is to prevent the caller from specifying the filename, but this can create usability issues in regards to keeping the files organized.</p>
<h4>2. Know your server&#8217;s limits</h4>
<p>Many PHP servers, if they allow uploads at all, will have very tight limits on the file size that can be uploaded. The code above has a size limit check, but it only works if the server allows larger files and you want to limit the size. In this sample, we allow up to a 5 MB file, but the server itself may only allow 1 MB. The server may not even reach your script if the file is too large, so it&#8217;s your responsibility to control the limits. Many websites live in a shared environment with other websites and you should be a good network citizen!</p>
<h4>3. Handling files of the same name</h4>
<p>The code above uses a simple (but somewhat flawed) method of adding an increasing sequence number to the end of the string. It stops incrementing the number at 100. The <code>while</code> loop that checks for duplicate file names can&#8217;t run forever and after you hit 100 uploads of the same name, it will start overwriting the 100th file. Again, this is <strong>not production-ready script</strong> and you must adapt it to your needs. Another potential method is to get a list of files, find the one with the highest number, parse the name from the number, and increment it.</p>
<h4>4. The upload directory</h4>
<p>This script assumes that you&#8217;ll create a folder named <strong>upload</strong> as a child folder of where this script is located, but this may not be the best option for your website. This upload folder must have <strong>write</strong> permissions for the ID your web server runs at. Generally the web server will not run with an ID or within a group that your account has access to. This means the folder needs to be <strong>World writable</strong>. As a safety precaution, you probably don&#8217;t want the folder to have <strong>READ</strong> or <strong>EXECUTE/LIST</strong> privileges for the <strong>World</strong> user. Finally, your server may need to dump the files in a completely different location in your server tree, so you must figure out that path and adjust the PHP script accordingly.</p>
<h3>In summary</h3>
<p>As you can see, the act of uploading files can be a complex task. Hopefully this tutorial has shed some light on the process. As always, please leave your questions and comments below. You may also <a href=https://gist.github.com/coronarob/221e23618615ae2ff0b9?#file-upload-php target="_blank" rel="noopener">download the PHP script</a> based on this tutorial if you wish to use it as a foundation for your own implementation.</p>
<hr />
]]></content:encoded>
			<wfw:commentRss>/blog/2014/02/25/tutorial-uploading-files-demystified/feed/</wfw:commentRss>
		<slash:comments>22</slash:comments>
		</item>
		<item>
		<title>Wednesday FAQs: Miscellaneous Questions</title>
		<link>/blog/2013/04/24/faq-wednesday-miscellaneous-questions/</link>
		<comments>/blog/2013/04/24/faq-wednesday-miscellaneous-questions/#comments</comments>
		<pubDate>Wed, 24 Apr 2013 23:19:37 +0000</pubDate>
		<dc:creator><![CDATA[tom]]></dc:creator>
				<category><![CDATA[FAQ]]></category>
		<category><![CDATA[corona]]></category>
		<category><![CDATA[CoronaSDK]]></category>
		<category><![CDATA[network]]></category>
		<category><![CDATA[Widgets]]></category>

		<guid isPermaLink="false">http://blog.coronalabs.com/?p=32583</guid>
		<description><![CDATA[It's Wednesday and time for another FAQ session. Here are some frequently asked questions (FAQ).]]></description>
				<content:encoded><![CDATA[<p><img src="http://blog.coronalabs.com/wp-content/uploads/2013/01/FAQ.png" alt="FAQ Icon" class="alignright size-full wp-image-28552" />It&#8217;s Wednesday and time for another FAQ session. Here are some frequently asked questions (FAQ).</p>
<h2>1. Why doesn&#8217;t native.setActivityIndicator work in my code?</h2>
<p><strong>native.setActivityIndicator</strong> cannot be set and cleared in the same code chunk. All display objects (including native objects) are not rendered on the screen until the code chunk ends.</p>
<p>The following is the wrong way to set the Activity Indicator. The activity indicator is not set until AFTER the function ends, and then it&#8217;s cleared. (Note: There is a current bug in Android where the activity indicator does not turn off in this example.)</p>
<p></p><pre class="crayon-plain-tag">native.setActivityIndicator( true )
for i = 1, 1000 do
    print( &quot;i = &quot; .. i )
end
native.setActivityIndicator( false )</pre><p></p>
<p>This is the right way to set the Activity Indicator. The indicator is cleared after one second. The problem with this approach is the activity indicator is set after the <strong>for loop</strong> executes so it&#8217;s not displaying the activity indicator during the time the <strong>for loop</strong> is running.</p>
<p></p><pre class="crayon-plain-tag">native.setActivityIndicator( true )
for i = 1, 1000 do
    print( &quot;i = &quot; .. i )
end

-- Turn off the indicator after one second
timer.performWithDelay( 1000, function() native.setActivityIndicator( false ) end )</pre><p></p>
<p>The solution to the above problem would be running the <strong>for loop</strong> code in a timer function. You start the activity indicator before the timer starts and turn off the activity indicator in the timer function.</p>
<p></p><pre class="crayon-plain-tag">native.setActivityIndicator( true )
timer.performWithDelay( 100,
    function()
        for i = 1, 1000 do
            print( &quot;i = &quot; .. i )
        end
        native.setActivityIndicator( false )
    end
)</pre><p></p>
<h2>2. I&#8217;m using Dynamic Scaling and don&#8217;t see native textField and textBox font sizes changing when I test on different devices.</h2>
<p>When you specify the target screen size in <strong>config.lua</strong>, this allows display objects to scale depending on the native screen size of the device. The one exception is fonts used in native text fields. The fonts don&#8217;t automatically scale so the font size needs to be adjusted manually. You can determine the correct size by either reading the device type (using <strong>system.getInfo( &#8220;model&#8221; )</strong>) or reading the scaling factor of the device (<strong>display.contentScaleX</strong> and <strong>display.contentScaleY</strong>). For Android, we recently added some new <strong>system.getInfo</strong> API calls in our Daily builds that may help: <strong>&#8220;androidDisplayWidthInInches&#8221;</strong>, <strong>&#8220;androidDisplayHeightInInches&#8221;</strong>, <strong>&#8220;androidDisplayXDpi&#8221;</strong>, and <strong>&#8220;androidDisplayYDpi&#8221;</strong>.</p>
<h2>3. My network.request calls are no longer working starting with build 1076. What happen?</h2>
<p>Starting with build 1053 we added a default <strong>Content-Type</strong> field of &#8220;text/plain&#8221; for all platforms. This was done to be consistent among the platforms. Before build 1053 we relied on the OS to provide the <strong>Content-Type</strong> field if it was missing from the <strong>network.request</strong>. If your <strong>network.request</strong> contains a <strong>parms.bodyType</strong> equal to &#8220;binary&#8221;, or your <strong>parms.body</strong> contains a table (specifying filename), <strong>Content-Type</strong> will be set to &#8221; application/octet-stream&#8221;. If your <strong>network.request</strong> specifies a value for <strong>Content-Type</strong>, it will override the default value. In all other cases it will be set to &#8220;text/plain&#8221;.</p>
<p></p><pre class="crayon-plain-tag">-- Example code to log in with username/password

local function networkListener( event )
    print( &quot;networkListener called&quot;, event.response )
end

local user = &quot;myName&quot;
local password = &quot;abc&quot;

local headers = {}
headers[&quot;Content-Type&quot;] = &quot;application/x-www-form-urlencoded&quot;

local body = &quot;login=&quot;..user..&quot;&amp;password=&quot;..password
local params = {}
params.headers = headers
params.body = body
-- go to http://requestb.in/ to set up an test page
network.request(&quot;http://requestb.in/&quot;, &quot;POST&quot;, networkListener, params )</pre><p></p>
<h2>4. Display.save now shows a white background in the saved image. The background use to be black.</h2>
<p>We had a blending issue with <strong>display.save</strong> captures and it was fixed by making the background full alpha behind the objects being saved. This changed occurred in build 1079. If you are saving a group, the background will be transparent, which is undefined. Before 1079 we made the background black, which was causing problems for some users. Now the transparent areas may show up as either black or white when saving to a .JPEG file. If you save it to a .PNG file (which <strong>display.save</strong> now supports), the background will be transparent and take on the existing background when displayed.</p>
<p>Specifying a .PNG file in <strong>display.save</strong> is one solution to the problem when saving a group. The other is creating a black <strong>display.newRect</strong> the size of your group and filling it with black and inserting it behind all your other group objects. You do this before calling <strong>display.save</strong> and remove the newRect object afterwards.</p>
<h2>5. I&#8217;m using the released version of Corona SDK and seeing bugs in Widgets. What can I do?</h2>
<p>The good news is we decided to open-source our Widgets 2.0 library. We have put the library up on <a href=https://github.com/coronalabs/>GitHub</a> that you can include in your own project. This is the same code we include in our Daily Builds and our plan is to keep both in sync. This means Starters, who don&#8217;t have access to our Daily Builds, can still use the latest Widget library. If you do find a Widget bug, please submit a bug report and a small test project demonstrating the bug. In the report please mention the Corona build you&#8217;re using and which version of the Widget library you&#8217;re reporting. Get more information <a href=http://forums.coronalabs.com/topic/34183-widgets-20-open-source/?hl=github>here</a></p>
<p>That&#8217;s it for today&#8217;s questions. I hope you enjoyed them and even learned a few things.</p>
]]></content:encoded>
			<wfw:commentRss>/blog/2013/04/24/faq-wednesday-miscellaneous-questions/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
	</channel>
</rss>
